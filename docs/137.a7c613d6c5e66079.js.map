{"version":3,"file":"137.a7c613d6c5e66079.js","mappings":"iNAaA,MAAMA,UAA0BC,KAG7BC,cACqBC,IAAdC,KAAKC,MAAoBD,KAAKE,cACrC,CAGAC,cAAcC,GAEX,IAAIC,EAAI,IAAIC,KAAYF,GAAO,UAE1BJ,KAAKO,UAASP,KAAKO,QAAU,CAAC,GAEnCC,OAAOC,OAAOT,KAAKO,QAAS,CACxBG,KAAML,EAAEM,MAAM,QACdC,OAAQP,EAAEM,MAAM,UAChBE,MAAOR,EAAEM,MAAM,WAGnBX,KAAKc,aAAaV,EACrB,CAGMW,eAAeC,GAAM,qCAEnBA,IACFA,EAAO,EACPC,EAAKC,mBAAoB,GAG5B,IAAIC,EAAMF,EAAKG,aAAaC,OAAOC,IAAIL,EAAKhB,MAE5C,GAAKkB,KAAQH,GAAQG,EAAIG,IAAIC,QAK7B,SAAOC,MAAKP,EAAKQ,SAAUN,EAAIG,IAAIN,GAAOG,EAAIf,IAAIY,IAAOU,KAAKC,IAEvDA,IACDA,EAAEC,UAAYX,EAAKY,OACnBF,EAAEG,QAAUb,EAAKhB,MAEbgB,EAAKF,eAAeC,EAAK,YAVzBC,EAAKC,iBAYZ,EAtBqB,EAuB3B,CAGAa,kBACG,IAAK/B,KAAKO,QAAS,OAEnB,IAAIyB,EAAKhC,KAAKoB,YAEd,GAAIpB,KAAKO,QAAQM,aAEPb,KAAKC,UAIf,GAAID,KAAKiC,qBAAsB,QACrBjC,KAAKiC,qBAGZ,IAAIC,EAAKlC,KAAKmC,gBACd,IAAKD,EAGF,mBADOlC,KAAKC,KAKfD,KAAKe,iBAAiBW,KAAK,KAExBQ,EAAGE,gBAAgBT,GAAeA,EAAEC,YAAc5B,KAAK6B,QAAYF,EAAEG,UAAY9B,KAAKC,MAEtFD,KAAK+B,iBAAe,EACtB,SACO/B,KAAKqC,gBACbC,aAAatC,KAAKqC,wBACXrC,KAAKqC,gBAEZrC,KAAKiC,sBAAuB,EAE5BM,sBAAsB,IAAMvC,KAAK+B,uBAC7B,CAEJ,IAAIS,EAAYC,KAAKC,IAAIV,EAAGW,WAAY,IAExC,KAAM3C,KAAKC,KAAO+B,EAAGX,OAAOC,IAAIC,OAC7B,KAAIvB,KAAKO,QAAQK,OAKd,mBADOZ,KAAKC,KAHZD,KAAKC,KAAO,EACZuC,EAAYC,KAAKC,IAAI,IAAM,EAAEF,EAG7B,CAINxC,KAAKqC,gBAAkBO,WAAW,IAAM5C,KAAK+B,kBAAmBS,EAAS,CAE/E,CAGAtC,eACG,YAAKD,KAAO,EAELD,KAAKe,iBAAiBW,KAAK,KAC/B1B,KAAK+B,kBACE/B,MAEb,CAGA6C,YAAkBC,EAAKd,EAAI5B,GAAK,0BAC7B,IAAK4B,EAAGe,OACNC,eAAQC,MAAM,8BACP,KAGT,IAAIC,EAAU,IAAItD,EAAkBkD,EAAKd,GAEzC,GAAIkB,EAAQC,iBACTH,eAAQC,MAAM,qDACP,KAKV,GAFAC,EAAQ/C,cAAcC,IAEjB4B,EAAGe,OAAOK,QAAUpB,EAAGoB,OAAQ,CACjC,IAAI9B,EAAMU,EAAGoB,OAAOC,MAAM,KAC1BrB,EAAGe,OAAOK,OAAS9B,EAAI,GACnBA,EAAI,KAAIU,EAAGe,OAAOO,OAAOF,OAAS9B,EAAI,IACtCA,EAAI,KAAIU,EAAGe,OAAOQ,OAAOH,OAAS9B,EAAI,GAAC,CAG9C4B,SAAQrB,OAAS,UAAY2B,yBAEtBC,SAAgBX,EAAKd,EAAGe,OAAQ,QAAQrB,KAAK,KACjDwB,EAAQQ,qBACDR,EAAQhD,gBACf,EA3B0B,EA4BhC","names":["TGraphTimePainter","ObjectPainter","redraw","undefined","this","step","startDrawing","decodeOptions","opt","d","DrawOptions","options","Object","assign","once","check","repeat","first","storeDrawOpt","drawPrimitives","indx","_this","_doing_primitives","lst","getObject","fSteps","arr","length","draw","getDom","then","p","$grtimeid","selfid","$grstep","continueDrawing","gr","wait_animation_frame","pp","getPadPainter","cleanPrimitives","running_timeout","clearTimeout","requestAnimationFrame","sleeptime","Math","max","fSleepTime","setTimeout","static","dom","fFrame","console","error","painter","getMainPainter","fTitle","split","fXaxis","fYaxis","internals","TH1Painter","addToPadPrimitives"],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/hist/TGraphTimePainter.mjs"],"sourcesContent":["import { internals } from '../core.mjs';\nimport { DrawOptions } from '../base/BasePainter.mjs';\nimport { ObjectPainter } from '../base/ObjectPainter.mjs';\nimport { TH1Painter } from '../hist2d/TH1Painter.mjs';\nimport { draw } from '../draw.mjs';\n\n\n/**\n * @summary Painter for TGraphTime object\n *\n * @private\n */\n\nclass TGraphTimePainter extends ObjectPainter {\n\n   /** @summary Redraw object */\n   redraw() {\n      if (this.step === undefined) this.startDrawing();\n   }\n\n   /** @summary Decode drawing options */\n   decodeOptions(opt) {\n\n      let d = new DrawOptions(opt || 'REPEAT');\n\n      if (!this.options) this.options = {};\n\n      Object.assign(this.options, {\n          once: d.check('ONCE'),\n          repeat: d.check('REPEAT'),\n          first: d.check('FIRST')\n      });\n\n      this.storeDrawOpt(opt);\n   }\n\n   /** @summary Draw primitives */\n   async drawPrimitives(indx) {\n\n      if (!indx) {\n         indx = 0;\n         this._doing_primitives = true;\n      }\n\n      let lst = this.getObject()?.fSteps.arr[this.step];\n\n      if (!lst || (indx >= lst.arr.length)) {\n         delete this._doing_primitives;\n         return;\n      }\n\n      return draw(this.getDom(), lst.arr[indx], lst.opt[indx]).then(p => {\n\n         if (p) {\n            p.$grtimeid = this.selfid; // indicator that painter created by ourself\n            p.$grstep = this.step; // remember step\n         }\n         return this.drawPrimitives(indx+1);\n\n      });\n   }\n\n   /** @summary Continue drawing */\n   continueDrawing() {\n      if (!this.options) return;\n\n      let gr = this.getObject();\n\n      if (this.options.first) {\n         // draw only single frame, cancel all others\n         delete this.step;\n         return;\n      }\n\n      if (this.wait_animation_frame) {\n         delete this.wait_animation_frame;\n\n         // clear pad\n         let pp = this.getPadPainter();\n         if (!pp) {\n            // most probably, pad is cleared\n            delete this.step;\n            return;\n         }\n\n         // draw ptrimitives again\n         this.drawPrimitives().then(() => {\n            // clear primitives produced by previous drawing to avoid flicking\n            pp.cleanPrimitives(p => { return (p.$grtimeid === this.selfid) && (p.$grstep !== this.step); });\n\n            this.continueDrawing();\n         });\n      } else if (this.running_timeout) {\n         clearTimeout(this.running_timeout);\n         delete this.running_timeout;\n\n         this.wait_animation_frame = true;\n         // use animation frame to disable update in inactive form\n         requestAnimationFrame(() => this.continueDrawing());\n      } else {\n\n         let sleeptime = Math.max(gr.fSleepTime, 10);\n\n         if (++this.step > gr.fSteps.arr.length) {\n            if (this.options.repeat) {\n               this.step = 0; // start again\n               sleeptime = Math.max(5000, 5*sleeptime); // increase sleep time\n            } else {\n               delete this.step;    // clear indicator that animation running\n               return;\n            }\n         }\n\n         this.running_timeout = setTimeout(() => this.continueDrawing(), sleeptime);\n      }\n   }\n\n   /** @ummary Start drawing of graph time */\n   startDrawing() {\n      this.step = 0;\n\n      return this.drawPrimitives().then(() => {\n         this.continueDrawing();\n         return this;\n      });\n   }\n\n   /** @summary Draw TGraphTime object */\n   static async draw(dom, gr, opt) {\n      if (!gr.fFrame) {\n        console.error('Frame histogram not exists');\n        return null;\n      }\n\n      let painter = new TGraphTimePainter(dom, gr);\n\n      if (painter.getMainPainter()) {\n         console.error('Cannot draw graph time on top of other histograms');\n         return null;\n      }\n\n      painter.decodeOptions(opt);\n\n      if (!gr.fFrame.fTitle && gr.fTitle) {\n         let arr = gr.fTitle.split(\";\");\n         gr.fFrame.fTitle = arr[0];\n         if (arr[1]) gr.fFrame.fXaxis.fTitle = arr[1];\n         if (arr[2]) gr.fFrame.fYaxis.fTitle = arr[2];\n      }\n\n      painter.selfid = 'grtime_' + internals.id_counter++; // use to identify primitives which should be clean\n\n      return TH1Painter.draw(dom, gr.fFrame, 'AXIS').then(() => {\n         painter.addToPadPrimitives();\n         return painter.startDrawing();\n      });\n   }\n\n} // class TGraphTimePainter\n\nexport { TGraphTimePainter };\n"],"x_google_ignoreList":[0]}