{"version":3,"file":"969.4da6fba206d57e9b.js","mappings":"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","names":["THStackPainter","ObjectPainter","constructor","dom","stack","opt","super","this","firstpainter","painters","cleanup","getPadPainter","cleanPrimitives","objp","indexOf","buildStack","fHists","nhists","arr","length","lst","create","clTList","Add","clone","i","hnext","hnextopt","hprev","fNbins","fXaxis","fXmin","fXmax","console","warn","fName","Clear","n","fArray","fStack","getMinMax","iserr","min","max","getObject","pad","getRootPad","getHistMinMax","hist","witherr","res","domin","domax","fMinimum","kNoZoom","fMaximum","i1","i2","j1","j2","first","TestBit","EAxisBits","fFirst","fLast","_typename","clTH2","fYaxis","j","val","getBinContent","err","getBinError","getBin","options","nostack","resh","Math","adjustRange","ndim","fLogy","fLogz","kmin","log10","kmax","gStyle","max0","min0","zoomed","hopt","drawNextHisto","indx","pad_painter","_this","hlst","rindx","horder","fOption","toUpperCase","draw_errors","_pfc","_plc","_pmc","mp","getMainPainter","isFunc","createAutoColor","icolor","fFillColor","fLineColor","fMarkerColor","subpad_painter","getSubPadPainter","prev_name","selectCurrentPad","this_pad_name","hdraw_func","getDom","then","subp","push","$baseh","decodeOptions","Object","assign","same","has_errors","fHistogram","hasErrors","fSumw2","k","nhist","d","DrawOptions","check","pads","remain","dolego","errors","createHistogram","histos","numhistos","histo","fTitle","h0","h","fLabels","updateObject","obj","matchObjectType","src","mm","minimum","maximum","_checked_zooming","ymin","ymax","zmin","zmax","did_update","redraw","static","painter","skip_drawing","ensureTCanvas","TH1Painter","TH2Painter","doingDraw","fPrimitives","log","p","divide","no_histogram","addToPadPrimitives","$secondary","$primary"],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/hist/THStackPainter.mjs"],"sourcesContent":["import { clone, create, createHistogram, isFunc, gStyle, clTList, clTH2, kNoZoom } from '../core.mjs';\nimport { DrawOptions } from '../base/BasePainter.mjs';\nimport { ObjectPainter, EAxisBits } from '../base/ObjectPainter.mjs';\nimport { TH1Painter } from './TH1Painter.mjs';\nimport { TH2Painter } from './TH2Painter.mjs';\nimport { ensureTCanvas } from '../gpad/TCanvasPainter.mjs';\n\n\n/**\n * @summary Painter class for THStack\n *\n * @private\n */\n\nclass THStackPainter extends ObjectPainter {\n\n   /** @summary constructor\n     * @param {object|string} dom - DOM element for drawing or element id\n     * @param {object} stack - THStack object\n     * @param {string} [opt] - draw options */\n   constructor(dom, stack, opt) {\n      super(dom, stack, opt);\n      this.firstpainter = null;\n      this.painters = []; // keep painters to be able update objects\n   }\n\n   /** @summary Cleanup THStack painter */\n   cleanup() {\n      this.getPadPainter()?.cleanPrimitives(objp => { return (objp === this.firstpainter) || (this.painters.indexOf(objp) >= 0); });\n      delete this.firstpainter;\n      delete this.painters;\n      super.cleanup();\n   }\n\n   /** @summary Build sum of all histograms\n     * @desc Build a separate list fStack containing the running sum of all histograms */\n   buildStack(stack) {\n      if (!stack.fHists) return false;\n      let nhists = stack.fHists.arr.length;\n      if (nhists <= 0) return false;\n      let lst = create(clTList);\n      lst.Add(clone(stack.fHists.arr[0]), stack.fHists.opt[0]);\n      for (let i = 1; i < nhists; ++i) {\n         let hnext = clone(stack.fHists.arr[i]),\n             hnextopt = stack.fHists.opt[i],\n             hprev = lst.arr[i-1];\n\n         if ((hnext.fNbins != hprev.fNbins) ||\n             (hnext.fXaxis.fXmin != hprev.fXaxis.fXmin) ||\n             (hnext.fXaxis.fXmax != hprev.fXaxis.fXmax)) {\n            console.warn(`When drawing THStack, cannot sum-up histograms ${hnext.fName} and ${hprev.fName}`);\n            lst.Clear();\n            return false;\n         }\n\n         // trivial sum of histograms\n         for (let n = 0; n < hnext.fArray.length; ++n)\n            hnext.fArray[n] += hprev.fArray[n];\n\n         lst.Add(hnext, hnextopt);\n      }\n      stack.fStack = lst;\n      return true;\n   }\n\n   /** @summary Returns stack min/max values */\n   getMinMax(iserr) {\n      let min = 0, max = 0,\n          stack = this.getObject(),\n          pad = this.getPadPainter().getRootPad(true);\n\n      const getHistMinMax = (hist, witherr) => {\n         let res = { min: 0, max: 0 },\n             domin = true, domax = true;\n         if (hist.fMinimum !== kNoZoom) {\n            res.min = hist.fMinimum;\n            domin = false;\n         }\n         if (hist.fMaximum !== kNoZoom) {\n            res.max = hist.fMaximum;\n            domax = false;\n         }\n\n         if (!domin && !domax) return res;\n\n         let i1 = 1, i2 = hist.fXaxis.fNbins, j1 = 1, j2 = 1, first = true;\n\n         if (hist.fXaxis.TestBit(EAxisBits.kAxisRange)) {\n            i1 = hist.fXaxis.fFirst;\n            i2 = hist.fXaxis.fLast;\n         }\n\n         if (hist._typename.indexOf(clTH2) === 0) {\n            j2 = hist.fYaxis.fNbins;\n            if (hist.fYaxis.TestBit(EAxisBits.kAxisRange)) {\n               j1 = hist.fYaxis.fFirst;\n               j2 = hist.fYaxis.fLast;\n            }\n         }\n         for (let j = j1; j <= j2; ++j)\n            for (let i = i1; i <= i2; ++i) {\n               let val = hist.getBinContent(i, j),\n                   err = witherr ? hist.getBinError(hist.getBin(i,j)) : 0;\n               if (domin && (first || (val-err < res.min))) res.min = val-err;\n               if (domax && (first || (val+err > res.max))) res.max = val+err;\n               first = false;\n           }\n\n         return res;\n      };\n\n      if (this.options.nostack) {\n         for (let i = 0; i < stack.fHists.arr.length; ++i) {\n            let resh = getHistMinMax(stack.fHists.arr[i], iserr);\n            if (i == 0) {\n               min = resh.min; max = resh.max;\n             } else {\n               min = Math.min(min, resh.min);\n               max = Math.max(max, resh.max);\n            }\n         }\n      } else {\n         min = getHistMinMax(stack.fStack.arr[0], iserr).min;\n         max = getHistMinMax(stack.fStack.arr[stack.fStack.arr.length-1], iserr).max;\n      }\n\n      const adjustRange = () => {\n         if (pad && (this.options.ndim == 1 ? pad.fLogy : pad.fLogz)) {\n            if (max <= 0) max = 1;\n            if (min <= 0) min = 1e-4*max;\n            let kmin = 1/(1 + 0.5*Math.log10(max / min)),\n                kmax = 1 + 0.2*Math.log10(max / min);\n            min *= kmin;\n            max *= kmax;\n         } else if ((min > 0) && (min < 0.05*max)) {\n            min = 0;\n         }\n      };\n\n      max *= (1 + gStyle.fHistTopMargin);\n\n      adjustRange();\n\n      let max0 = max, min0 = min, zoomed = false;\n\n      if (stack.fMaximum != kNoZoom) {\n         max = stack.fMaximum*(1 + gStyle.fHistTopMargin);\n         max0 = Math.max(max, max0);\n         zoomed = true;\n      }\n\n      if (stack.fMinimum != kNoZoom) {\n         min = stack.fMinimum;\n         min0 = Math.min(min, min0);\n         zoomed = true;\n      }\n\n      if (zoomed)\n         adjustRange();\n      else\n         min = max = kNoZoom;\n\n      return { min, max, min0, max0, zoomed, hopt: `hmin:${min0};hmax:${max0};minimum:${min};maximum:${max}` };\n   }\n\n   /** @summary Draw next stack histogram */\n   async drawNextHisto(indx, pad_painter) {\n\n      let stack = this.getObject(),\n          hlst = this.options.nostack ? stack.fHists : stack.fStack,\n          nhists = hlst?.arr?.length || 0;\n\n      if (indx >= nhists)\n         return this;\n\n      let rindx = this.options.horder ? indx : nhists-indx-1,\n          hist = hlst.arr[rindx],\n          hopt = hlst.opt[rindx] || hist.fOption || this.options.hopt;\n\n      if (hopt.toUpperCase().indexOf(this.options.hopt) < 0)\n         hopt += ' ' + this.options.hopt;\n      if (this.options.draw_errors && !hopt)\n         hopt = 'E';\n\n      if (this.options._pfc || this.options._plc || this.options._pmc) {\n         let mp = this.getMainPainter();\n         if (isFunc(mp?.createAutoColor)) {\n            let icolor = mp.createAutoColor(nhists);\n            if (this.options._pfc) hist.fFillColor = icolor;\n            if (this.options._plc) hist.fLineColor = icolor;\n            if (this.options._pmc) hist.fMarkerColor = icolor;\n         }\n      }\n\n      // handling of 'pads' draw option\n      if (pad_painter) {\n         let subpad_painter = pad_painter.getSubPadPainter(indx+1);\n         if (!subpad_painter)\n            return this;\n\n         let prev_name = subpad_painter.selectCurrentPad(subpad_painter.this_pad_name);\n\n         return this.hdraw_func(subpad_painter.getDom(), hist, hopt).then(subp => {\n            this.painters.push(subp);\n            subpad_painter.selectCurrentPad(prev_name);\n            return this.drawNextHisto(indx+1, pad_painter);\n         });\n      }\n\n      // special handling of stacked histograms - set $baseh object for correct drawing\n      // also used to provide tooltips\n      if ((rindx > 0) && !this.options.nostack)\n         hist.$baseh = hlst.arr[rindx - 1];\n\n      return this.hdraw_func(this.getDom(), hist, hopt + ' same nostat').then(subp => {\n          this.painters.push(subp);\n          return this.drawNextHisto(indx+1, pad_painter);\n      });\n   }\n\n   /** @summary Decode draw options of THStack painter */\n   decodeOptions(opt) {\n      if (!this.options) this.options = {};\n      Object.assign(this.options, { ndim: 1, nostack: false, same: false, horder: true, has_errors: false, draw_errors: false, hopt: '' });\n\n      let stack = this.getObject(),\n          hist = stack.fHistogram || (stack.fHists ? stack.fHists.arr[0] : null) || (stack.fStack ? stack.fStack.arr[0] : null);\n\n      const hasErrors = hist => {\n         if (hist.fSumw2 && (hist.fSumw2.length > 0))\n            for (let n = 0; n < hist.fSumw2.length; ++n)\n               if (hist.fSumw2[n] > 0) return true;\n         return false;\n      };\n\n      if (hist && (hist._typename.indexOf(clTH2) == 0))\n         this.options.ndim = 2;\n\n      if ((this.options.ndim == 2) && !opt)\n         opt = 'lego1';\n\n      if (stack.fHists && !this.options.nostack)\n         for (let k = 0; k < stack.fHists.arr.length; ++k)\n            this.options.has_errors = this.options.has_errors || hasErrors(stack.fHists.arr[k]);\n\n      this.options.nhist = stack.fHists ? stack.fHists.arr.length : 1;\n\n      let d = new DrawOptions(opt);\n\n      this.options.nostack = d.check('NOSTACK');\n      if (d.check('STACK')) this.options.nostack = false;\n      this.options.same = d.check('SAME');\n\n      d.check('NOCLEAR'); // ignore noclear option\n\n      this.options._pfc = d.check('PFC');\n      this.options._plc = d.check('PLC');\n      this.options._pmc = d.check('PMC');\n\n      this.options.pads = d.check('PADS');\n      if (this.options.pads) this.options.nostack = true;\n\n      this.options.hopt = d.remain(); // use remaining draw options for histogram draw\n\n      let dolego = d.check('LEGO');\n\n      this.options.errors = d.check('E');\n\n      // if any histogram appears with pre-calculated errors, use E for all histograms\n      if (!this.options.nostack && this.options.has_errors && !dolego && !d.check('HIST') && (this.options.hopt.indexOf('E') < 0))\n         this.options.draw_errors = true;\n\n      this.options.horder = this.options.nostack || dolego;\n   }\n\n   /** @summary Create main histogram for THStack axis drawing */\n   createHistogram(stack) {\n      let histos = stack.fHists,\n          numhistos = histos ? histos.arr.length : 0;\n\n      if (!numhistos) {\n         let histo = createHistogram('TH1I', 100);\n         histo.fTitle = stack.fTitle;\n         return histo;\n      }\n\n      let h0 = histos.arr[0],\n          histo = createHistogram((this.options.ndim == 1) ? 'TH1I' : 'TH2I', h0.fXaxis.fNbins, h0.fYaxis.fNbins);\n      histo.fName = 'axis_hist';\n      Object.assign(histo.fXaxis, h0.fXaxis);\n      if (this.options.ndim==2)\n         Object.assign(histo.fYaxis, h0.fYaxis);\n\n      // this code is not exists in ROOT painter, can be skipped?\n      for (let n = 1; n < numhistos; ++n) {\n         let h = histos.arr[n];\n\n         if (!histo.fXaxis.fLabels) {\n            histo.fXaxis.fXmin = Math.min(histo.fXaxis.fXmin, h.fXaxis.fXmin);\n            histo.fXaxis.fXmax = Math.max(histo.fXaxis.fXmax, h.fXaxis.fXmax);\n         }\n\n         if ((this.options.ndim==2) && !histo.fYaxis.fLabels) {\n            histo.fYaxis.fXmin = Math.min(histo.fYaxis.fXmin, h.fYaxis.fXmin);\n            histo.fYaxis.fXmax = Math.max(histo.fYaxis.fXmax, h.fYaxis.fXmax);\n         }\n      }\n\n      histo.fTitle = stack.fTitle;\n\n      return histo;\n   }\n\n   /** @summary Update thstack object */\n   updateObject(obj) {\n      if (!this.matchObjectType(obj)) return false;\n\n      let stack = this.getObject();\n\n      stack.fHists = obj.fHists;\n      stack.fStack = obj.fStack;\n      stack.fTitle = obj.fTitle;\n      stack.fMinimum = obj.fMinimum;\n      stack.fMaximum = obj.fMaximum;\n\n      if (!this.options.nostack)\n         this.options.nostack = !this.buildStack(stack);\n\n      if (this.firstpainter) {\n         let src = obj.fHistogram;\n         if (!src)\n            src = stack.fHistogram = this.createHistogram(stack);\n\n         let mm = this.getMinMax(this.options.errors || this.options.draw_errors);\n\n         this.firstpainter.options.minimum = mm.min;\n         this.firstpainter.options.maximum = mm.max;\n         this.firstpainter._checked_zooming = false; // force to check 3d zooming\n\n         if (this.options.ndim == 1) {\n            this.firstpainter.ymin = mm.min0;\n            this.firstpainter.ymax = mm.max0;\n         } else {\n            this.firstpainter.zmin = mm.min0;\n            this.firstpainter.zmax = mm.max0;\n         }\n\n         this.firstpainter.updateObject(src);\n      }\n\n      // and now update histograms\n      let hlst = this.options.nostack ? stack.fHists : stack.fStack,\n          nhists = (hlst && hlst.arr) ? hlst.arr.length : 0;\n\n      if (nhists !== this.painters.length) {\n         this.getPadPainter()?.cleanPrimitives(objp => { return this.painters.indexOf(objp) >= 0; });\n         this.painters = [];\n         this.did_update = true;\n      } else {\n         for (let indx = 0; indx < nhists; ++indx) {\n            let rindx = this.options.horder ? indx : nhists-indx-1;\n            let hist = hlst.arr[rindx];\n            this.painters[indx].updateObject(hist);\n         }\n      }\n\n      return true;\n   }\n\n   /** @summary Redraw THStack\n     * @desc Do something if previous update had changed number of histograms */\n   redraw() {\n      if (this.did_update) {\n         delete this.did_update;\n         return this.drawNextHisto(0, this.options.pads ? this.getPadPainter() : null);\n      }\n   }\n\n   /** @summary draw THStack object */\n   static async draw(dom, stack, opt) {\n      if (!stack.fHists || !stack.fHists.arr)\n         return null; // drawing not needed\n\n      let painter = new THStackPainter(dom, stack, opt),\n          pad_painter = null,\n          skip_drawing = false;\n\n      return ensureTCanvas(painter, false).then(() => {\n\n         painter.decodeOptions(opt);\n\n         painter.hdraw_func = (painter.options.ndim == 1) ? TH1Painter.draw : TH2Painter.draw;\n\n         if (painter.options.pads) {\n            pad_painter = painter.getPadPainter();\n            if (pad_painter.doingDraw() && pad_painter.pad?.fPrimitives &&\n                pad_painter.pad.fPrimitives.arr.length > 1 && (pad_painter.pad.fPrimitives.arr.indexOf(stack) == 0)) {\n               skip_drawing = true;\n               console.log('special case with THStack with is already rendered - do nothing');\n               return;\n            }\n\n            pad_painter.cleanPrimitives(p => p !== painter);\n            return pad_painter.divide(painter.options.nhist);\n         }\n\n         if (!painter.options.nostack)\n             painter.options.nostack = !painter.buildStack(stack);\n\n         if (painter.options.same) return;\n\n         let no_histogram = !stack.fHistogram;\n\n         if (no_histogram)\n             stack.fHistogram = painter.createHistogram(stack);\n\n         let mm = painter.getMinMax(painter.options.errors || painter.options.draw_errors),\n             hopt = painter.options.hopt + ';axis;' + mm.hopt;\n\n         return painter.hdraw_func(dom, stack.fHistogram, hopt).then(subp => {\n            painter.addToPadPrimitives();\n            painter.firstpainter = subp;\n            subp.$secondary = 'hist'; // mark histogram painter as secondary\n            if (!no_histogram) painter.$primary = true; // mark stack as provider for histogram\n         });\n      }).then(() => skip_drawing ? painter : painter.drawNextHisto(0, pad_painter));\n   }\n\n} // class THStackPainter\n\nexport { THStackPainter };\n"],"x_google_ignoreList":[0]}