{"version":3,"file":"484.5a180dbb47d3c56e.js","mappings":"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","names":["TSplinePainter","ObjectPainter","updateObject","obj","opt","spline","this","getObject","_typename","Object","assign","undefined","decodeOptions","eval","knot","x","dx","fX","fY","fB","fC","fD","fE","fF","findX","klow","khig","fNp","fXmin","fXmax","fKstep","Math","round","fDelta","fPoly","max","khalf","createDummyHisto","xmin","xmax","ymin","ymax","forEach","min","gStyle","histo","create","fName","fTitle","fXaxis","fYaxis","processTooltipEvent","pnt","xx","yy","cleanup","funcs","getFramePainter","getGrFuncs","options","second_x","second_y","indx","revertAxis","fN","abs","grx","knot_size","draw_g","select","remove","gbin","radius","lineatt","width","empty","append","attr","style","call","func","res","name","title","y","gry","color1","color","lines","exact","changed","property","menu","menu_dist","sqrt","getObjectHint","push","axisAsText","floatToString","redraw","pmain","w","getFrameWidth","h","getFrameHeight","createG","createAttLine","Line","Curve","npx","fNpx","scale_xmin","scale_xmax","bins","logx","log","n","exp","h0","hmin","path","buildSvgPath","Mark","createAttMarker","markeratt","resetPos","getFullSize","length","canZoomInside","axis","d","DrawOptions","has_main","getMainPainter","Same","check","Hopt","storeDrawOpt","static","dom","painter","promise","Promise","resolve","no_main","console","warn","TH1Painter","then","addToPadPrimitives"],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/draw/TSplinePainter.mjs"],"sourcesContent":["import { gStyle, create } from '../core.mjs';\nimport { DrawOptions, floatToString, buildSvgPath } from '../base/BasePainter.mjs';\nimport { ObjectPainter } from '../base/ObjectPainter.mjs';\nimport { TH1Painter } from '../hist/TH1Painter.mjs';\n\n\n/**\n * @summary Painter for TSpline objects.\n *\n * @private\n */\n\nclass TSplinePainter extends ObjectPainter {\n\n   /** @summary Update TSpline object\n     * @private */\n   updateObject(obj, opt) {\n      let spline = this.getObject();\n\n      if (spline._typename != obj._typename) return false;\n\n      if (spline !== obj) Object.assign(spline, obj);\n\n      if (opt !== undefined) this.decodeOptions(opt);\n\n      return true;\n   }\n\n   /** @summary Evaluate spline at given position\n     * @private */\n   eval(knot, x) {\n      let dx = x - knot.fX;\n\n      if (knot._typename == 'TSplinePoly3')\n         return knot.fY + dx*(knot.fB + dx*(knot.fC + dx*knot.fD));\n\n      if (knot._typename == 'TSplinePoly5')\n         return knot.fY + dx*(knot.fB + dx*(knot.fC + dx*(knot.fD + dx*(knot.fE + dx*knot.fF))));\n\n      return knot.fY + dx;\n   }\n\n   /** @summary Find idex for x value\n     * @private */\n   findX(x) {\n      let spline = this.getObject(),\n          klow = 0, khig = spline.fNp - 1;\n\n      if (x <= spline.fXmin) return 0;\n      if (x >= spline.fXmax) return khig;\n\n      if(spline.fKstep) {\n         // Equidistant knots, use histogramming\n         klow = Math.round((x - spline.fXmin)/spline.fDelta);\n         // Correction for rounding errors\n         if (x < spline.fPoly[klow].fX) {\n            klow = Math.max(klow-1,0);\n         } else if (klow < khig) {\n            if (x > spline.fPoly[klow+1].fX) ++klow;\n         }\n      } else {\n         // Non equidistant knots, binary search\n         while(khig - klow > 1) {\n            let khalf = Math.round((klow + khig)/2);\n            if(x > spline.fPoly[khalf].fX) klow = khalf;\n                                      else khig = khalf;\n         }\n      }\n      return klow;\n   }\n\n   /** @summary Create histogram for axes drawing\n     * @private */\n   createDummyHisto() {\n\n      let xmin = 0, xmax = 1, ymin = 0, ymax = 1,\n          spline = this.getObject();\n\n      if (spline?.fPoly) {\n\n         xmin = xmax = spline.fPoly[0].fX;\n         ymin = ymax = spline.fPoly[0].fY;\n\n         spline.fPoly.forEach(knot => {\n            xmin = Math.min(knot.fX, xmin);\n            xmax = Math.max(knot.fX, xmax);\n            ymin = Math.min(knot.fY, ymin);\n            ymax = Math.max(knot.fY, ymax);\n         });\n\n         if (ymax > 0.0) ymax *= (1 + gStyle.fHistTopMargin);\n         if (ymin < 0.0) ymin *= (1 + gStyle.fHistTopMargin);\n      }\n\n      let histo = create('TH1I');\n\n      histo.fName = spline.fName + '_hist';\n      histo.fTitle = spline.fTitle;\n\n      histo.fXaxis.fXmin = xmin;\n      histo.fXaxis.fXmax = xmax;\n      histo.fYaxis.fXmin = ymin;\n      histo.fYaxis.fXmax = ymax;\n\n      return histo;\n   }\n\n   /** @summary Process tooltip event\n     * @private */\n   processTooltipEvent(pnt) {\n\n      let cleanup = false,\n          spline = this.getObject(),\n          main = this.getFramePainter(),\n          funcs = main?.getGrFuncs(this.options.second_x, this.options.second_y),\n          xx, yy, knot = null, indx = 0;\n\n      if ((pnt === null) || !spline || !funcs) {\n         cleanup = true;\n      } else {\n         xx = funcs.revertAxis('x', pnt.x);\n         indx = this.findX(xx);\n         knot = spline.fPoly[indx];\n         yy = this.eval(knot, xx);\n\n         if ((indx < spline.fN-1) && (Math.abs(spline.fPoly[indx+1].fX-xx) < Math.abs(xx-knot.fX))) knot = spline.fPoly[++indx];\n\n         if (Math.abs(funcs.grx(knot.fX) - pnt.x) < 0.5*this.knot_size) {\n            xx = knot.fX; yy = knot.fY;\n         } else {\n            knot = null;\n            if ((xx < spline.fXmin) || (xx > spline.fXmax)) cleanup = true;\n         }\n      }\n\n      if (cleanup) {\n         if (this.draw_g)\n            this.draw_g.select('.tooltip_bin').remove();\n         return null;\n      }\n\n      let gbin = this.draw_g.select('.tooltip_bin'),\n          radius = this.lineatt.width + 3;\n\n      if (gbin.empty())\n         gbin = this.draw_g.append('svg:circle')\n                           .attr('class', 'tooltip_bin')\n                           .style('pointer-events','none')\n                           .attr('r', radius)\n                           .style('fill', 'none')\n                           .call(this.lineatt.func);\n\n      let res = { name: this.getObject().fName,\n                  title: this.getObject().fTitle,\n                  x: funcs.grx(xx),\n                  y: funcs.gry(yy),\n                  color1: this.lineatt.color,\n                  lines: [],\n                  exact: (knot !== null) || (Math.abs(funcs.gry(yy) - pnt.y) < radius) };\n\n      res.changed = gbin.property('current_xx') !== xx;\n      res.menu = res.exact;\n      res.menu_dist = Math.sqrt((res.x-pnt.x)**2 + (res.y-pnt.y)**2);\n\n      if (res.changed)\n         gbin.attr('cx', Math.round(res.x))\n             .attr('cy', Math.round(res.y))\n             .property('current_xx', xx);\n\n      let name = this.getObjectHint();\n      if (name) res.lines.push(name);\n      res.lines.push('x = ' + funcs.axisAsText('x', xx));\n      res.lines.push('y = ' + funcs.axisAsText('y', yy));\n      if (knot !== null) {\n         res.lines.push('knot = ' + indx);\n         res.lines.push('B = ' + floatToString(knot.fB, gStyle.fStatFormat));\n         res.lines.push('C = ' + floatToString(knot.fC, gStyle.fStatFormat));\n         res.lines.push('D = ' + floatToString(knot.fD, gStyle.fStatFormat));\n         if ((knot.fE !== undefined) && (knot.fF !== undefined)) {\n            res.lines.push('E = ' + floatToString(knot.fE, gStyle.fStatFormat));\n            res.lines.push('F = ' + floatToString(knot.fF, gStyle.fStatFormat));\n         }\n      }\n\n      return res;\n   }\n\n   /** @summary Redraw object\n     * @private */\n   redraw() {\n\n      let spline = this.getObject(),\n          pmain = this.getFramePainter(),\n          funcs = pmain?.getGrFuncs(this.options.second_x, this.options.second_y),\n          w = pmain.getFrameWidth(),\n          h = pmain.getFrameHeight();\n\n      this.createG(true);\n\n      this.knot_size = 5; // used in tooltip handling\n\n      this.createAttLine({ attr: spline });\n\n      if (this.options.Line || this.options.Curve) {\n\n         let npx = Math.max(10, spline.fNpx),\n             xmin = Math.max(pmain.scale_xmin, spline.fXmin),\n             xmax = Math.min(pmain.scale_xmax, spline.fXmax),\n             indx = this.findX(xmin),\n             bins = []; // index of current knot\n\n         if (pmain.logx) {\n            xmin = Math.log(xmin);\n            xmax = Math.log(xmax);\n         }\n\n         for (let n = 0; n < npx; ++n) {\n            let x = xmin + (xmax-xmin)/npx*(n-1);\n            if (pmain.logx) x = Math.exp(x);\n\n            while ((indx < spline.fNp-1) && (x > spline.fPoly[indx+1].fX)) ++indx;\n\n            let y = this.eval(spline.fPoly[indx], x);\n\n            bins.push({ x, y, grx: funcs.grx(x), gry: funcs.gry(y) });\n         }\n\n         let h0 = h;  // use maximal frame height for filling\n         if ((pmain.hmin !== undefined) && (pmain.hmin >= 0)) {\n            h0 = Math.round(funcs.gry(0));\n            if ((h0 > h) || (h0 < 0)) h0 = h;\n         }\n\n         let path = buildSvgPath('bezier', bins, h0, 2);\n\n         this.draw_g.append('svg:path')\n             .attr('class', 'line')\n             .attr('d', path.path)\n             .style('fill', 'none')\n             .call(this.lineatt.func);\n      }\n\n      if (this.options.Mark) {\n\n         // for tooltips use markers only if nodes where not created\n         let path = '';\n\n         this.createAttMarker({ attr: spline });\n\n         this.markeratt.resetPos();\n\n         this.knot_size = this.markeratt.getFullSize();\n\n         for (let n = 0; n < spline.fPoly.length; n++) {\n            let knot = spline.fPoly[n],\n                grx = funcs.grx(knot.fX);\n            if ((grx > -this.knot_size) && (grx < w + this.knot_size)) {\n               let gry = funcs.gry(knot.fY);\n               if ((gry > -this.knot_size) && (gry < h + this.knot_size)) {\n                  path += this.markeratt.create(grx, gry);\n               }\n            }\n         }\n\n         if (path)\n            this.draw_g.append('svg:path')\n                       .attr('d', path)\n                       .call(this.markeratt.func);\n      }\n   }\n\n   /** @summary Checks if it makes sense to zoom inside specified axis range */\n   canZoomInside(axis/*,min,max*/) {\n      if (axis !== 'x') return false;\n\n      let spline = this.getObject();\n      if (!spline) return false;\n\n      // if function calculated, one always could zoom inside\n      return true;\n   }\n\n   /** @summary Decode options for TSpline drawing */\n   decodeOptions(opt) {\n      let d = new DrawOptions(opt);\n\n      if (!this.options) this.options = {};\n\n      let has_main = !!this.getMainPainter();\n\n      Object.assign(this.options, {\n         Same: d.check('SAME'),\n         Line: d.check('L'),\n         Curve: d.check('C'),\n         Mark: d.check('P'),\n         Hopt: 'AXIS',\n         second_x: false,\n         second_y: false\n      });\n\n      if (!this.options.Line && !this.options.Curve && !this.options.Mark)\n         this.options.Curve = true;\n\n      if (d.check('X+')) { this.options.Hopt += 'X+'; this.options.second_x = has_main; }\n      if (d.check('Y+')) { this.options.Hopt += 'Y+'; this.options.second_y = has_main; }\n\n      this.storeDrawOpt(opt);\n   }\n\n   /** @summary Draw TSpline */\n   static async draw(dom, spline, opt) {\n      let painter = new TSplinePainter(dom, spline);\n      painter.decodeOptions(opt);\n\n      let promise = Promise.resolve(), no_main = !painter.getMainPainter();\n      if (no_main || painter.options.second_x || painter.options.second_y) {\n         if (painter.options.Same && no_main) {\n            console.warn('TSpline painter requires histogram to be drawn');\n            return null;\n         }\n         let histo = painter.createDummyHisto();\n         promise = TH1Painter.draw(dom, histo, painter.options.Hopt);\n      }\n\n      return promise.then(() => {\n         painter.addToPadPrimitives();\n         painter.redraw();\n         return painter;\n      });\n   }\n\n} // class TSplinePainter\n\nexport { TSplinePainter };\n"],"x_google_ignoreList":[0]}