{"version":3,"file":"763.7bf80b6745caf98b.js","mappings":"wOASA,SAASA,GAAOC,GACb,IAAIC,EAAID,EAAI,GACZ,QAASE,EAAI,EAAGA,EAAIF,EAAIG,SAAUD,EAC/BD,EAAIG,KAAKC,IAAIJ,EAAGD,EAAIE,IACvB,OAAOD,CACV,CAEA,SAASK,GAAON,GACb,IAAIC,EAAID,EAAI,GACZ,QAASE,EAAI,EAAGA,EAAIF,EAAIG,SAAUD,EAC/BD,EAAIG,KAAKG,IAAIN,EAAGD,EAAIE,IACvB,OAAOD,CACV,CAaA,MAAMO,GAEHC,YAAYC,GACTC,KAAKC,SAAWF,EAChBC,KAAKE,GAAKH,EAAEG,GACZF,KAAKG,GAAKJ,EAAEI,GACZH,KAAKI,GAAKL,EAAEK,GACZJ,KAAKK,SAAWN,EAAEM,SAClBL,KAAKM,MAAQ,EACbN,KAAKO,KAAO,EACZP,KAAKQ,OAAS,EACdR,KAAKS,YAAc,KACnBT,KAAKU,IAAM,KACXV,KAAKW,IAAM,KACXX,KAAKY,OAAS,KACdZ,KAAKa,MAAQ,KACbb,KAAKc,QAAU,KACfd,KAAKe,QAAU,KACff,KAAKgB,QAAU,KACfhB,KAAKiB,OAAQ,EACbjB,KAAKkB,OAAS,EACdlB,KAAKmB,OAAS,EACdnB,KAAKoB,OAAS,EACdpB,KAAKqB,OAAS,EACdrB,KAAKsB,SAAW,EAChBtB,KAAKuB,SAAW,EAChBvB,KAAKwB,cAAgB,EACrBxB,KAAKyB,cAAgB,EAErBzB,KAAK0B,YACR,CAGAC,aACQ3B,KAAKiB,QACPjB,KAAK4B,+BACL5B,KAAK6B,WACL7B,KAAKiB,OAAQ,EAEnB,CAEAa,SAASC,EAAGC,GAKThC,KAAK2B,aAGL,MAAMM,GAAMF,EAAE/B,KAAKsB,UAAUtB,KAAKwB,cAC5BU,GAAMF,EAAEhC,KAAKuB,UAAUvB,KAAKyB,cAClC,IAAIU,EAAKnC,KAAKoC,YAAYH,EAAIC,GAI9B,OAAW,IAAPC,IAAUA,EAAKnC,KAAKoC,YAAYH,EAAG,KAAQC,IAExCC,CACV,CAGAP,+BAIG,MAAMS,EAAOjD,GAAOY,KAAKC,SAASC,IAC5BoC,EAAOlD,GAAOY,KAAKC,SAASE,IAC5BoC,EAAO5C,GAAOK,KAAKC,SAASC,IAC5BsC,EAAO7C,GAAOK,KAAKC,SAASE,IAClCH,KAAKsB,WAAae,EAAKE,GAAM,EAC7BvC,KAAKuB,WAAae,EAAKE,GAAM,EAC7BxC,KAAKwB,cAAgB,GAAGa,EAAKE,GAC7BvC,KAAKyB,cAAgB,GAAGa,EAAKE,GAC7BxC,KAAKmB,QAAUkB,EAAKrC,KAAKsB,UAAUtB,KAAKwB,cACxCxB,KAAKkB,QAAUqB,EAAKvC,KAAKsB,UAAUtB,KAAKwB,cACxCxB,KAAKqB,QAAUiB,EAAKtC,KAAKuB,UAAUvB,KAAKyB,cACxCzB,KAAKoB,QAAUoB,EAAKxC,KAAKuB,UAAUvB,KAAKyB,cACxCzB,KAAKU,IAAM,IAAI+B,MAAMzC,KAAKK,SAAS,GACnCL,KAAKW,IAAM,IAAI8B,MAAMzC,KAAKK,SAAS,GACnC,QAASqC,EAAI,EAAGA,EAAI1C,KAAKK,SAAUqC,IAChC1C,KAAKU,IAAIgC,EAAE,IAAM1C,KAAKE,GAAGwC,GAAG1C,KAAKsB,UAAUtB,KAAKwB,cAChDxB,KAAKW,IAAI+B,EAAE,IAAM1C,KAAKG,GAAGuC,GAAG1C,KAAKuB,UAAUvB,KAAKyB,cAMnDzB,KAAKc,QAAU,GACfd,KAAKe,QAAU,GACff,KAAKgB,QAAU,EAClB,CAKA2B,QAAQC,EAAIC,EAAIC,EAAIC,GACjB,MAAMhB,EAAI,CAAC/B,KAAKU,IAAIkC,GAAK5C,KAAKU,IAAImC,GAAK7C,KAAKU,IAAIoC,GAAK9C,KAAKU,IAAIkC,IACxDZ,EAAI,CAAChC,KAAKW,IAAIiC,GAAK5C,KAAKW,IAAIkC,GAAK7C,KAAKW,IAAImC,GAAK9C,KAAKW,IAAIiC,IACxDI,EAAKhD,KAAKU,IAAIqC,GACdE,EAAKjD,KAAKW,IAAIoC,GACpB,IAAIxD,EAAI,EAAG2D,EAAInB,EAAEvC,OAAS,EAAG2D,GAAW,EAExC,KAAO5D,EAAIwC,EAAEvC,SAAUD,GACfyC,EAAEzC,GAAG0D,GAAMjB,EAAEkB,IAAID,GAAQjB,EAAEkB,GAAGD,GAAMjB,EAAEzC,IAAI0D,IACxClB,EAAExC,IAAI0D,EAAGjB,EAAEzC,KAAKyC,EAAEkB,GAAGlB,EAAEzC,KAAKwC,EAAEmB,GAAGnB,EAAExC,IAAIyD,IACxCG,GAAYA,GAElBD,EAAI3D,EAGP,OAAO4D,CACV,CAOAC,OAAOC,EAAGX,EAAGY,GACV,IAAIC,EAAMC,EAAKC,EAAKJ,EAAGK,EAAKhB,EAAGiB,EAAKL,EAGpC,GACGC,GAAO,EACHG,EAAKD,IAAMD,EAAMC,EAAIA,EAAKC,EAAIA,EAAKF,EAAKD,GAAO,GAC/CI,EAAKD,IAAMF,EAAME,EAAIA,EAAKC,EAAIA,EAAKH,EAAKD,GAAO,SAC7CA,GAGTvD,KAAKO,OACLP,KAAKc,QAAQ8C,KAAKH,GAClBzD,KAAKe,QAAQ6C,KAAKF,GAClB1D,KAAKgB,QAAQ4C,KAAKD,EACrB,CAcAE,mBACG,GAAI7D,KAAK8D,QAAS,OAElB9D,KAAK8D,SAAU,EAEf,IAAIC,EAAOC,EAAOC,EAAIC,EAAIjC,EAAIC,EAC1BiC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAOC,EAAIC,EACnC/B,EAAIC,EAAI+B,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAgB3B,EAAGZ,EAAfwC,EAAG,EAAGC,EAAG,EAASC,EAAG,EACzD,MAAMC,EAAI,EAAC,GAAO,GAAO,GACnBC,EAAa,KAUnB,IARAtF,KAAK2B,aAMLoC,EAAQ,EACRC,EAAQ,EACHtB,EAAI,EAAGA,GAAK1C,KAAKQ,OAAQkC,IAC3BqB,GAAS/D,KAAKU,IAAIV,KAAKS,YAAYiC,EAAE,IACrCsB,GAAShE,KAAKW,IAAIX,KAAKS,YAAYiC,EAAE,IAYxC,IAVAqB,EAAQA,EAAM/D,KAAKQ,OAAO8E,EAC1BtB,EAAQA,EAAMhE,KAAKQ,OAAO8E,EAE1BtF,KAAKoC,YAAY2B,EAAOC,GAMxBpB,EAAK,EACEA,GAAM5C,KAAKO,MAAM,CAWrB,IATAqE,EAAK5E,KAAKc,QAAQ8B,EAAG,GACrBiC,EAAK7E,KAAKe,QAAQ6B,EAAG,GACrBkC,EAAK9E,KAAKgB,QAAQ4B,EAAG,GAGrByC,EAAE,IAAK,EACPA,EAAE,IAAK,EACPA,EAAE,IAAK,EAEFxC,EAAG,EAAGA,GAAI7C,KAAKO,KAAMsC,IACnBA,IAAOD,IAERmC,EAAK/E,KAAKc,QAAQ+B,EAAG,GACrBmC,EAAKhF,KAAKe,QAAQ8B,EAAG,GACrBoC,EAAKjF,KAAKgB,QAAQ6B,EAAG,GAEhB+B,IAAOG,GAAMF,IAAOG,GAAQJ,IAAOG,GAAMF,IAAOI,GAAQL,IAAOI,GAAMH,IAAOI,EAE9EI,EAAE,IAAK,EACET,IAAOG,GAAMD,IAAOE,GAAQJ,IAAOG,GAAMD,IAAOG,GAAQL,IAAOI,GAAMF,IAAOG,EAErFI,EAAE,IAAK,GACER,IAAOE,GAAMD,IAAOE,GAAQH,IAAOE,GAAMD,IAAOG,GAAQJ,IAAOG,GAAMF,IAAOG,KAErFI,EAAE,IAAK,IAWhB,IAAK/B,EAAE,EAAGA,GAAG,EAAGA,IACR+B,EAAE/B,EAAE,KAEI,IAANA,GACD4B,EAAKN,EACLO,EAAKN,EACLO,EAAKN,GACS,IAANxB,GACR4B,EAAKN,EACLO,EAAKL,EACLM,EAAKP,GACS,IAANvB,IACR4B,EAAKL,EACLM,EAAKL,EACLM,EAAKR,GAGRX,GAAMjE,KAAKU,IAAIwE,GAAIlF,KAAKU,IAAIyE,IAAK,EACjCjB,GAAMlE,KAAKW,IAAIuE,GAAIlF,KAAKW,IAAIwE,IAAK,EAIjChB,EAAKnE,KAAKU,IAAIwE,GAAIlF,KAAKU,IAAIyE,GAC3Bf,EAAKpE,KAAKW,IAAIuE,GAAIlF,KAAKW,IAAIwE,GAG3Bd,EAAKD,EACLE,GAAMH,EACNO,EAAKjF,KAAK8F,KAAKlB,EAAGA,EAAGC,EAAGA,GACxBD,GAAQK,EACRJ,GAAQI,EACRH,EAAKvE,KAAKU,IAAI0E,GAAInB,EAClBO,EAAKxE,KAAKW,IAAIyE,GAAIlB,EAClBO,EAAQF,EAAGF,EAAGG,EAAGF,EACbG,EAAQ,IAETJ,GAAMA,EACNC,GAAMA,GAKTK,EAAIlF,KAAK+F,IAAI/F,KAAKC,IAAI4F,EAAWrB,EAAIqB,EAAWpB,IAChDjC,EAAKgC,EAAGI,EAAGM,EACXzC,EAAKgC,EAAGI,EAAGK,EAEX3E,KAAKoC,YAAYH,EAAIC,IAM3BU,GACH,CACH,CAQAf,WACQ7B,KAAKS,cACPT,KAAKS,YAAc,IAAIgC,MAAMzC,KAAKK,WAErC,IAAIoF,EAAY,EAChB,QAAS/C,EAAE,EAAGA,GAAG1C,KAAKK,SAAUqC,IAIf1C,KAAK0F,OAAOhD,EAAGA,KAI1B+C,IACAzF,KAAKS,YAAYgF,EAAU,GAAK/C,GAGtC1C,KAAKQ,OAASiF,CACjB,CAKAC,OAAO3C,EAAGhB,GACP,IAAI4D,EAAIC,EAAIlD,EAAGY,EAAGuC,EACdC,EAAUC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAC7CC,EAAGjH,EAAGkH,EAAMC,EAAMC,EAAMC,EAAMC,EAC9BC,GAAY,EAEhB,MAAM5E,EAAKjC,KAAKU,IAAIqC,GACdb,EAAKlC,KAAKW,IAAIoC,GAmCpB,IA9BG8C,EAHC7F,KAAKQ,OAAS,EAGRR,KAAKQ,OAGLR,KAAKK,SAQfsF,EAAK,EACLC,EAAK,EACDD,IAAO5D,GACR4D,EAAKC,EACLA,KACQA,IAAO7D,GACf6D,IAIHK,EAAMhE,EAAGjC,KAAKU,IAAIiF,GAClBS,EAAMlE,EAAGlC,KAAKW,IAAIgF,GAClBO,EAAMjE,EAAGjC,KAAKU,IAAIkF,GAClBS,EAAMnE,EAAGlC,KAAKW,IAAIiF,GAClBc,EAAOjH,KAAKqH,MAAMV,EAAKH,GACvBU,EAAOlH,KAAKqH,MAAMT,EAAKH,GACvBU,EAAQF,EAAKC,EAAOlH,KAAKsH,OAAOL,EAAKC,IAAe,EAARlH,KAAKuH,KAAOvH,KAAKuH,GAAG,EAC5DJ,EAAO,IAAGA,GAAgB,EAARnH,KAAKuH,IAC3BlB,EAAWc,EACNlE,EAAE,EAAGA,GAAGmD,EAAMnD,IAOhB,GAJGY,EAFCtD,KAAKQ,OAAS,EAEXR,KAAKS,YAAYiC,EAAE,GAEnBA,EAEFY,IAAMqC,GAAQrC,IAAMsC,GAAQtC,IAAMvB,IAGpCkE,EAAMhE,EAAGjC,KAAKU,IAAIiF,GAClBS,EAAMlE,EAAGlC,KAAKW,IAAIgF,GAClBO,EAAMjE,EAAGjC,KAAKU,IAAIkF,GAClBS,EAAMnE,EAAGlC,KAAKW,IAAIiF,GAClBO,EAAMlE,EAAGjC,KAAKU,IAAI4C,GAClBgD,EAAMpE,EAAGlC,KAAKW,IAAI2C,GAElByC,EAAOG,EAAIE,EAAIH,EAAII,EACnBL,EAAOC,EAAII,EAAIH,EAAIE,EAEfL,EAAIC,GAAQ,IACbO,GAAKL,EAAII,EAAIH,EAAIE,GAAKN,EACtBzG,GAAK2G,EAAIK,EAAIH,EAAIC,GAAKJ,EACjBO,EAAI,GAAOjH,EAAI,IAAI,CAkBrB,GAbAkH,GAAQP,EAAIE,EAAIC,EAAIE,GAAK7G,KAAK8F,KAAKU,EAAIA,EAAIG,EAAIA,GAC/CK,GAAQP,EAAIC,EAAIE,EAAIC,GAAK7G,KAAK8F,KAAKW,EAAIA,EAAIG,EAAIA,GAC3CG,EAAOC,GACRd,EAAKrC,EACLoD,EAAOjH,KAAKqH,MAAMR,EAAKH,GACvBQ,EAAOlH,KAAKqH,MAAMT,EAAKH,KAEvBN,EAAKtC,EACLoD,EAAOjH,KAAKqH,MAAMV,EAAKH,GACvBU,EAAOlH,KAAKqH,MAAMR,EAAKH,IAE1BS,EAAQF,EAAKC,EAAOlH,KAAKsH,OAAOL,EAAKC,IAAe,EAARlH,KAAKuH,KAAOvH,KAAKuH,GAAG,EAC5DJ,EAAO,IAAGA,GAAgB,EAARnH,KAAKuH,KACtBJ,EAAOnH,KAAKuH,KAAKlB,EAAWrG,KAAKuH,IAAM,EAGzCH,UAAY,EACLA,EAEVf,EAAWc,CACd,CAKT,OAAOC,CACV,CAKAI,mBAAmBC,EAAKC,EAAKC,EAAKrE,GAC/B,IAAIS,EAAKD,EAAMX,EAAKsE,EAAKrE,EAAKsE,EAAKrE,EAAKsE,EAGxC,GACG7D,GAAO,EACHV,EAAKD,IAAMY,EAAMZ,EAAIA,EAAKC,EAAIA,EAAKW,EAAKD,GAAO,GAC/CT,EAAKD,IAAMW,EAAMX,EAAIA,EAAKC,EAAIA,EAAKU,EAAKD,GAAO,SAC7CA,GAET,MAAM8D,EAAKrH,KAAKU,IAAIkC,GACd0E,EAAKtH,KAAKU,IAAImC,GACd0E,EAAKvH,KAAKU,IAAIoC,GACd0E,EAAKxH,KAAKW,IAAIiC,GACd6E,EAAKzH,KAAKW,IAAIkC,GACd6E,EAAK1H,KAAKW,IAAImC,GACd6E,EAAK3H,KAAKI,GAAGwC,EAAG,GAChBgF,EAAK5H,KAAKI,GAAGyC,EAAG,GAChBgF,EAAK7H,KAAKI,GAAG0C,EAAG,GAChByD,GAAKoB,GAAIF,EAAGC,GAAIE,GAAIF,EAAGF,GAAIK,GAAIL,EAAGC,KAAMJ,GAAII,EAAGC,GAAIJ,GAAII,EAAGF,GAAID,GAAIC,EAAGC,IACrEnI,GAAKqI,GAAIL,EAAGC,GAAIK,GAAIL,EAAGF,GAAIQ,GAAIR,EAAGC,KAAME,GAAIF,EAAGC,GAAIE,GAAIF,EAAGF,GAAIK,GAAIL,EAAGC,IAG3E,OAAOf,EAAEvG,KAAKU,IAAIqC,GAAKzD,EAAEU,KAAKW,IAAIoC,IAFxB4E,EAAGpB,EAAEc,EAAG/H,EAAEkI,EAGvB,CAMApF,YAAYH,EAAIC,GACb,IAAI4F,EACAC,EAAIC,EAAa3E,EAAGX,EAAGY,EACvB/D,EAAG2D,EAAG+E,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAIC,EAAI5D,EAAG6D,EAAG5F,EAAIC,EAAIC,EAE3C2F,EAAKC,EACLC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,GAAMC,GAAMC,GAChCC,GAAMC,EAASC,EAAOC,GAAQC,GAC9BtD,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,EAAKC,GAAGjH,GAJjCkK,EAAS,EAAGC,EAAQ,EAAGC,EAAS,EAAGC,EAAU,EAAGC,EAAU,EAK9D,MAAMC,EAAM,CAAC,EAAG,EAAG,GAAIC,EAAM,CAAC,EAAG,EAAG,GAsBpC,GAnBA9J,KAAK2B,aAGA3B,KAAKY,SACPZ,KAAKY,OAAS,IAAI6B,MAAMzC,KAAKK,UAC7BL,KAAKa,MAAQ,IAAI4B,MAAMzC,KAAKK,WAI/BL,KAAKU,IAAI,GAAKuB,EACdjC,KAAKW,IAAI,GAAKuB,EAGd4F,EAAW9H,KAAKM,MAGhB0H,EAAc,EAGT/F,EAAKjC,KAAKmB,QAAYc,EAAKjC,KAAKkB,QAAYgB,EAAKlC,KAAKqB,QAAYa,EAAKlC,KAAKoB,OAC9E,OAAO0G,EAGV,IAAKC,EAAG,EAAGA,GAAI/H,KAAKO,KAAMwH,IAMvB,GALA1E,EAAIrD,KAAKc,QAAQiH,EAAG,GACpBrF,EAAI1C,KAAKe,QAAQgH,EAAG,GACpBzE,EAAItD,KAAKgB,QAAQ+G,EAAG,GAGhB/H,KAAK2C,QAAQU,EAAGX,EAAGY,EAAG,GAEvBwE,SAAW9H,KAAKiH,mBAAmB5D,EAAGX,EAAGY,EAAG,GACrCwE,EAKb,MAAMiC,GAAa/J,KAAK0F,OAAO,GAAG,GAClC,IAAKqE,GACF,OAAOjC,EAKV,IAAKC,EAAG,EAAGA,GAAI/H,KAAKK,SAAU0H,IAC3BU,EAAMzI,KAAKU,IAAIqH,GACfW,EAAM1I,KAAKW,IAAIoH,GACf/H,KAAKa,MAAMkH,EAAG,GAAKtI,KAAK8F,MAAMtD,EAAGwG,IAAMxG,EAAGwG,IAAMvG,EAAGwG,IAAMxG,EAAGwG,IAK/D,IA5fN,SAASsB,GAAWC,EAAIC,EAAQC,GAC7B,MAAM9K,EAAM,IAAIoD,MAAMwH,GACtB,QAAS1K,EAAI,EAAGA,EAAI0K,IAAM1K,EACvBF,EAAIE,GAAK,CAAED,EAAG4K,EAAO3K,GAAIA,KAE5BF,EAAI+K,KAAK,CAACzF,EAAG6D,IAAe7D,EAAErF,EAAIkJ,EAAElJ,GAAI,EAAMqF,EAAErF,EAAIkJ,EAAElJ,EAAI,EAAI,GAE9D,QAASC,EAAI,EAAGA,EAAI0K,IAAM1K,EACvB4K,EAAS5K,GAAKF,EAAIE,GAAGA,CAC3B,CAkfMyK,CAAWhK,KAAKK,SAAUL,KAAKa,MAAOb,KAAKY,QACtCmH,EAAG,EAAGA,EAAG/H,KAAKK,SAAU0H,IAAM/H,KAAKY,OAAOmH,KAI/C,IAAKE,EAAE,EAAGA,GAAGjI,KAAKK,SAAU4H,IAEzB,IADA3E,EAAItD,KAAKY,OAAOqH,EAAE,GACb/E,EAAE,EAAGA,GAAG+E,EAAE,EAAG/E,IAEf,IADAR,EAAI1C,KAAKY,OAAOsC,EAAE,GACb3D,EAAE,EAAGA,GAAG2D,EAAE,EAAG3D,IAAK,CACpB,IAAI8K,GAAqB,EAEzB,GADAhH,EAAIrD,KAAKY,OAAOrB,EAAE,GACdyI,EAAchI,KAAKsK,SAKpB,OAAOxC,EAOV,GALAE,IAEAW,EAAKlJ,KAAK8F,MAAMvF,KAAKU,IAAI2C,GAAGrD,KAAKU,IAAIgC,KAAK,GAAG1C,KAAKW,IAAI0C,GAAGrD,KAAKW,IAAI+B,KAAK,GACvEkG,EAAKnJ,KAAK8F,MAAMvF,KAAKU,IAAI2C,GAAGrD,KAAKU,IAAI4C,KAAK,GAAGtD,KAAKW,IAAI0C,GAAGrD,KAAKW,IAAI2C,KAAK,GACvEuF,EAAKpJ,KAAK8F,MAAMvF,KAAKU,IAAIgC,GAAG1C,KAAKU,IAAI4C,KAAK,GAAGtD,KAAKW,IAAI+B,GAAG1C,KAAKW,IAAI2C,KAAK,KAClEqF,EAAGC,GAAMC,GAAQF,EAAGE,GAAMD,GAAQA,EAAGC,GAAMF,IAI3C3I,KAAK2C,QAAQU,EAAGX,EAAGY,EAAG,GAW3B,KADAkG,EAAS,EACJrB,EAAI,EAAGA,GAAKnI,KAAKK,SAAU8H,IAC7B,GAAKA,IAAM9E,GAAO8E,IAAMzF,GAAOyF,IAAM7E,EAOrC,KAAK4E,EAAE,EAAGA,GAAGlI,KAAKK,SAAU6H,IACzB,GAAIlI,KAAKY,OAAOsH,EAAE,KAAOC,EACtB,MAAKD,EAAE3I,GAAO2I,EAAEhF,GAAOgF,EAAED,GAStB,MAJA,GAAIjI,KAAK2C,QAAQU,EAAGX,EAAGY,EAAG6E,GAAI,CAAEkC,GAAqB,EAAM,KAAO,CAIlE,CAKT,GAAIA,EAAoB,MAoBxB,IAhBMrK,KAAKU,IAAI2C,GAAGrD,KAAKU,IAAIyH,KAAKnI,KAAKW,IAAI0C,GAAGrD,KAAKW,IAAI+B,MAAW1C,KAAKW,IAAI0C,GAAGrD,KAAKW,IAAIwH,KAAKnI,KAAKU,IAAI2C,GAAGrD,KAAKU,IAAIgC,KAE5GiC,EAAItB,EACJmF,EAAI9F,IACM1C,KAAKU,IAAI2C,GAAGrD,KAAKU,IAAIyH,KAAKnI,KAAKW,IAAI0C,GAAGrD,KAAKW,IAAI2C,MAAWtD,KAAKW,IAAI0C,GAAGrD,KAAKW,IAAIwH,KAAKnI,KAAKU,IAAI2C,GAAGrD,KAAKU,IAAI4C,KAEnHqB,EAAItB,EACJmF,EAAIlF,IACMtD,KAAKU,IAAIgC,GAAG1C,KAAKU,IAAIyH,KAAKnI,KAAKW,IAAI+B,GAAG1C,KAAKW,IAAI2C,MAAWtD,KAAKW,IAAI+B,GAAG1C,KAAKW,IAAIwH,KAAKnI,KAAKU,IAAIgC,GAAG1C,KAAKU,IAAI4C,KAEnHqB,EAAIjC,EACJ8F,EAAIlF,IAEJqB,EAAI,EACJ6D,EAAI,GAEG,IAAN7D,EAAS,CAGV,GAAI3E,KAAKU,IAAIiE,KAAO3E,KAAKU,IAAI8H,GAC1B,KAAMxI,KAAKU,IAAIyH,GAAGnI,KAAKU,IAAIiE,KAAK3E,KAAKU,IAAIyH,GAAGnI,KAAKU,IAAI8H,IAAO,EAAG,CAC5D6B,GAAqB,EACrB,KAEH,EAAarK,KAAKU,IAAIyH,GAAGnI,KAAKU,IAAIiE,KAAK3E,KAAKU,IAAIyH,GAAGnI,KAAKU,IAAI8H,KAAS,GAMlE+B,QAAQC,KAAK,wDAAwD7F,KAAK6D,KAAKL,IAAG,UAG/EnI,KAAKW,IAAIwH,GAAGnI,KAAKW,IAAIgE,KAAK3E,KAAKW,IAAIwH,GAAGnI,KAAKW,IAAI6H,IAAO,EAAG,CAC5D6B,GAAqB,EACrB,KAEH,EAAarK,KAAKW,IAAIwH,GAAGnI,KAAKW,IAAIgE,KAAK3E,KAAKW,IAAIwH,GAAGnI,KAAKW,IAAI6H,KAAS,GAElE+B,QAAQC,KAAK,wDAAwD7F,KAAK6D,KAAKL,IAAG,CAIxF,QACH,CAEA,GAAIkC,EAAoB,MAmBxB,IAdAjC,EAAI9E,EACJgF,EAAKjF,EACLkF,EAAK7F,EAMLmH,EAAI,GAAK7J,KAAKU,IAAI2C,GAAGrD,KAAKU,IAAIyH,GAC9B2B,EAAI,GAAK9J,KAAKW,IAAI0C,GAAGrD,KAAKW,IAAIwH,GAC9B0B,EAAI,GAAK7J,KAAKU,IAAIgC,GAAG1C,KAAKU,IAAIyH,GAC9B2B,EAAI,GAAK9J,KAAKW,IAAI+B,GAAG1C,KAAKW,IAAIwH,GAC9B0B,EAAI,GAAK7J,KAAKU,IAAI4C,GAAGtD,KAAKU,IAAIyH,GAC9B2B,EAAI,GAAK9J,KAAKW,IAAI2C,GAAGtD,KAAKW,IAAIwH,GACzBD,EAAE,EAAGA,GAAG,EAAGA,IAeb,GAdAjC,EAAM4D,EAAI3B,EAAE,GACZhC,EAAM2D,EAAI3B,EAAE,GACZ/B,EAAM0D,GAAK3B,EAAE,GAAG,GAChB9B,EAAM0D,EAAI5B,EAAE,GACZ7B,EAAMyD,EAAI5B,EAAE,GACZ5B,EAAMwD,GAAK5B,EAAE,GAAG,GAMhB3B,IAAKD,EAAIJ,EAAIC,EAAIE,IAAMD,EAAIF,EAAID,EAAII,GACnC/G,IAAKgH,EAAIL,EAAIE,EAAIC,IAAMC,EAAIJ,EAAIC,EAAIE,GAE9BG,IAAK,GAAOjH,IAAK,EAAI,CAGb,IAAN4I,GACDE,EAAI9E,EAAGgF,EAAKjF,EAAGkF,EAAK7F,GACN,IAANwF,GACRE,EAAI/E,EAAGiF,EAAK5F,EAAG6F,EAAKjF,IAEpB8E,EAAI1F,EAAG4F,EAAKhF,EAAGiF,EAAKlF,GAEvB,KACH,CAeH,GATAgG,IAAUrJ,KAAKU,IAAI0H,GAAGpI,KAAKU,IAAI4H,KAAMtI,KAAKU,IAAIyH,GAAGnI,KAAKU,IAAI4H,KAAMtI,KAAKW,IAAIyH,GAAGpI,KAAKW,IAAI2H,KAAMtI,KAAKW,IAAIwH,GAAGnI,KAAKW,IAAI2H,KACvG7I,KAAK8F,OAAOvF,KAAKU,IAAI0H,GAAGpI,KAAKU,IAAI4H,KAAMtI,KAAKU,IAAI0H,GAAGpI,KAAKU,IAAI4H,KAAMtI,KAAKW,IAAIyH,GAAGpI,KAAKW,IAAI2H,KAAMtI,KAAKW,IAAIyH,GAAGpI,KAAKW,IAAI2H,OAChHtI,KAAKU,IAAIyH,GAAGnI,KAAKU,IAAI4H,KAAMtI,KAAKU,IAAIyH,GAAGnI,KAAKU,IAAI4H,KAAMtI,KAAKW,IAAIwH,GAAGnI,KAAKW,IAAI2H,KAAMtI,KAAKW,IAAIwH,GAAGnI,KAAKW,IAAI2H,MACjHgB,KAAWtJ,KAAKU,IAAI6H,GAAIvI,KAAKU,IAAI4H,KAAMtI,KAAKU,IAAIyH,GAAGnI,KAAKU,IAAI4H,KAAMtI,KAAKW,IAAI4H,GAAIvI,KAAKW,IAAI2H,KAAMtI,KAAKW,IAAIwH,GAAGnI,KAAKW,IAAI2H,KAC1G7I,KAAK8F,OAAOvF,KAAKU,IAAI6H,GAAIvI,KAAKU,IAAI4H,KAAMtI,KAAKU,IAAI6H,GAAIvI,KAAKU,IAAI4H,KAAMtI,KAAKW,IAAI4H,GAAIvI,KAAKW,IAAI2H,KAAMtI,KAAKW,IAAI4H,GAAIvI,KAAKW,IAAI2H,OACpHtI,KAAKU,IAAIyH,GAAGnI,KAAKU,IAAI4H,KAAMtI,KAAKU,IAAIyH,GAAGnI,KAAKU,IAAI4H,KAAQtI,KAAKW,IAAIwH,GAAGnI,KAAKW,IAAI2H,KAAMtI,KAAKW,IAAIwH,GAAGnI,KAAKW,IAAI2H,MACnHiB,KAAWvJ,KAAKU,IAAI6H,GAAIvI,KAAKU,IAAI4H,KAAMtI,KAAKU,IAAI0H,GAAGpI,KAAKU,IAAI4H,KAAMtI,KAAKW,IAAI4H,GAAIvI,KAAKW,IAAI2H,KAAMtI,KAAKW,IAAIyH,GAAGpI,KAAKW,IAAI2H,KAC1G7I,KAAK8F,OAAOvF,KAAKU,IAAI6H,GAAIvI,KAAKU,IAAI4H,KAAMtI,KAAKU,IAAI6H,GAAIvI,KAAKU,IAAI4H,KAAMtI,KAAKW,IAAI4H,GAAIvI,KAAKW,IAAI2H,KAAMtI,KAAKW,IAAI4H,GAAIvI,KAAKW,IAAI2H,OACpHtI,KAAKU,IAAI0H,GAAGpI,KAAKU,IAAI4H,KAAMtI,KAAKU,IAAI0H,GAAGpI,KAAKU,IAAI4H,KAAQtI,KAAKW,IAAIyH,GAAGpI,KAAKW,IAAI2H,KAAMtI,KAAKW,IAAIyH,GAAGpI,KAAKW,IAAI2H,QAC9Ge,EAAQC,IAAYD,EAAQE,IAgBjC,IATAP,GAAOvJ,KAAK8F,MAAMvF,KAAKU,IAAIyH,GAAGnI,KAAKU,IAAI4H,KAAMtI,KAAKU,IAAIyH,GAAGnI,KAAKU,IAAI4H,KAAMtI,KAAKW,IAAIwH,GAAGnI,KAAKW,IAAI2H,KAAMtI,KAAKW,IAAIwH,GAAGnI,KAAKW,IAAI2H,KACxHW,GAAOxJ,KAAK8F,MAAMvF,KAAKU,IAAIyH,GAAGnI,KAAKU,IAAI6H,KAAMvI,KAAKU,IAAIyH,GAAGnI,KAAKU,IAAI6H,KAAMvI,KAAKW,IAAIwH,GAAGnI,KAAKW,IAAI4H,KAAMvI,KAAKW,IAAIwH,GAAGnI,KAAKW,IAAI4H,KACxHW,GAAOzJ,KAAK8F,MAAMvF,KAAKU,IAAI0H,GAAGpI,KAAKU,IAAI4H,KAAMtI,KAAKU,IAAI0H,GAAGpI,KAAKU,IAAI4H,KAAMtI,KAAKW,IAAIyH,GAAGpI,KAAKW,IAAI2H,KAAMtI,KAAKW,IAAIyH,GAAGpI,KAAKW,IAAI2H,KACxHa,GAAO1J,KAAK8F,MAAMvF,KAAKU,IAAI0H,GAAGpI,KAAKU,IAAI6H,KAAMvI,KAAKU,IAAI0H,GAAGpI,KAAKU,IAAI6H,KAAMvI,KAAKW,IAAIyH,GAAGpI,KAAKW,IAAI4H,KAAMvI,KAAKW,IAAIyH,GAAGpI,KAAKW,IAAI4H,KACxHO,IAAO9I,KAAKU,IAAIyH,GAAGnI,KAAKU,IAAI4H,KAAMtI,KAAKU,IAAIyH,GAAGnI,KAAKU,IAAI6H,KAAMvI,KAAKW,IAAIwH,GAAGnI,KAAKW,IAAI2H,KAAMtI,KAAKW,IAAIwH,GAAGnI,KAAKW,IAAI4H,KAAMS,GAAKC,GACxHF,IAAO/I,KAAKU,IAAI0H,GAAGpI,KAAKU,IAAI4H,KAAMtI,KAAKU,IAAI0H,GAAGpI,KAAKU,IAAI6H,KAAMvI,KAAKW,IAAIyH,GAAGpI,KAAKW,IAAI2H,KAAMtI,KAAKW,IAAIyH,GAAGpI,KAAKW,IAAI4H,KAAMW,GAAKC,GACxHC,EAAUN,EAAGrJ,KAAK8F,KAAK,EAAEwD,EAAGA,GAAIA,EAAGtJ,KAAK8F,KAAK,EAAEuD,EAAGA,GAG9CM,GAAU,KAAQ,CAEnBiB,GAAqB,EACrB,KAEH,CAAW5K,KAAK+F,IAAI4D,IAAY,OAM7BI,IACAC,EAAQtB,EACRuB,EAAStB,EACTuB,EAAUrB,EACVsB,EAAUrB,IAMhB,IAAI8B,EAGJ,OAAIb,EAAS,GAcVnB,EAAIoB,EACJrB,EAAIsB,EACJpB,EAAKqB,EACLpB,EAAKqB,EACA5J,KAAKI,GAAGkI,EAAG,GAAKtI,KAAKI,GAAGmI,EAAG,GAAOvI,KAAKI,GAAGiI,EAAE,GAAKrI,KAAKI,GAAGgI,EAAE,IAG7DxF,EAAKS,EACLR,EAAKH,EACLI,EAAKQ,EAELtD,KAAKoD,OAAOC,EAAGX,EAAGY,GAClBtD,KAAKoD,OAAOiF,EAAGC,EAAIC,KAKnB3F,EAAKwF,EACLvF,EAAKwF,EAEFvF,EADC9C,KAAK2C,QAAQyF,EAAGC,EAAGC,EAAI,GACnBA,EAEAC,EAGRvI,KAAKoD,OAAOgF,EAAGC,EAAGC,GAClBtI,KAAKoD,OAAOgF,EAAGC,EAAGE,MAIrBvI,KAAKoD,OAAOC,EAAGX,EAAGY,GAClBV,EAAKS,EACLR,EAAKH,EACLI,EAAKQ,GAGRwE,EAAW9H,KAAKiH,mBAAmBrE,EAAIC,EAAIC,EAAI,GACxCgF,EAGV,CAGN,OAAIiC,IACDQ,QAAQE,MAAM,kFAAkFxI,MAAOC,KAAM8F,KACzGF,CACV,CAKApG,WAAWgB,EAAI,KACZ1C,KAAK8D,SAAU,EACf9D,KAAKsK,SAAW5H,CACnB,CAKAgI,qBAAqBvC,GAClBnI,KAAKM,MAAQ6H,CAChB,EAKH,SAASwC,EAAeC,GACrB,IAAIC,EAAOpL,KAAKsH,MAAM6D,EAAUE,MAAQ9K,KAAK+K,SAC7C,GAAKF,EAAO,GAAOA,GAAQ7K,KAAK8K,MAAMtL,OAAS,OAAO,KACtD,MAAMwL,EAAM1L,GAAKA,EAAEA,EAEnBuL,EAAO7K,KAAK8K,MAAMD,GAElB,MAAMI,EAAKjL,KAAKiL,GAAIC,EAAKlL,KAAKmL,MAC9B,IAAIC,EAAMH,EAAGG,IAAIF,EAAGhL,GAAG2K,IACnBQ,EAAMJ,EAAGI,IAAIH,EAAG/K,GAAG0K,IACnBS,EAAML,EAAGK,IAAIJ,EAAG9K,GAAGyK,IAEvB,GAAI7K,KAAKuL,YAAcV,EAAK,EAAEK,EAAGhL,GAAGV,OAAQ,CACzC,MAAM6I,EAAIuC,EAAUY,MAChBC,EAAOR,EAAGG,IAAIF,EAAGhL,GAAG2K,EAAK,IACzBa,EAAOT,EAAGI,IAAIH,EAAG/K,GAAG0K,EAAK,IACzBc,EAAOV,EAAGK,IAAIJ,EAAG9K,GAAGyK,EAAK,IACzBG,EAAI3C,EAAEtG,EAAE0J,GAAMT,EAAI3C,EAAErG,EAAE0J,GAAMV,EAAI3C,EAAEF,EAAEwD,GAAQX,EAAI3C,EAAEtG,EAAEqJ,GAAKJ,EAAI3C,EAAErG,EAAEqJ,GAAKL,EAAI3C,EAAEF,EAAEmD,KAC/EF,EAAMK,EAAMJ,EAAMK,EAAMJ,EAAMK,EAAMd,IAE1C,CAEA,MAAO,CACJxD,GAAI+D,EAAMpL,KAAK4L,OACftE,GAAI8D,EAAMpL,KAAK4L,OACfpE,GAAI6D,EAAMrL,KAAK4L,OACfnE,GAAI4D,EAAMrL,KAAK4L,OACfC,GAAIP,EAAMtL,KAAK4L,OACfE,GAAIR,EAAMtL,KAAK4L,OACfG,MAAO/L,KAAKgM,UACZC,MAAO,CAACjM,KAAKkM,SACJ,QAAUrB,EACV,MAAQI,EAAGkB,WAAW,IAAKjB,EAAGhL,GAAG2K,IACjC,MAAQI,EAAGkB,WAAW,IAAKjB,EAAG/K,GAAG0K,IACjC,MAAQI,EAAGkB,WAAW,IAAKjB,EAAG9K,GAAGyK,KAGhD,CAQA,MAAMuB,UAAwBC,MAG3BC,cAAcC,EAAKC,GAChB,MAAMnE,EAAI,IAAIoE,MAAYF,GAErBvM,KAAK0M,UACP1M,KAAK0M,QAAU,CAAC,GAEnB,MAAMC,EAAM3M,KAAK0M,QAASE,EAAO5M,KAAK6M,YAElCxE,EAAEyE,MAAM,QAAS,UAAYF,IAC9BA,EAAKG,WAAa1E,EAAE0D,OAEnB1D,EAAEyE,MAAM,QAAS,UAAYF,IAC9BA,EAAKI,WAAa3E,EAAE0D,OAEvB1D,EAAEyE,MAAM,QAELH,EAAIM,UADH5E,EAAEyE,MAAM,QACO,GACVzE,EAAEyE,MAAM,QACE,GACVzE,EAAEyE,MAAM,QACE,EACVzE,EAAEyE,MAAM,OACE,EAEA,EACnBH,EAAIO,KAAO7E,EAAEyE,MAAM,QACnBH,EAAIQ,MAAQ9E,EAAEyE,MAAM,SAAW9M,KAAKoN,gBAAgBC,qBAAqBrN,KAAKoN,gBAAgBE,0BAE1FjF,EAAEyE,MAAM,SACTH,EAAIY,MAAQZ,EAAIa,QAAUb,EAAIc,SAAU,GAExCd,EAAIY,MAAQlF,EAAEyE,MAAM,OACpBH,EAAIa,QAAUnF,EAAEyE,MAAM,MACtBH,EAAIc,QAAUpF,EAAEyE,MAAM,MAGpBH,EAAIc,UAASd,EAAIY,OAAQ,IAE1BZ,EAAIY,OAASZ,EAAIM,WAAa,MAC/BN,EAAIe,OAASrF,EAAEyE,MAAM,MAExBH,EAAIgB,MAAQ,WACT,OAAO3N,KAAKyN,SAAWzN,KAAKmN,OAASnN,KAAKwN,SAAWxN,KAAKkN,MAAQlN,KAAKiN,SAC1E,EAEIN,EAAIgB,SACLhB,EAAIiB,KAAO,QACPjB,EAAIe,SAAQf,EAAIiB,MAAQ,MAE5BjB,EAAIiB,KAAOrB,EAEdvM,KAAK6N,aAAatB,EACrB,CAGAuB,kBACG,MAAM5C,EAAKlL,KAAK6M,YACVkB,EAAQ/N,KAAKoN,gBAAgBE,yBACnC,IAAI/K,EAAO2I,EAAGhL,GAAG,GAAImC,EAAOE,EACxBC,EAAO0I,EAAG/K,GAAG,GAAImC,EAAOE,EACxBwL,EAAO9C,EAAG9K,GAAG,GAAI6N,EAAOD,EAE5B,QAAS3K,EAAI,EAAGA,EAAI6H,EAAG7K,WAAYgD,EAAG,CACnC,MAAMtB,EAAImJ,EAAGhL,GAAGmD,GAAIrB,EAAIkJ,EAAG/K,GAAGkD,GAAI8E,EAAI+C,EAAG9K,GAAGiD,GAExCrD,KAAK0M,QAAQS,OACd5K,EAAO9C,KAAKG,IAAI2C,EAAMR,GAAKgM,EAAQ7C,EAAGgD,OAAO7K,GAAK6H,EAAGiD,IAAI9K,KACzDhB,EAAO5C,KAAKC,IAAI2C,EAAMN,GAAKgM,EAAQ7C,EAAGkD,QAAQ/K,GAAK6H,EAAGiD,IAAI9K,KAC1Db,EAAO/C,KAAKG,IAAI4C,EAAMR,GAAK+L,EAAQ7C,EAAGmD,OAAOhL,GAAK6H,EAAGoD,IAAIjL,KACzDf,EAAO7C,KAAKC,IAAI4C,EAAMN,GAAK+L,EAAQ7C,EAAGqD,QAAQlL,GAAK6H,EAAGoD,IAAIjL,KAC1D2K,EAAOvO,KAAKG,IAAIoO,EAAM7F,GAAK4F,EAAQ7C,EAAGsD,OAAOnL,GAAK6H,EAAGuD,IAAIpL,KACzD4K,EAAOxO,KAAKC,IAAIuO,EAAM9F,GAAK4F,EAAQ7C,EAAGwD,QAAQrL,GAAK6H,EAAGuD,IAAIpL,OAE1Dd,EAAO9C,KAAKG,IAAI2C,EAAMR,GACtBM,EAAO5C,KAAKC,IAAI2C,EAAMN,GACtBS,EAAO/C,KAAKG,IAAI4C,EAAMR,GACtBM,EAAO7C,KAAKC,IAAI4C,EAAMN,GACtBgM,EAAOvO,KAAKG,IAAIoO,EAAM7F,GACtB8F,EAAOxO,KAAKC,IAAIuO,EAAM9F,GAE5B,CAEA,SAASwG,EAAW/O,EAAKF,EAAKkP,GAC3B,OAAIhP,EAAMF,EAAYkP,GAAUlP,EAAME,GAC/BH,KAAK+F,IAAI5F,GAAO,IAAM,IAAO,IAAOH,KAAK+F,IAAI5F,EACvD,CACA,MAAMiP,EAAKF,EAAWpM,EAAMF,EAAM6I,EAAG4D,SAC/BC,EAAKJ,EAAWnM,EAAMF,EAAM4I,EAAG4D,SAC/BE,EAAKL,EAAWX,EAAMC,EAAM,GAClC,IAAIgB,EAAQ1M,EAAOsM,EAAIK,EAAQ7M,EAAOwM,EAClCM,EAAQ3M,EAAOuM,EAAIK,EAAQ9M,EAAOyM,EAClCM,EAAQrB,EAAOgB,EAAIM,EAAQrB,EAAOe,EAEjCC,EAAQ,GAAO1M,GAAQ,IAAI0M,EAAa,IAAL1M,GACnC2M,EAAQ,GAAO7M,GAAQ,IAAI6M,EAAQ,GAEnCC,EAAQ,GAAO3M,GAAQ,IAAI2M,EAAa,IAAL3M,GACnC4M,EAAQ,GAAO9M,GAAQ,IAAI8M,EAAQ,GAEnCC,EAAQ,GAAOrB,GAAQ,IAAIqB,EAAa,IAALrB,GACnCsB,EAAQ,GAAOrB,GAAQ,IAAIqB,EAAQ,GAExC,MAAMnE,EAAQnL,KAAK6M,YAEf1B,EAAMoE,WAAaC,YAASH,EAAQlE,EAAMoE,UAC1CpE,EAAMsE,WAAaD,YAASF,EAAQnE,EAAMsE,UAE9CzP,KAAK0P,gBAAiB,EAEtB,MAAMC,KAAQ7B,mBAAgB8B,SAAQzE,EAAM0E,KAAM1E,EAAM2E,MAaxD,GAZAH,EAAMI,MAAQ5E,EAAM4E,MAAQ,QAC5BC,qBAAkBL,EAAOxE,EAAM8E,QAC/BN,EAAMO,OAAOC,MAAQlB,EACrBU,EAAMO,OAAOE,MAAQlB,EACrBS,EAAMU,OAAOF,MAAQhB,EACrBQ,EAAMU,OAAOD,MAAQhB,EACrBO,EAAMW,OAAOH,MAAQd,EACrBM,EAAMW,OAAOF,MAAQd,EACrBK,EAAMJ,SAAWF,EACjBM,EAAMF,SAAWH,EACjBK,EAAMY,OAASC,YAEVxQ,KAAK0M,QAAQiB,QAAS,CACxB,MAAM8C,EAAWzQ,KAAK0Q,cAAcvF,GACpC,GAAIsF,EACD,QAASlR,EAAI,EAAGA,EAAI4L,EAAM0E,OAAQtQ,EAAG,CAClC,MAAM0C,EAAKgN,GAAS1P,EAAI,IAAO4L,EAAM0E,MAAQX,EAAQD,GACrD,QAAS/L,EAAI,EAAGA,EAAIiI,EAAM2E,OAAQ5M,EAAG,CAClC,MACMf,EAAKsO,EAAS3O,SAASG,EADlBkN,GAASjM,EAAI,IAAOiI,EAAM2E,MAAQV,EAAQD,IAErDQ,EAAMgB,OAAOhB,EAAMiB,OAAOrR,EAAE,EAAG2D,EAAE,IAAMf,CAC1C,CACH,CAEN,CAEA,OAAOwN,CACV,CAEAe,cAAcvF,GACX,OAAKnL,KAAK6Q,YACP7Q,KAAK6Q,UAAY,IAAIhR,GAAesL,GACpCnL,KAAK6Q,UAAUhN,mBACV7D,KAAK6Q,UAAUtQ,aACVP,KAAK6Q,WAEX7Q,KAAK6Q,SACf,CAEAC,cAAc7F,EAAIE,EAAO4F,EAAQC,GAC9B,MAAMP,EAAWzQ,KAAK0Q,cAAcvF,GACpC,IAAKsF,EAAU,OAEf,MAAMQ,EAAYhG,EAAGiG,KAAgBC,GAAUA,EAAQlG,EAAGmG,YAAc,GAAOnG,EAAGK,IAAI6F,GAA1DlG,EAAGK,IACzB+F,EAAwC,IAA3BrR,KAAK0M,QAAQO,UAC1BqE,EAAYtR,KAAK0M,QAAQO,WAAa,IAAOoE,EAC7CE,EAAYvR,KAAK0M,QAAQO,UAAY,IAAO,GAAOoE,GAAelG,EAAM6B,aAAe7B,EAAM4B,WAC7FyE,EAAY,IAAIC,MAAmBV,EAAQE,EAAU,EAAG,EAAEhG,EAAGyG,SAAUH,GAE7E,IAAKC,EAAUG,KAAO,EAAGH,EAAUG,KAAO,IAAKH,EAAUG,KAAM,CAC5DH,EAAUI,gBAEV,QAASC,EAAI,EAAGA,EAAIpB,EAASlQ,OAAQsR,EAAG,CACrC,MAAMC,EAAS,CAACrB,EAAS3P,QAAQ+Q,GAAIpB,EAAS1P,QAAQ8Q,GAAIpB,EAASzP,QAAQ6Q,IACrEE,EAAQ,GACd,IAAIC,GAAe,EACnB,QAASzS,EAAI,EAAGA,EAAI,IAAKA,EAAG,CACzB,MAAM0S,EAAMH,EAAOvS,GAAK,EACxBwS,EAAMnO,KAAKqH,EAAGG,IAAID,EAAMjL,GAAG+R,IAAOhH,EAAGI,IAAIF,EAAMhL,GAAG8R,IAAOhB,EAAS9F,EAAM/K,GAAG6R,MAErE9G,EAAMjL,GAAG+R,GAAOhH,EAAGiH,YAAgB/G,EAAMjL,GAAG+R,GAAOhH,EAAGkH,YACtDhH,EAAMhL,GAAG8R,GAAOhH,EAAGmH,YAAgBjH,EAAMhL,GAAG8R,GAAOhH,EAAGoH,cACzDL,GAAe,EACrB,CAEIV,GAAYU,GACbR,EAAUc,mBAAmBP,GAE5BR,GAAYS,IACbR,EAAUe,eAAeR,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,IAEjFP,EAAUe,eAAeR,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,IAEjFP,EAAUe,eAAeR,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,GAAIA,EAAM,IAEvF,CACH,CAEAP,EAAUgB,UAAU,CAACC,EAAKC,KACvB,MAAMC,KAAWC,MAAe5S,KAAK6S,iBAAkBH,EAAK,KAAM,IAAK,KACjE3G,EAAQsF,EAAarR,KAAK8S,SAAS3H,EAAM4B,YAAciE,EAAQ+B,UAAUN,EAAK1B,EAAOvR,QACrFwT,EAAW,IAAIC,KAAMC,qBAAkBC,MAAgBpH,EAAO,CAAEqH,KAAMH,KAAMI,WAAYC,cAAc,KAE3GC,EAAO,IAAIN,KAAMO,KAAKb,EAAUK,GAEjC/H,EAAGwI,UAAUF,EAAMvT,MAEnBuT,EAAKG,QAAU1T,IAAA,EACf,CAAC2T,EAASC,KACV,MAAMC,EAAS7T,KAAK8S,SAAS3H,EAAM6B,YAC9BgG,EAAW,IAAIC,KAAMa,kBAAkB,CAAE/H,MAAO,IAAIkH,KAAM1F,MAAMsG,GAASE,UAAW5I,EAAM6I,aAC1FC,KAAWC,SAAmBC,MAAenU,KAAK6S,iBAAkBe,EAAM,IAAK,KAAMZ,GAC1F/H,EAAGwI,UAAUQ,EAAUjU,KAAI,EAEjC,CAGAoU,aAAaC,EAAK9H,GACf,IAAKvM,KAAKoN,gBAAgBiH,GAAM,OAAO,EAYvC,GAVI9H,GAAQA,IAAQvM,KAAK0M,QAAQ4H,UAC9BtU,KAAKsM,cAAcC,EAAK8H,GAE3BE,OAAOC,OAAOxU,KAAK6M,YAAawH,UAEzBrU,KAAK6Q,iBAEL7Q,KAAKyU,aAGRzU,KAAK0U,UAAW,CACjB,MAAMC,EAAe3U,KAAK6S,iBAC1B8B,GAAcP,aAAapU,KAAK8N,kBAAmB9N,KAAK0M,QAAQkB,MAChE5N,KAAKyU,aAAeE,CACvB,CAEA,OAAO,CACV,CAKMC,SAAS,IAAAC,EAAA7U,KAAA,SAAA8U,KAAA,YACZ,IAAIC,EAAUC,QAAQC,SAAQ,GAE9B,OAAIJ,EAAKJ,eACNM,EAAUF,EAAKJ,aAAaG,gBACrBC,EAAKJ,cAGRM,EAAQG,KAAK,IAAML,EAAKM,cAAe,EARlC,EASf,CAIMA,cAAc,IAAAC,EAAApV,KAAA,SAAA8U,KAAA,YACjB,MAAMO,EAAOD,EAAKvC,iBACZ5H,EAAKmK,EAAKE,kBACVnK,EAAQiK,EAAKvI,YAEnB,KAAK1B,GAAUkK,GAASpK,GAAOA,EAAGsK,QAC/B,OAAOH,EAIV,GAFAnK,EAAGuK,eAAeJ,IAEbA,EAAK1I,QAAQiB,QAAS,CAExB,GAAI0H,EAAKI,aACN,OAAOL,EACiB,IAAtBjK,EAAMuK,aAA8C,IAAvBvK,EAAMwK,aACrCP,EAAK1I,QAAQc,SAAU,EAEvB4H,EAAK1I,QAAQe,SAAU,CAC7B,CAEA,MAAMmI,EAAgBA,CAAC5H,EAAMC,KAC1B,IAAI4H,EAAM,EACV,QAAStW,EAAI,EAAGA,EAAI4L,EAAM9K,WAAYd,EAC9B4L,EAAMjL,GAAGX,GAAK0L,EAAGiH,YAAgB/G,EAAMjL,GAAGX,GAAK0L,EAAGkH,YAClDhH,EAAMhL,GAAGZ,GAAK0L,EAAGmH,YAAgBjH,EAAMhL,GAAGZ,GAAK0L,EAAGoH,YAClDlH,EAAM/K,GAAGb,GAAKyO,GAAU7C,EAAM/K,GAAGb,IAAM0O,KAE1C4H,EAEL,OAAOA,GAIV,IAAIC,EAAO,EACX,GAAKC,WAASC,aAAe,IAAO/K,EAAGgL,MAAO,CAC3C,MAAMC,EAAcN,EAAc3K,EAAGmG,WAAYnG,EAAGkL,YAChDC,EAAY,IAEZF,EAAcE,IACfN,EAAOrW,KAAKsH,MAAMmP,EAAcE,GAC5BN,GAAQ,IAAGA,EAAO,GAE5B,CAEA,MAAMO,EAAYjB,EAAKkB,gBAAgB,CAAEC,KAAMpL,EAAOqL,KAAK,IACrDC,EAAW,GACjB,IAAIzF,EAAU,KACVD,EAAS,CAAC9F,EAAGmG,WAAYnG,EAAGkL,YAC5BO,EAAQzL,EAAG0L,SAAW,IAAMN,EAAUO,cAEtCxB,EAAK1I,QAAQc,UACdkJ,EAAQ,IAAOzL,EAAG0L,UAEjB1L,EAAG4L,SAAQH,GAAS,IAExBA,GAAS,EAAIjX,KAAKC,IAAIuL,EAAG0L,SAAW1L,EAAG6L,gBAAiB7L,EAAGyG,SAAWzG,EAAG8L,mBAErE3B,EAAK1I,QAAQa,OAAU6H,EAAK1I,QAAQO,WAAa,MAClD8D,EAASsE,EAAK2B,kBAAiB,GAC/BhG,EAAUqE,EAAK4B,kBAGd7B,EAAK1I,QAAQO,WACdmI,EAAKtE,cAAc7F,EAAIE,EAAO4F,EAAQC,GAEzC,QAASyB,EAAM,EAAGA,EAAM1B,EAAOvR,OAAO,IAAKiT,EAAK,CAC7C,MAAMyE,EAAWzX,KAAKC,IAAIqR,EAAO0B,GAAMxH,EAAGmG,YACpC+F,EAAW1X,KAAKG,IAAImR,EAAO0B,EAAI,GAAIxH,EAAGkL,YAE5C,GAAIe,GAAYC,EAAU,SAE1B,MAAMC,EAAO3X,KAAKsH,MAAM6O,EAAcsB,EAAUC,GAAYrB,GACtDhL,EAAQ,IAAIuM,WAAWD,GAC7B,IAAIE,EAAO,KAAMC,EAAS,EAAGC,EAAO,EAChCC,EAAM,KAAM1J,GAAQ,EAAO2J,EAAO,KAAMC,EAAO,EAAGC,EAAQ,GAE1DxC,EAAK1I,QAAQe,SAAW2H,EAAK1I,QAAQc,WACtC8J,EAAO,IAAIO,KAAcT,EAAMnM,EAAGgL,MAAOS,EAAM,IAE9CtB,EAAK1I,QAAQS,QACdsK,EAAM,IAAIK,aAAkB,EAALV,EAAO,GAC9BrJ,EAAQqH,EAAKhI,gBAAgBE,0BAG5B8H,EAAK1I,QAAQQ,OACdwK,EAAO,IAAII,aAAsB,GAARV,EAAK,KAEjC,QAAS7X,EAAI,EAAGA,EAAI4L,EAAM9K,WAAYd,EAAG,CAKtC,GAJK4L,EAAMjL,GAAGX,GAAK0L,EAAGiH,YAAgB/G,EAAMjL,GAAGX,GAAK0L,EAAGkH,YAClDhH,EAAMhL,GAAGZ,GAAK0L,EAAGmH,YAAgBjH,EAAMhL,GAAGZ,GAAK0L,EAAGoH,YAClDlH,EAAM/K,GAAGb,GAAK2X,GAAc/L,EAAM/K,GAAGb,IAAM4X,GAE5CrB,EAAO,IACRyB,GAAUA,EAAO,GAAKzB,EACP,IAAXyB,GAAc,SAGrBzM,EAAM0M,KAAUjY,EAEhB,MAAMwC,EAAIkJ,EAAGG,IAAID,EAAMjL,GAAGX,IACtByC,EAAIiJ,EAAGI,IAAIF,EAAMhL,GAAGZ,IACpB4I,EAAI8C,EAAGK,IAAIH,EAAM/K,GAAGb,IAEpB+X,GAAMA,EAAKS,SAAShW,EAAGC,EAAGmG,GAE1BsP,IACDA,EAAIE,GAAQ1M,EAAGG,IAAID,EAAMjL,GAAGX,IAAMwO,EAAQ5C,EAAM+C,OAAO3O,GAAK4L,EAAMgD,IAAI5O,KACtEkY,EAAIE,EAAK,GAAK3V,EACdyV,EAAIE,EAAK,GAAKxP,EACdsP,EAAIE,EAAK,GAAK1M,EAAGG,IAAID,EAAMjL,GAAGX,IAAMwO,EAAQ5C,EAAMiD,QAAQ7O,GAAK4L,EAAMgD,IAAI5O,KACzEkY,EAAIE,EAAK,GAAK3V,EACdyV,EAAIE,EAAK,GAAKxP,EACdwP,GAAM,EACNF,EAAIE,GAAQ5V,EACZ0V,EAAIE,EAAK,GAAK1M,EAAGI,IAAIF,EAAMhL,GAAGZ,IAAMwO,EAAQ5C,EAAMkD,OAAO9O,GAAK4L,EAAMmD,IAAI/O,KACxEkY,EAAIE,EAAK,GAAKxP,EACdsP,EAAIE,EAAK,GAAK5V,EACd0V,EAAIE,EAAK,GAAK1M,EAAGI,IAAIF,EAAMhL,GAAGZ,IAAMwO,EAAQ5C,EAAMoD,QAAQhP,GAAK4L,EAAMmD,IAAI/O,KACzEkY,EAAIE,EAAK,GAAKxP,EACdwP,GAAM,EACNF,EAAIE,GAAQ5V,EACZ0V,EAAIE,EAAK,GAAK3V,EACdyV,EAAIE,EAAK,GAAK1M,EAAGK,IAAIH,EAAM/K,GAAGb,IAAMwO,EAAQ5C,EAAMqD,OAAOjP,GAAK4L,EAAMsD,IAAIlP,KACxEkY,EAAIE,EAAK,GAAK5V,EACd0V,EAAIE,EAAK,GAAK3V,EACdyV,EAAIE,EAAK,GAAK1M,EAAGK,IAAIH,EAAM/K,GAAGb,IAAMwO,EAAQ5C,EAAMuD,QAAQnP,GAAK4L,EAAMsD,IAAIlP,KACzEoY,GAAM,GAGLD,IACGE,GAAO,IACRF,EAAKE,GAASF,EAAKE,EAAM,GACzBF,EAAKE,EAAM,GAAKF,EAAKE,EAAM,GAC3BF,EAAKE,EAAM,GAAKF,EAAKE,EAAM,GAC3BA,GAAO,GAEVF,EAAKE,GAAS7V,EACd2V,EAAKE,EAAM,GAAK5V,EAChB0V,EAAKE,EAAM,GAAKzP,EAChByP,GAAO,EAEb,CAEA,GAAIF,GAASE,EAAQ,GAAOF,EAAKlY,SAAWoY,EAAQ,CACjD,MAAM/D,EAASuB,EAAKtC,SAAS3H,EAAM6B,YAC7BgG,EAAW,IAAIC,KAAMa,kBAAkB,CAAE/H,MAAO,IAAIkH,KAAM1F,MAAMsG,GAASE,UAAW5I,EAAM6I,aAC1FC,KAAWC,MAAmBwD,EAAM1E,GAC1C/H,EAAGwI,UAAUQ,EAAUmB,GAEvBnB,EAAS9I,MAAQA,EACjB8I,EAASnJ,MAAQA,EACjBmJ,EAAShJ,GAAKA,EACdgJ,EAASrI,OAAS,GAAI8K,EACtBzC,EAAS/H,SAAWkJ,EAAK4C,gBACzB/D,EAASjI,UAAoC,IAAvBb,EAAM8M,aAAsB,SAAW,MAC7DhE,EAASlJ,QAAU,EACnBkJ,EAAS1I,YAAa,EAEtB0I,EAASiE,QAAUvN,CACtB,CAEA,GAAI8M,EAAK,CACN,MAAM5D,EAASuB,EAAKtC,SAAS3H,EAAM6B,YAC7BgG,EAAW,IAAIC,KAAMa,kBAAkB,CAAE/H,MAAO,IAAIkH,KAAM1F,MAAMsG,GAASE,UAAW5I,EAAM6I,aAC1FmE,KAAUjE,MAAmBuD,EAAKzE,GACxC/H,EAAGwI,UAAU0E,EAAS/C,GAEtB+C,EAAQhN,MAAQA,EAChBgN,EAAQrN,MAAQA,EAChBqN,EAAQlN,GAAKA,EACbkN,EAAQvM,OAAS,GAAI8K,EACrByB,EAAQjM,SAAWkJ,EAAK4C,gBACxBG,EAAQnM,UAAoC,IAAvBb,EAAM8M,aAAsB,SAAW,MAC5DE,EAAQpN,QAAU,EAElBoN,EAAQD,QAAUvN,CACrB,CAEA,GAAI2M,EAAM,CACP,IAAIvL,EAAQ,SAEPqJ,EAAK1I,QAAQc,SAAW4H,EAAK1I,QAAQa,SACvCxB,EAAQiF,GAAS+B,UAAUN,EAAK1B,EAAOvR,SAAW4V,EAAKtC,SAAS3H,EAAM8M,eAEzE,MAAMG,EAAKd,EAAKe,aAAa,CAAEtM,QAAOuM,MAAOlD,EAAK1I,QAAQc,QAAU,EAAIrC,EAAMwK,eAAgBT,KAAK3B,IAChGA,EAAKpI,MAAQA,EACboI,EAAKtI,GAAKA,EACVsI,EAAKvH,UAAoC,IAAvBb,EAAM8M,aAAsB,SAAW,MACzD1E,EAAK3H,OAAS,GAAI8K,EAClBnD,EAAKzI,MAAQA,EAEbyI,EAAKrH,SAAWkJ,EAAK4C,gBACrBzE,EAAK2E,QAAUvN,EACfM,EAAGwI,UAAUF,EAAM6B,EAAI,GAG1BqB,EAAS7S,KAAKwU,EACjB,CACH,CAEA,OAAOpD,QAAQuD,IAAI9B,GAAUvB,KAAK,KAC/B,MAAMG,EAAOD,EAAKvC,iBAElB,IADuBuC,EAAKV,YAAqC,IAAvBW,GAAMI,aAE7C,OAEH,MAAM+C,EAAMnD,GAAMoD,aAAaC,kBACzBC,EAAcvD,EAAKwD,iBAAiBC,eAAeL,GACzD,GAAKG,EAKL,IAFAA,EAAYG,QAAU1D,EAAK1I,QAAQgB,OAE/B0H,EAAK1I,QAAQgB,OACd,OAAOiL,EAAYI,WAEnBJ,EAAYK,SAAQ,IACvB9D,KAAK,KACLjK,EAAGgO,SAAS,KACL7D,GACP,EA5Nc,EA6NpB,CAGA,WAAa8D,CAAKC,EAAKjO,EAAIqB,GAAK,SAAAuI,KAAA,YAC7B,MAAMpB,EAAU,IAAItH,EAAgB+M,EAAKjO,GACzCwI,EAAQpH,cAAcC,EAAKrB,GAE3B,IAAI6J,EAAUC,QAAQC,QAAQ,MAE9B,OAAKvB,EAAQb,mBAEVkC,EAAUqE,cAAWF,KAAKC,EAAKzF,EAAQ5F,kBAAmB4F,EAAQhH,QAAQkB,MAC1E8F,EAAQgB,WAAY,GAGhBK,EAAQG,KAAK,KACjBxB,EAAQ2F,qBACD3F,EAAQyB,eACf,EAf0B,EAgBhC","names":["getMax","arr","v","i","length","Math","max","getMin","min","TGraphDelaunay","constructor","g","this","fGraph2D","fX","fY","fZ","fNpoints","fZout","fNdt","fNhull","fHullPoints","fXN","fYN","fOrder","fDist","fPTried","fNTried","fMTried","fInit","fXNmin","fXNmax","fYNmin","fYNmax","fXoffset","fYoffset","fXScaleFactor","fYScaleFactor","SetMaxIter","Initialize","CreateTrianglesDataStructure","FindHull","ComputeZ","x","y","xx","yy","zz","Interpolate","xmax","ymax","xmin","ymin","Array","n","Enclose","t1","t2","t3","e","xp","yp","j","oddNodes","FileIt","p","m","swap","tmp","ps","ns","ms","push","FindAllTriangles","fAllTri","xcntr","ycntr","xm","ym","sx","sy","nx","ny","mx","my","mdotn","nn","a","pa","na","ma","pb","nb","mb","p1","p2","p3","s","alittlebit","sqrt","abs","nhull_tmp","InHull","n1","n2","ntry","lastdphi","dd1","dd2","dx1","dx2","dx3","dy1","dy2","dy3","u","vNv1","vNv2","phi1","phi2","dphi","deTinhull","atan2","floor","PI","InterpolateOnPlane","TI1","TI2","TI3","x1","x2","x3","y1","y2","y3","f1","f2","f3","thevalue","it","ntris_tried","k","l","z","f","d","o1","o2","b","vxN","vyN","d1","d2","d3","c1","c2","dko1","dko2","dfo1","dfo2","sin_sum","cfo1k","co2o1k","co2o1f","ndegen","degen","fdegen","o1degen","o2degen","dxz","dyz","shouldbein","TMath_Sort","np","values","indicies","sort","skip_this_triangle","fMaxIter","console","warn","error","SetMarginBinsContent","graph2DTooltip","intersect","indx","index","nvertex","sqr","fp","gr","graph","grx","gry","grz","check_next","point","grx1","gry1","grz1","scale0","z1","z2","color","tip_color","lines","tip_name","axisAsText","TGraph2DPainter","ObjectPainter","decodeOptions","opt","_gr","DrawOptions","options","res","gr2d","getObject","check","fFillColor","fLineColor","Triangles","Line","Error","matchObjectType","clTGraph2DErrors","clTGraph2DAsymmErrors","Color","Circles","Markers","Zscale","isAny","Axis","storeDrawOpt","createHistogram","asymm","zmin","zmax","fEXlow","fEX","fEXhigh","fEYlow","fEY","fEYhigh","fEZlow","fEZ","fEZhigh","calc_delta","margin","dx","fMargin","dy","dz","uxmin","uxmax","uymin","uymax","uzmin","uzmax","fMinimum","kNoZoom","fMaximum","_own_histogram","histo","clTH2F","fNpx","fNpy","fName","setHistogramTitle","fTitle","fXaxis","fXmin","fXmax","fYaxis","fZaxis","fBits","kNoStats","dulaunay","buildDelaunay","fArray","getBin","_delaunay","drawTriangles","levels","palette","main_grz","logz","value","scale_zmin","plain_mode","do_faces","do_lines","triangles","Triangles3DHandler","size_z3d","loop","createBuffers","t","points","coord","use_triangle","pnt","scale_xmin","scale_xmax","scale_ymin","scale_ymax","addMainTriangle","addLineSegment","callFuncs","lvl","pos","geometry","createLegoGeom","getMainPainter","getColor","calcColor","material","THREE","MeshBasicMaterial","getMaterialArgs","side","DoubleSide","vertexColors","mesh","Mesh","add3DMesh","painter","_isgrid","lpos","lcolor","LineBasicMaterial","linewidth","fLineWidth","linemesh","createLineSegments","convertLegoBuf","updateObject","obj","original","Object","assign","$redraw_hist","axes_draw","hist_painter","redraw","_this","_asyncToGenerator","promise","Promise","resolve","then","drawGraph2D","_this2","main","getFramePainter","mode3d","remove3DMeshes","draw_content","fMarkerSize","fMarkerStyle","countSelected","cnt","step","settings","OptimizeDraw","webgl","numselected","scale_zmax","sizelimit","markeratt","createAttMarker","attr","std","promises","scale","size_x3d","getFullSize","usesvg","getFrameWidth","getFrameHeight","getContourLevels","getHistPalette","lvl_zmin","lvl_zmax","size","Int32Array","pnts","select","icnt","err","line","ierr","iline","PointsCreator","Float32Array","addPoint","getObjectHint","fMarkerColor","tooltip","errmesh","pr","createPoints","style","all","pal","findFunction","clTPaletteAxis","pal_painter","getPadPainter","findPainterFor","Enabled","drawPave","removeG","render3D","draw","dom","TH2Painter","addToPadPrimitives"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/hist/TGraph2DPainter.mjs"],"sourcesContent":["import { settings, createHistogram, setHistogramTitle, kNoZoom,\n         clTH2F, clTGraph2DErrors, clTGraph2DAsymmErrors, clTPaletteAxis, kNoStats } from '../core.mjs';\nimport { DrawOptions } from '../base/BasePainter.mjs';\nimport { ObjectPainter } from '../base/ObjectPainter.mjs';\nimport { TH2Painter } from './TH2Painter.mjs';\nimport { Triangles3DHandler } from '../hist2d/TH2Painter.mjs';\nimport { createLineSegments, PointsCreator, getMaterialArgs, THREE } from '../base/base3d.mjs';\nimport { convertLegoBuf, createLegoGeom } from './hist3d.mjs';\n\nfunction getMax(arr) {\n   let v = arr[0];\n   for (let i = 1; i < arr.length; ++i)\n      v = Math.max(v, arr[i]);\n   return v;\n}\n\nfunction getMin(arr) {\n   let v = arr[0];\n   for (let i = 1; i < arr.length; ++i)\n      v = Math.min(v, arr[i]);\n   return v;\n}\n\nfunction TMath_Sort(np, values, indicies /* , down */) {\n   const arr = new Array(np);\n   for (let i = 0; i < np; ++i)\n      arr[i] = { v: values[i], i };\n\n   arr.sort((a, b) => { return a.v < b.v ? -1 : (a.v > b.v ? 1 : 0); });\n\n   for (let i = 0; i < np; ++i)\n      indicies[i] = arr[i].i;\n}\n\nclass TGraphDelaunay {\n\n   constructor(g) {\n      this.fGraph2D = g;\n      this.fX = g.fX;\n      this.fY = g.fY;\n      this.fZ = g.fZ;\n      this.fNpoints = g.fNpoints;\n      this.fZout = 0.0;\n      this.fNdt = 0;\n      this.fNhull = 0;\n      this.fHullPoints = null;\n      this.fXN = null;\n      this.fYN = null;\n      this.fOrder = null;\n      this.fDist = null;\n      this.fPTried = null;\n      this.fNTried = null;\n      this.fMTried = null;\n      this.fInit = false;\n      this.fXNmin = 0.0;\n      this.fXNmax = 0.0;\n      this.fYNmin = 0.0;\n      this.fYNmax = 0.0;\n      this.fXoffset = 0.0;\n      this.fYoffset = 0.0;\n      this.fXScaleFactor = 0.0;\n      this.fYScaleFactor = 0.0;\n\n      this.SetMaxIter();\n   }\n\n\n   Initialize() {\n      if (!this.fInit) {\n         this.CreateTrianglesDataStructure();\n         this.FindHull();\n         this.fInit = true;\n      }\n   }\n\n   ComputeZ(x, y) {\n      // Initialize the Delaunay algorithm if needed.\n      // CreateTrianglesDataStructure computes fXoffset, fYoffset,\n      // fXScaleFactor and fYScaleFactor;\n      // needed in this function.\n      this.Initialize();\n\n      // Find the z value corresponding to the point (x,y).\n      const xx = (x+this.fXoffset)*this.fXScaleFactor,\n            yy = (y+this.fYoffset)*this.fYScaleFactor;\n      let zz = this.Interpolate(xx, yy);\n\n      // Wrong zeros may appear when points sit on a regular grid.\n      // The following line try to avoid this problem.\n      if (zz === 0) zz = this.Interpolate(xx+0.0001, yy);\n\n      return zz;\n   }\n\n\n   CreateTrianglesDataStructure() {\n      // Offset fX and fY so they average zero, and scale so the average\n      // of the X and Y ranges is one. The normalized version of fX and fY used\n      // in Interpolate.\n      const xmax = getMax(this.fGraph2D.fX),\n            ymax = getMax(this.fGraph2D.fY),\n            xmin = getMin(this.fGraph2D.fX),\n            ymin = getMin(this.fGraph2D.fY);\n      this.fXoffset = -(xmax+xmin)/2;\n      this.fYoffset = -(ymax+ymin)/2;\n      this.fXScaleFactor = 1/(xmax-xmin);\n      this.fYScaleFactor = 1/(ymax-ymin);\n      this.fXNmax = (xmax+this.fXoffset)*this.fXScaleFactor;\n      this.fXNmin = (xmin+this.fXoffset)*this.fXScaleFactor;\n      this.fYNmax = (ymax+this.fYoffset)*this.fYScaleFactor;\n      this.fYNmin = (ymin+this.fYoffset)*this.fYScaleFactor;\n      this.fXN = new Array(this.fNpoints+1);\n      this.fYN = new Array(this.fNpoints+1);\n      for (let n = 0; n < this.fNpoints; n++) {\n         this.fXN[n+1] = (this.fX[n]+this.fXoffset)*this.fXScaleFactor;\n         this.fYN[n+1] = (this.fY[n]+this.fYoffset)*this.fYScaleFactor;\n      }\n\n      // If needed, creates the arrays to hold the Delaunay triangles.\n      // A maximum number of 2*fNpoints is guessed. If more triangles will be\n      // find, FillIt will automatically enlarge these arrays.\n      this.fPTried = [];\n      this.fNTried = [];\n      this.fMTried = [];\n   }\n\n\n   // Is point e inside the triangle t1-t2-t3 ?\n\n   Enclose(t1, t2, t3, e) {\n      const x = [this.fXN[t1], this.fXN[t2], this.fXN[t3], this.fXN[t1]],\n            y = [this.fYN[t1], this.fYN[t2], this.fYN[t3], this.fYN[t1]],\n            xp = this.fXN[e],\n            yp = this.fYN[e];\n      let i = 0, j = x.length - 1, oddNodes = false;\n\n      for (; i < x.length; ++i) {\n         if ((y[i]<yp && y[j]>=yp) || (y[j]<yp && y[i]>=yp)) {\n            if (x[i]+(yp-y[i])/(y[j]-y[i])*(x[j]-x[i])<xp)\n               oddNodes = !oddNodes;\n         }\n         j = i;\n      }\n\n      return oddNodes;\n   }\n\n\n   // Files the triangle defined by the 3 vertices p, n and m into the\n   // fxTried arrays. If these arrays are to small they are automatically\n   // expanded.\n\n   FileIt(p, n, m) {\n      let swap, tmp, ps = p, ns = n, ms = m;\n\n      // order the vertices before storing them\n      do {\n         swap = false;\n         if (ns > ps) { tmp = ps; ps = ns; ns = tmp; swap = true; }\n         if (ms > ns) { tmp = ns; ns = ms; ms = tmp; swap = true; }\n      } while (swap);\n\n      // store a new Delaunay triangle\n      this.fNdt++;\n      this.fPTried.push(ps);\n      this.fNTried.push(ns);\n      this.fMTried.push(ms);\n   }\n\n\n   // Attempt to find all the Delaunay triangles of the point set. It is not\n   // guaranteed that it will fully succeed, and no check is made that it has\n   // fully succeeded (such a check would be possible by referencing the points\n   // that make up the convex hull). The method is to check if each triangle\n   // shares all three of its sides with other triangles. If not, a point is\n   // generated just outside the triangle on the side(s) not shared, and a new\n   // triangle is found for that point. If this method is not working properly\n   // (many triangles are not being found) it's probably because the new points\n   // are too far beyond or too close to the non-shared sides. Fiddling with\n   // the size of the `alittlebit' parameter may help.\n\n   FindAllTriangles() {\n      if (this.fAllTri) return;\n\n      this.fAllTri = true;\n\n      let xcntr, ycntr, xm, ym, xx, yy,\n          sx, sy, nx, ny, mx, my, mdotn, nn, a,\n          t1, t2, pa, na, ma, pb, nb, mb, p1=0, p2=0, m, n, p3=0;\n      const s = [false, false, false],\n            alittlebit = 0.0001;\n\n      this.Initialize();\n\n      // start with a point that is guaranteed to be inside the hull (the\n      // centre of the hull). The starting point is shifted \"a little bit\"\n      // otherwise, in case of triangles aligned on a regular grid, we may\n      // found none of them.\n      xcntr = 0;\n      ycntr = 0;\n      for (n = 1; n <= this.fNhull; n++) {\n         xcntr += this.fXN[this.fHullPoints[n-1]];\n         ycntr += this.fYN[this.fHullPoints[n-1]];\n      }\n      xcntr = xcntr/this.fNhull+alittlebit;\n      ycntr = ycntr/this.fNhull+alittlebit;\n      // and calculate it's triangle\n      this.Interpolate(xcntr, ycntr);\n\n      // loop over all Delaunay triangles (including those constantly being\n      // produced within the loop) and check to see if their 3 sides also\n      // correspond to the sides of other Delaunay triangles, i.e. that they\n      // have all their neighbors.\n      t1 = 1;\n      while (t1 <= this.fNdt) {\n         // get the three points that make up this triangle\n         pa = this.fPTried[t1-1];\n         na = this.fNTried[t1-1];\n         ma = this.fMTried[t1-1];\n\n         // produce three integers which will represent the three sides\n         s[0] = false;\n         s[1] = false;\n         s[2] = false;\n         // loop over all other Delaunay triangles\n         for (t2=1; t2<=this.fNdt; t2++) {\n            if (t2 !== t1) {\n               // get the points that make up this triangle\n               pb = this.fPTried[t2-1];\n               nb = this.fNTried[t2-1];\n               mb = this.fMTried[t2-1];\n               // do triangles t1 and t2 share a side?\n               if ((pa === pb && na === nb) || (pa === pb && na === mb) || (pa === nb && na === mb)) {\n                  // they share side 1\n                  s[0] = true;\n               } else if ((pa === pb && ma === nb) || (pa === pb && ma === mb) || (pa === nb && ma === mb)) {\n                  // they share side 2\n                  s[1] = true;\n               } else if ((na === pb && ma === nb) || (na === pb && ma === mb) || (na === nb && ma === mb)) {\n                  // they share side 3\n                  s[2] = true;\n               }\n            }\n            // if t1 shares all its sides with other Delaunay triangles then\n            // forget about it\n            if (s[0] && s[1] && s[2]) continue;\n         }\n         // Looks like t1 is missing a neighbor on at least one side.\n         // For each side, take a point a little bit beyond it and calculate\n         // the Delaunay triangle for that point, this should be the triangle\n         // which shares the side.\n         for (m=1; m<=3; m++) {\n            if (!s[m-1]) {\n               // get the two points that make up this side\n               if (m === 1) {\n                  p1 = pa;\n                  p2 = na;\n                  p3 = ma;\n               } else if (m === 2) {\n                  p1 = pa;\n                  p2 = ma;\n                  p3 = na;\n               } else if (m === 3) {\n                  p1 = na;\n                  p2 = ma;\n                  p3 = pa;\n               }\n               // get the coordinates of the centre of this side\n               xm = (this.fXN[p1]+this.fXN[p2])/2.0;\n               ym = (this.fYN[p1]+this.fYN[p2])/2.0;\n               // we want to add a little to these coordinates to get a point just\n               // outside the triangle; (sx,sy) will be the vector that represents\n               // the side\n               sx = this.fXN[p1]-this.fXN[p2];\n               sy = this.fYN[p1]-this.fYN[p2];\n               // (nx,ny) will be the normal to the side, but don't know if it's\n               // pointing in or out yet\n               nx = sy;\n               ny = -sx;\n               nn = Math.sqrt(nx*nx+ny*ny);\n               nx = nx/nn;\n               ny = ny/nn;\n               mx = this.fXN[p3]-xm;\n               my = this.fYN[p3]-ym;\n               mdotn = mx*nx+my*ny;\n               if (mdotn > 0) {\n                  // (nx,ny) is pointing in, we want it pointing out\n                  nx = -nx;\n                  ny = -ny;\n               }\n               // increase/decrease xm and ym a little to produce a point\n               // just outside the triangle (ensuring that the amount added will\n               // be large enough such that it won't be lost in rounding errors)\n               a = Math.abs(Math.max(alittlebit*xm, alittlebit*ym));\n               xx = xm+nx*a;\n               yy = ym+ny*a;\n               // try and find a new Delaunay triangle for this point\n               this.Interpolate(xx, yy);\n\n               // this side of t1 should now, hopefully, if it's not part of the\n               // hull, be shared with a new Delaunay triangle just calculated by Interpolate\n            }\n         }\n         t1++;\n      }\n   }\n\n   // Finds those points which make up the convex hull of the set. If the xy\n   // plane were a sheet of wood, and the points were nails hammered into it\n   // at the respective coordinates, then if an elastic band were stretched\n   // over all the nails it would form the shape of the convex hull. Those\n   // nails in contact with it are the points that make up the hull.\n\n   FindHull() {\n      if (!this.fHullPoints)\n         this.fHullPoints = new Array(this.fNpoints);\n\n      let nhull_tmp = 0;\n      for (let n=1; n<=this.fNpoints; n++) {\n         // if the point is not inside the hull of the set of all points\n         // bar it, then it is part of the hull of the set of all points\n         // including it\n         const is_in = this.InHull(n, n);\n         if (!is_in) {\n            // cannot increment fNhull directly - InHull needs to know that\n            // the hull has not yet been completely found\n            nhull_tmp++;\n            this.fHullPoints[nhull_tmp-1] = n;\n         }\n      }\n      this.fNhull = nhull_tmp;\n   }\n\n\n   // Is point e inside the hull defined by all points apart from x ?\n\n   InHull(e, x) {\n      let n1, n2, n, m, ntry,\n          lastdphi, dd1, dd2, dx1, dx2, dx3, dy1, dy2, dy3,\n          u, v, vNv1, vNv2, phi1, phi2, dphi,\n          deTinhull = false;\n\n      const xx = this.fXN[e],\n            yy = this.fYN[e];\n\n      if (this.fNhull > 0) {\n         //  The hull has been found - no need to use any points other than\n         //  those that make up the hull\n         ntry = this.fNhull;\n      } else {\n         //  The hull has not yet been found, will have to try every point\n         ntry = this.fNpoints;\n      }\n\n      //  n1 and n2 will represent the two points most separated by angle\n      //  from point e. Initially the angle between them will be <180 degrees.\n      //  But subsequent points will increase the n1-e-n2 angle. If it\n      //  increases above 180 degrees then point e must be surrounded by\n      //  points - it is not part of the hull.\n      n1 = 1;\n      n2 = 2;\n      if (n1 === x) {\n         n1 = n2;\n         n2++;\n      } else if (n2 === x)\n         n2++;\n\n\n      //  Get the angle n1-e-n2 and set it to lastdphi\n      dx1 = xx-this.fXN[n1];\n      dy1 = yy-this.fYN[n1];\n      dx2 = xx-this.fXN[n2];\n      dy2 = yy-this.fYN[n2];\n      phi1 = Math.atan2(dy1, dx1);\n      phi2 = Math.atan2(dy2, dx2);\n      dphi = (phi1-phi2)-(Math.floor((phi1-phi2)/(Math.PI*2))*Math.PI*2);\n      if (dphi < 0) dphi += Math.PI*2;\n      lastdphi = dphi;\n      for (n=1; n<=ntry; n++) {\n         if (this.fNhull > 0) {\n            // Try hull point n\n            m = this.fHullPoints[n-1];\n         } else\n            m = n;\n\n         if ((m !== n1) && (m !== n2) && (m !== x)) {\n            // Can the vector e->m be represented as a sum with positive\n            // coefficients of vectors e->n1 and e->n2?\n            dx1 = xx-this.fXN[n1];\n            dy1 = yy-this.fYN[n1];\n            dx2 = xx-this.fXN[n2];\n            dy2 = yy-this.fYN[n2];\n            dx3 = xx-this.fXN[m];\n            dy3 = yy-this.fYN[m];\n\n            dd1 = (dx2*dy1-dx1*dy2);\n            dd2 = (dx1*dy2-dx2*dy1);\n\n            if (dd1*dd2 !== 0) {\n               u = (dx2*dy3-dx3*dy2)/dd1;\n               v = (dx1*dy3-dx3*dy1)/dd2;\n               if ((u < 0) || (v < 0)) {\n                  // No, it cannot - point m does not lie in-between n1 and n2 as\n                  // viewed from e. Replace either n1 or n2 to increase the\n                  // n1-e-n2 angle. The one to replace is the one which makes the\n                  // smallest angle with e->m\n                  vNv1 = (dx1*dx3+dy1*dy3)/Math.sqrt(dx1*dx1+dy1*dy1);\n                  vNv2 = (dx2*dx3+dy2*dy3)/Math.sqrt(dx2*dx2+dy2*dy2);\n                  if (vNv1 > vNv2) {\n                     n1 = m;\n                     phi1 = Math.atan2(dy3, dx3);\n                     phi2 = Math.atan2(dy2, dx2);\n                  } else {\n                     n2 = m;\n                     phi1 = Math.atan2(dy1, dx1);\n                     phi2 = Math.atan2(dy3, dx3);\n                  }\n                  dphi = (phi1-phi2)-(Math.floor((phi1-phi2)/(Math.PI*2))*Math.PI*2);\n                  if (dphi < 0) dphi += Math.PI*2;\n                  if ((dphi - Math.PI)*(lastdphi - Math.PI) < 0) {\n                     // The addition of point m means the angle n1-e-n2 has risen\n                     // above 180 degrees, the point is in the hull.\n                     deTinhull = true;\n                     return deTinhull;\n                  }\n                  lastdphi = dphi;\n               }\n            }\n         }\n      }\n      // Point e is not surrounded by points - it is not in the hull.\n      return deTinhull;\n   }\n\n   // Finds the z-value at point e given that it lies\n   // on the plane defined by t1,t2,t3\n\n   InterpolateOnPlane(TI1, TI2, TI3, e) {\n      let tmp, swap, t1 = TI1, t2 = TI2, t3 = TI3;\n\n      // order the vertices\n      do {\n         swap = false;\n         if (t2 > t1) { tmp = t1; t1 = t2; t2 = tmp; swap = true; }\n         if (t3 > t2) { tmp = t2; t2 = t3; t3 = tmp; swap = true; }\n      } while (swap);\n\n      const x1 = this.fXN[t1],\n            x2 = this.fXN[t2],\n            x3 = this.fXN[t3],\n            y1 = this.fYN[t1],\n            y2 = this.fYN[t2],\n            y3 = this.fYN[t3],\n            f1 = this.fZ[t1-1],\n            f2 = this.fZ[t2-1],\n            f3 = this.fZ[t3-1],\n            u = (f1*(y2-y3)+f2*(y3-y1)+f3*(y1-y2))/(x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2)),\n            v = (f1*(x2-x3)+f2*(x3-x1)+f3*(x1-x2))/(y1*(x2-x3)+y2*(x3-x1)+y3*(x1-x2)),\n            w = f1-u*x1-v*y1;\n\n      return u*this.fXN[e] + v*this.fYN[e] + w;\n   }\n\n   // Finds the Delaunay triangle that the point (xi,yi) sits in (if any) and\n   // calculate a z-value for it by linearly interpolating the z-values that\n   // make up that triangle.\n\n   Interpolate(xx, yy) {\n      let thevalue,\n          it, ntris_tried, p, n, m,\n          i, j, k, l, z, f, d, o1, o2, a, b, t1, t2, t3,\n          ndegen = 0, degen = 0, fdegen = 0, o1degen = 0, o2degen = 0,\n          vxN, vyN,\n          d1, d2, d3, c1, c2, dko1, dko2, dfo1,\n          dfo2, sin_sum, cfo1k, co2o1k, co2o1f,\n          dx1, dx2, dx3, dy1, dy2, dy3, u, v;\n      const dxz = [0, 0, 0], dyz = [0, 0, 0];\n\n      // initialize the Delaunay algorithm if needed\n      this.Initialize();\n\n      // create vectors needed for sorting\n      if (!this.fOrder) {\n         this.fOrder = new Array(this.fNpoints);\n         this.fDist = new Array(this.fNpoints);\n      }\n\n      // the input point will be point zero.\n      this.fXN[0] = xx;\n      this.fYN[0] = yy;\n\n      // set the output value to the default value for now\n      thevalue = this.fZout;\n\n      // some counting\n      ntris_tried = 0;\n\n      // no point in proceeding if xx or yy are silly\n      if ((xx > this.fXNmax) || (xx < this.fXNmin) || (yy > this.fYNmax) || (yy < this.fYNmin))\n         return thevalue;\n\n      // check existing Delaunay triangles for a good one\n      for (it=1; it<=this.fNdt; it++) {\n         p = this.fPTried[it-1];\n         n = this.fNTried[it-1];\n         m = this.fMTried[it-1];\n         // p, n and m form a previously found Delaunay triangle, does it\n         // enclose the point?\n         if (this.Enclose(p, n, m, 0)) {\n            // yes, we have the triangle\n            thevalue = this.InterpolateOnPlane(p, n, m, 0);\n            return thevalue;\n         }\n      }\n\n      // is this point inside the convex hull?\n      const shouldbein = this.InHull(0, -1);\n      if (!shouldbein)\n         return thevalue;\n\n      // it must be in a Delaunay triangle - find it...\n\n      // order mass points by distance in mass plane from desired point\n      for (it=1; it<=this.fNpoints; it++) {\n         vxN = this.fXN[it];\n         vyN = this.fYN[it];\n         this.fDist[it-1] = Math.sqrt((xx-vxN)*(xx-vxN)+(yy-vyN)*(yy-vyN));\n      }\n\n      // sort array 'fDist' to find closest points\n      TMath_Sort(this.fNpoints, this.fDist, this.fOrder /* , false */);\n      for (it=0; it<this.fNpoints; it++) this.fOrder[it]++;\n\n      // loop over triplets of close points to try to find a triangle that\n      // encloses the point.\n      for (k=3; k<=this.fNpoints; k++) {\n         m = this.fOrder[k-1];\n         for (j=2; j<=k-1; j++) {\n            n = this.fOrder[j-1];\n            for (i=1; i<=j-1; i++) {\n               let skip_this_triangle = false; // used instead of goto L90\n               p = this.fOrder[i-1];\n               if (ntris_tried > this.fMaxIter) {\n                  // perhaps this point isn't in the hull after all\n                  /* Warning(\"Interpolate\",\n                             \"Abandoning the effort to find a Delaunay triangle (and thus interpolated z-value) for point %g %g\"\n                              ,xx,yy); */\n                  return thevalue;\n               }\n               ntris_tried++;\n               // check the points aren't colinear\n               d1 = Math.sqrt((this.fXN[p]-this.fXN[n])**2+(this.fYN[p]-this.fYN[n])**2);\n               d2 = Math.sqrt((this.fXN[p]-this.fXN[m])**2+(this.fYN[p]-this.fYN[m])**2);\n               d3 = Math.sqrt((this.fXN[n]-this.fXN[m])**2+(this.fYN[n]-this.fYN[m])**2);\n               if ((d1+d2 <= d3) || (d1+d3 <= d2) || (d2+d3 <= d1))\n                  continue;\n\n               // does the triangle enclose the point?\n               if (!this.Enclose(p, n, m, 0))\n                  continue;\n\n               // is it a Delaunay triangle? (ie. are there any other points\n               // inside the circle that is defined by its vertices?)\n\n               // test the triangle for Delaunay'ness\n\n               // loop over all other points testing each to see if it's\n               // inside the triangle's circle\n               ndegen = 0;\n               for (z = 1; z <= this.fNpoints; z++) {\n                  if ((z === p) || (z === n) || (z === m))\n                     continue; // goto L50;\n                  // An easy first check is to see if point z is inside the triangle\n                  // (if it's in the triangle it's also in the circle)\n\n                  // point z cannot be inside the triangle if it's further from (xx,yy)\n                  // than the furthest pointing making up the triangle - test this\n                  for (l=1; l<=this.fNpoints; l++) {\n                     if (this.fOrder[l-1] === z) {\n                        if ((l<i) || (l<j) || (l<k)) {\n                           // point z is nearer to (xx,yy) than m, n or p - it could be in the\n                           // triangle so call enclose to find out\n\n                           // if it is inside the triangle this can't be a Delaunay triangle\n                           if (this.Enclose(p, n, m, z)) { skip_this_triangle = true; break; } // goto L90;\n                        } else {\n                           // there's no way it could be in the triangle so there's no point\n                           // calling enclose\n                           break; // goto L1;\n                        }\n                     }\n                  }\n\n                  if (skip_this_triangle) break;\n\n                  // is point z colinear with any pair of the triangle points?\n   // L1:\n                  if (((this.fXN[p]-this.fXN[z])*(this.fYN[p]-this.fYN[n])) === ((this.fYN[p]-this.fYN[z])*(this.fXN[p]-this.fXN[n]))) {\n                     // z is colinear with p and n\n                     a = p;\n                     b = n;\n                  } else if (((this.fXN[p]-this.fXN[z])*(this.fYN[p]-this.fYN[m])) === ((this.fYN[p]-this.fYN[z])*(this.fXN[p]-this.fXN[m]))) {\n                     // z is colinear with p and m\n                     a = p;\n                     b = m;\n                  } else if (((this.fXN[n]-this.fXN[z])*(this.fYN[n]-this.fYN[m])) === ((this.fYN[n]-this.fYN[z])*(this.fXN[n]-this.fXN[m]))) {\n                     // z is colinear with n and m\n                     a = n;\n                     b = m;\n                  } else {\n                     a = 0;\n                     b = 0;\n                  }\n                  if (a !== 0) {\n                     // point z is colinear with 2 of the triangle points, if it lies\n                     // between them it's in the circle otherwise it's outside\n                     if (this.fXN[a] !== this.fXN[b]) {\n                        if (((this.fXN[z]-this.fXN[a])*(this.fXN[z]-this.fXN[b])) < 0) {\n                           skip_this_triangle = true;\n                           break;\n                           // goto L90;\n                        } else if (((this.fXN[z]-this.fXN[a])*(this.fXN[z]-this.fXN[b])) === 0) {\n                           // At least two points are sitting on top of each other, we will\n                           // treat these as one and not consider this a 'multiple points lying\n                           // on a common circle' situation. It is a sign something could be\n                           // wrong though, especially if the two coincident points have\n                           // different fZ's. If they don't then this is harmless.\n                           console.warn(`Interpolate Two of these three points are coincident ${a} ${b} ${z}`);\n                        }\n                     } else {\n                        if (((this.fYN[z]-this.fYN[a])*(this.fYN[z]-this.fYN[b])) < 0) {\n                           skip_this_triangle = true;\n                           break;\n                           // goto L90;\n                        } else if (((this.fYN[z]-this.fYN[a])*(this.fYN[z]-this.fYN[b])) === 0) {\n                           // At least two points are sitting on top of each other - see above.\n                           console.warn(`Interpolate Two of these three points are coincident ${a} ${b} ${z}`);\n                        }\n                     }\n                     // point is outside the circle, move to next point\n                     continue; // goto L50;\n                  }\n\n                  if (skip_this_triangle) break;\n\n                  /* Error(\"Interpolate\", \"Should not get to here\"); */\n                  // may as well soldier on\n                  // SL: initialize before try to find better values\n                  f = m;\n                  o1 = p;\n                  o2 = n;\n\n                  // if point z were to look at the triangle, which point would it see\n                  // lying between the other two? (we're going to form a quadrilateral\n                  // from the points, and then demand certain properties of that\n                  // quadrilateral)\n                  dxz[0] = this.fXN[p]-this.fXN[z];\n                  dyz[0] = this.fYN[p]-this.fYN[z];\n                  dxz[1] = this.fXN[n]-this.fXN[z];\n                  dyz[1] = this.fYN[n]-this.fYN[z];\n                  dxz[2] = this.fXN[m]-this.fXN[z];\n                  dyz[2] = this.fYN[m]-this.fYN[z];\n                  for (l=1; l<=3; l++) {\n                     dx1 = dxz[l-1];\n                     dx2 = dxz[l%3];\n                     dx3 = dxz[(l+1)%3];\n                     dy1 = dyz[l-1];\n                     dy2 = dyz[l%3];\n                     dy3 = dyz[(l+1)%3];\n\n                     // u et v are used only to know their sign. The previous\n                     // code computed them with a division which was long and\n                     // might be a division by 0. It is now replaced by a\n                     // multiplication.\n                     u = (dy3*dx2-dx3*dy2)*(dy1*dx2-dx1*dy2);\n                     v = (dy3*dx1-dx3*dy1)*(dy2*dx1-dx2*dy1);\n\n                     if ((u >= 0) && (v >= 0)) {\n                        // vector (dx3,dy3) is expressible as a sum of the other two vectors\n                        // with positive coefficients -> i.e. it lies between the other two vectors\n                        if (l === 1) {\n                           f = m; o1 = p; o2 = n;\n                        } else if (l === 2) {\n                           f = p; o1 = n; o2 = m;\n                        } else {\n                           f = n; o1 = m; o2 = p;\n                        }\n                        break; // goto L2;\n                     }\n                  }\n   // L2:\n                  // this is not a valid quadrilateral if the diagonals don't cross,\n                  // check that points f and z lie on opposite side of the line o1-o2,\n                  // this is true if the angle f-o1-z is greater than o2-o1-z and o2-o1-f\n                  cfo1k = ((this.fXN[f]-this.fXN[o1])*(this.fXN[z]-this.fXN[o1])+(this.fYN[f]-this.fYN[o1])*(this.fYN[z]-this.fYN[o1]))/\n                           Math.sqrt(((this.fXN[f]-this.fXN[o1])*(this.fXN[f]-this.fXN[o1])+(this.fYN[f]-this.fYN[o1])*(this.fYN[f]-this.fYN[o1]))*\n                           ((this.fXN[z]-this.fXN[o1])*(this.fXN[z]-this.fXN[o1])+(this.fYN[z]-this.fYN[o1])*(this.fYN[z]-this.fYN[o1])));\n                  co2o1k = ((this.fXN[o2]-this.fXN[o1])*(this.fXN[z]-this.fXN[o1])+(this.fYN[o2]-this.fYN[o1])*(this.fYN[z]-this.fYN[o1]))/\n                           Math.sqrt(((this.fXN[o2]-this.fXN[o1])*(this.fXN[o2]-this.fXN[o1])+(this.fYN[o2]-this.fYN[o1])*(this.fYN[o2]-this.fYN[o1]))*\n                           ((this.fXN[z]-this.fXN[o1])*(this.fXN[z]-this.fXN[o1]) + (this.fYN[z]-this.fYN[o1])*(this.fYN[z]-this.fYN[o1])));\n                  co2o1f = ((this.fXN[o2]-this.fXN[o1])*(this.fXN[f]-this.fXN[o1])+(this.fYN[o2]-this.fYN[o1])*(this.fYN[f]-this.fYN[o1]))/\n                           Math.sqrt(((this.fXN[o2]-this.fXN[o1])*(this.fXN[o2]-this.fXN[o1])+(this.fYN[o2]-this.fYN[o1])*(this.fYN[o2]-this.fYN[o1]))*\n                           ((this.fXN[f]-this.fXN[o1])*(this.fXN[f]-this.fXN[o1]) + (this.fYN[f]-this.fYN[o1])*(this.fYN[f]-this.fYN[o1])));\n                  if ((cfo1k > co2o1k) || (cfo1k > co2o1f)) {\n                     // not a valid quadrilateral - point z is definitely outside the circle\n                     continue; // goto L50;\n                  }\n                  // calculate the 2 internal angles of the quadrangle formed by joining\n                  // points z and f to points o1 and o2, at z and f. If they sum to less\n                  // than 180 degrees then z lies outside the circle\n                  dko1 = Math.sqrt((this.fXN[z]-this.fXN[o1])*(this.fXN[z]-this.fXN[o1])+(this.fYN[z]-this.fYN[o1])*(this.fYN[z]-this.fYN[o1]));\n                  dko2 = Math.sqrt((this.fXN[z]-this.fXN[o2])*(this.fXN[z]-this.fXN[o2])+(this.fYN[z]-this.fYN[o2])*(this.fYN[z]-this.fYN[o2]));\n                  dfo1 = Math.sqrt((this.fXN[f]-this.fXN[o1])*(this.fXN[f]-this.fXN[o1])+(this.fYN[f]-this.fYN[o1])*(this.fYN[f]-this.fYN[o1]));\n                  dfo2 = Math.sqrt((this.fXN[f]-this.fXN[o2])*(this.fXN[f]-this.fXN[o2])+(this.fYN[f]-this.fYN[o2])*(this.fYN[f]-this.fYN[o2]));\n                  c1 = ((this.fXN[z]-this.fXN[o1])*(this.fXN[z]-this.fXN[o2])+(this.fYN[z]-this.fYN[o1])*(this.fYN[z]-this.fYN[o2]))/dko1/dko2;\n                  c2 = ((this.fXN[f]-this.fXN[o1])*(this.fXN[f]-this.fXN[o2])+(this.fYN[f]-this.fYN[o1])*(this.fYN[f]-this.fYN[o2]))/dfo1/dfo2;\n                  sin_sum = c1*Math.sqrt(1-c2*c2)+c2*Math.sqrt(1-c1*c1);\n\n                  // sin_sum doesn't always come out as zero when it should do.\n                  if (sin_sum < -1.e-6) {\n                     // z is inside the circle, this is not a Delaunay triangle\n                     skip_this_triangle = true;\n                     break;\n                     // goto L90;\n                  } else if (Math.abs(sin_sum) <= 1.e-6) {\n                     // point z lies on the circumference of the circle (within rounding errors)\n                     // defined by the triangle, so there is potential for degeneracy in the\n                     // triangle set (Delaunay triangulation does not give a unique way to split\n                     // a polygon whose points lie on a circle into constituent triangles). Make\n                     // a note of the additional point number.\n                     ndegen++;\n                     degen = z;\n                     fdegen = f;\n                     o1degen = o1;\n                     o2degen = o2;\n                  }\n\n                  // L50: continue;\n               } // end of for ( z = 1 ...) loop\n\n               if (skip_this_triangle) continue;\n\n               // This is a good triangle\n               if (ndegen > 0) {\n                  // but is degenerate with at least one other,\n                  // haven't figured out what to do if more than 4 points are involved\n                  /* if (ndegen > 1) {\n                     Error(\"Interpolate\",\n                            \"More than 4 points lying on a circle. No decision making process formulated for triangulating this region in a non-arbitrary way %d %d %d %d\",\n                             p,n,m,degen);\n                     return thevalue;\n                  } */\n\n                  // we have a quadrilateral which can be split down either diagonal\n                  // (d<->f or o1<->o2) to form valid Delaunay triangles. Choose diagonal\n                  // with highest average z-value. Whichever we choose we will have\n                  // verified two triangles as good and two as bad, only note the good ones\n                  d = degen;\n                  f = fdegen;\n                  o1 = o1degen;\n                  o2 = o2degen;\n                  if ((this.fZ[o1-1] + this.fZ[o2-1]) > (this.fZ[d-1] + this.fZ[f-1])) {\n                     // best diagonalisation of quadrilateral is current one, we have\n                     // the triangle\n                     t1 = p;\n                     t2 = n;\n                     t3 = m;\n                     // file the good triangles\n                     this.FileIt(p, n, m);\n                     this.FileIt(d, o1, o2);\n                  } else {\n                     // use other diagonal to split quadrilateral, use triangle formed by\n                     // point f, the degnerate point d and whichever of o1 and o2 create\n                     // an enclosing triangle\n                     t1 = f;\n                     t2 = d;\n                     if (this.Enclose(f, d, o1, 0))\n                        t3 = o1;\n                      else\n                        t3 = o2;\n\n                     // file the good triangles\n                     this.FileIt(f, d, o1);\n                     this.FileIt(f, d, o2);\n                  }\n               } else {\n                  // this is a Delaunay triangle, file it\n                  this.FileIt(p, n, m);\n                  t1 = p;\n                  t2 = n;\n                  t3 = m;\n               }\n               // do the interpolation\n               thevalue = this.InterpolateOnPlane(t1, t2, t3, 0);\n               return thevalue;\n\n   // L90:      continue;\n            }\n         }\n      }\n      if (shouldbein)\n         console.error(`Interpolate Point outside hull when expected inside: this point could be dodgy ${xx}  ${yy} ${ntris_tried}`);\n      return thevalue;\n   }\n\n   // Defines the number of triangles tested for a Delaunay triangle\n   // (number of iterations) before abandoning the search\n\n   SetMaxIter(n = 100000) {\n      this.fAllTri = false;\n      this.fMaxIter = n;\n   }\n\n   // Sets the histogram bin height for points lying outside the convex hull ie:\n   // the bins in the margin.\n\n   SetMarginBinsContent(z) {\n      this.fZout = z;\n   }\n\n} // class TGraphDelaunay\n\n   /** @summary Function handles tooltips in the mesh */\nfunction graph2DTooltip(intersect) {\n   let indx = Math.floor(intersect.index / this.nvertex);\n   if ((indx < 0) || (indx >= this.index.length)) return null;\n   const sqr = v => v*v;\n\n   indx = this.index[indx];\n\n   const fp = this.fp, gr = this.graph;\n   let grx = fp.grx(gr.fX[indx]),\n       gry = fp.gry(gr.fY[indx]),\n       grz = fp.grz(gr.fZ[indx]);\n\n   if (this.check_next && indx+1<gr.fX.length) {\n      const d = intersect.point,\n          grx1 = fp.grx(gr.fX[indx+1]),\n          gry1 = fp.gry(gr.fY[indx+1]),\n          grz1 = fp.grz(gr.fZ[indx+1]);\n      if (sqr(d.x-grx1)+sqr(d.y-gry1)+sqr(d.z-grz1) < sqr(d.x-grx)+sqr(d.y-gry)+sqr(d.z-grz)) {\n         grx = grx1; gry = gry1; grz = grz1; indx++;\n      }\n   }\n\n   return {\n      x1: grx - this.scale0,\n      x2: grx + this.scale0,\n      y1: gry - this.scale0,\n      y2: gry + this.scale0,\n      z1: grz - this.scale0,\n      z2: grz + this.scale0,\n      color: this.tip_color,\n      lines: [this.tip_name,\n               'pnt: ' + indx,\n               'x: ' + fp.axisAsText('x', gr.fX[indx]),\n               'y: ' + fp.axisAsText('y', gr.fY[indx]),\n               'z: ' + fp.axisAsText('z', gr.fZ[indx])\n             ]\n   };\n}\n\n\n/**\n * @summary Painter for TGraph2D classes\n * @private\n */\n\nclass TGraph2DPainter extends ObjectPainter {\n\n   /** @summary Decode options string  */\n   decodeOptions(opt, _gr) {\n      const d = new DrawOptions(opt);\n\n      if (!this.options)\n         this.options = {};\n\n      const res = this.options, gr2d = this.getObject();\n\n      if (d.check('FILL_', 'color') && gr2d)\n         gr2d.fFillColor = d.color;\n\n      if (d.check('LINE_', 'color') && gr2d)\n         gr2d.fLineColor = d.color;\n\n      d.check('SAME');\n      if (d.check('TRI1'))\n         res.Triangles = 11; // wire-frame and colors\n      else if (d.check('TRI2'))\n         res.Triangles = 10; // only color triangles\n      else if (d.check('TRIW'))\n         res.Triangles = 1;\n      else if (d.check('TRI'))\n         res.Triangles = 2;\n      else\n         res.Triangles = 0;\n      res.Line = d.check('LINE');\n      res.Error = d.check('ERR') && (this.matchObjectType(clTGraph2DErrors) || this.matchObjectType(clTGraph2DAsymmErrors));\n\n      if (d.check('P0COL'))\n         res.Color = res.Circles = res.Markers = true;\n       else {\n         res.Color = d.check('COL');\n         res.Circles = d.check('P0');\n         res.Markers = d.check('P');\n      }\n\n      if (!res.Markers) res.Color = false;\n\n      if (res.Color || res.Triangles >= 10)\n         res.Zscale = d.check('Z');\n\n      res.isAny = function() {\n         return this.Markers || this.Error || this.Circles || this.Line || this.Triangles;\n      };\n\n      if (res.isAny()) {\n         res.Axis = 'lego2';\n         if (res.Zscale) res.Axis += 'z';\n      } else\n         res.Axis = opt;\n\n      this.storeDrawOpt(opt);\n   }\n\n   /** @summary Create histogram for axes drawing */\n   createHistogram() {\n      const gr = this.getObject(),\n            asymm = this.matchObjectType(clTGraph2DAsymmErrors);\n      let xmin = gr.fX[0], xmax = xmin,\n          ymin = gr.fY[0], ymax = ymin,\n          zmin = gr.fZ[0], zmax = zmin;\n\n      for (let p = 0; p < gr.fNpoints; ++p) {\n         const x = gr.fX[p], y = gr.fY[p], z = gr.fZ[p];\n\n         if (this.options.Error) {\n            xmin = Math.min(xmin, x - (asymm ? gr.fEXlow[p] : gr.fEX[p]));\n            xmax = Math.max(xmax, x + (asymm ? gr.fEXhigh[p] : gr.fEX[p]));\n            ymin = Math.min(ymin, y - (asymm ? gr.fEYlow[p] : gr.fEY[p]));\n            ymax = Math.max(ymax, y + (asymm ? gr.fEYhigh[p] : gr.fEY[p]));\n            zmin = Math.min(zmin, z - (asymm ? gr.fEZlow[p] : gr.fEZ[p]));\n            zmax = Math.max(zmax, z + (asymm ? gr.fEZhigh[p] : gr.fEZ[p]));\n         } else {\n            xmin = Math.min(xmin, x);\n            xmax = Math.max(xmax, x);\n            ymin = Math.min(ymin, y);\n            ymax = Math.max(ymax, y);\n            zmin = Math.min(zmin, z);\n            zmax = Math.max(zmax, z);\n         }\n      }\n\n      function calc_delta(min, max, margin) {\n         if (min < max) return margin * (max - min);\n         return Math.abs(min) < 1e5 ? 0.02 : 0.02 * Math.abs(min);\n      }\n      const dx = calc_delta(xmin, xmax, gr.fMargin),\n            dy = calc_delta(ymin, ymax, gr.fMargin),\n            dz = calc_delta(zmin, zmax, 0);\n      let uxmin = xmin - dx, uxmax = xmax + dx,\n          uymin = ymin - dy, uymax = ymax + dy,\n          uzmin = zmin - dz, uzmax = zmax + dz;\n\n      if ((uxmin < 0) && (xmin >= 0)) uxmin = xmin*0.98;\n      if ((uxmax > 0) && (xmax <= 0)) uxmax = 0;\n\n      if ((uymin < 0) && (ymin >= 0)) uymin = ymin*0.98;\n      if ((uymax > 0) && (ymax <= 0)) uymax = 0;\n\n      if ((uzmin < 0) && (zmin >= 0)) uzmin = zmin*0.98;\n      if ((uzmax > 0) && (zmax <= 0)) uzmax = 0;\n\n      const graph = this.getObject();\n\n      if (graph.fMinimum !== kNoZoom) uzmin = graph.fMinimum;\n      if (graph.fMaximum !== kNoZoom) uzmax = graph.fMaximum;\n\n      this._own_histogram = true; // when histogram created on client side\n\n      const histo = createHistogram(clTH2F, graph.fNpx, graph.fNpy);\n      histo.fName = graph.fName + '_h';\n      setHistogramTitle(histo, graph.fTitle);\n      histo.fXaxis.fXmin = uxmin;\n      histo.fXaxis.fXmax = uxmax;\n      histo.fYaxis.fXmin = uymin;\n      histo.fYaxis.fXmax = uymax;\n      histo.fZaxis.fXmin = uzmin;\n      histo.fZaxis.fXmax = uzmax;\n      histo.fMinimum = uzmin;\n      histo.fMaximum = uzmax;\n      histo.fBits |= kNoStats;\n\n      if (!this.options.isAny()) {\n         const dulaunay = this.buildDelaunay(graph);\n         if (dulaunay) {\n            for (let i = 0; i < graph.fNpx; ++i) {\n               const xx = uxmin + (i + 0.5) / graph.fNpx * (uxmax - uxmin);\n               for (let j = 0; j < graph.fNpy; ++j) {\n                  const yy = uymin + (j + 0.5) / graph.fNpy * (uymax - uymin),\n                        zz = dulaunay.ComputeZ(xx, yy);\n                  histo.fArray[histo.getBin(i+1, j+1)] = zz;\n               }\n            }\n         }\n      }\n\n      return histo;\n   }\n\n   buildDelaunay(graph) {\n      if (!this._delaunay) {\n         this._delaunay = new TGraphDelaunay(graph);\n         this._delaunay.FindAllTriangles();\n         if (!this._delaunay.fNdt)\n            delete this._delaunay;\n      }\n      return this._delaunay;\n   }\n\n   drawTriangles(fp, graph, levels, palette) {\n      const dulaunay = this.buildDelaunay(graph);\n      if (!dulaunay) return;\n\n      const main_grz = !fp.logz ? fp.grz : value => (value < fp.scale_zmin) ? -0.1 : fp.grz(value),\n            plain_mode = this.options.Triangles === 2,\n            do_faces = (this.options.Triangles >= 10) || plain_mode,\n            do_lines = (this.options.Triangles % 10 === 1) || (plain_mode && (graph.fLineColor !== graph.fFillColor)),\n            triangles = new Triangles3DHandler(levels, main_grz, 0, 2*fp.size_z3d, do_lines);\n\n      for (triangles.loop = 0; triangles.loop < 2; ++triangles.loop) {\n         triangles.createBuffers();\n\n         for (let t = 0; t < dulaunay.fNdt; ++t) {\n            const points = [dulaunay.fPTried[t], dulaunay.fNTried[t], dulaunay.fMTried[t]],\n                  coord = [];\n            let use_triangle = true;\n            for (let i = 0; i < 3; ++i) {\n               const pnt = points[i] - 1;\n               coord.push(fp.grx(graph.fX[pnt]), fp.gry(graph.fY[pnt]), main_grz(graph.fZ[pnt]));\n\n                if ((graph.fX[pnt] < fp.scale_xmin) || (graph.fX[pnt] > fp.scale_xmax) ||\n                    (graph.fY[pnt] < fp.scale_ymin) || (graph.fY[pnt] > fp.scale_ymax))\n                  use_triangle = false;\n            }\n\n            if (do_faces && use_triangle)\n               triangles.addMainTriangle(...coord);\n\n            if (do_lines && use_triangle) {\n               triangles.addLineSegment(coord[0], coord[1], coord[2], coord[3], coord[4], coord[5]);\n\n               triangles.addLineSegment(coord[3], coord[4], coord[5], coord[6], coord[7], coord[8]);\n\n               triangles.addLineSegment(coord[6], coord[7], coord[8], coord[0], coord[1], coord[2]);\n            }\n         }\n      }\n\n      triangles.callFuncs((lvl, pos) => {\n         const geometry = createLegoGeom(this.getMainPainter(), pos, null, 100, 100),\n               color = plain_mode ? this.getColor(graph.fFillColor) : palette.calcColor(lvl, levels.length),\n               material = new THREE.MeshBasicMaterial(getMaterialArgs(color, { side: THREE.DoubleSide, vertexColors: false })),\n\n          mesh = new THREE.Mesh(geometry, material);\n\n         fp.add3DMesh(mesh, this);\n\n         mesh.painter = this; // to let use it with context menu\n      }, (_isgrid, lpos) => {\n         const lcolor = this.getColor(graph.fLineColor),\n              material = new THREE.LineBasicMaterial({ color: new THREE.Color(lcolor), linewidth: graph.fLineWidth }),\n              linemesh = createLineSegments(convertLegoBuf(this.getMainPainter(), lpos, 100, 100), material);\n         fp.add3DMesh(linemesh, this);\n      });\n   }\n\n   /** @summary Update TGraph2D object */\n   updateObject(obj, opt) {\n      if (!this.matchObjectType(obj)) return false;\n\n      if (opt && (opt !== this.options.original))\n         this.decodeOptions(opt, obj);\n\n      Object.assign(this.getObject(), obj);\n\n      delete this._delaunay; // rebuild triangles\n\n      delete this.$redraw_hist;\n\n      // if our own histogram was used as axis drawing, we need update histogram as well\n      if (this.axes_draw) {\n         const hist_painter = this.getMainPainter();\n         hist_painter?.updateObject(this.createHistogram(), this.options.Axis);\n         this.$redraw_hist = hist_painter;\n      }\n\n      return true;\n   }\n\n   /** @summary Redraw TGraph2D object\n     * @desc Update histogram drawing if necessary\n     * @return {Promise} for drawing ready */\n   async redraw() {\n      let promise = Promise.resolve(true);\n\n      if (this.$redraw_hist) {\n         promise = this.$redraw_hist.redraw();\n         delete this.$redraw_hist;\n      }\n\n      return promise.then(() => this.drawGraph2D());\n   }\n\n   /** @summary Actual drawing of TGraph2D object\n     * @return {Promise} for drawing ready */\n   async drawGraph2D() {\n      const main = this.getMainPainter(),\n            fp = this.getFramePainter(),\n            graph = this.getObject();\n\n      if (!graph || !main || !fp || !fp.mode3d)\n         return this;\n\n      fp.remove3DMeshes(this);\n\n      if (!this.options.isAny()) {\n         // no need to draw smoothing if histogram content was drawn\n         if (main.draw_content)\n            return this;\n         if ((graph.fMarkerSize === 1) && (graph.fMarkerStyle === 1))\n            this.options.Circles = true;\n         else\n            this.options.Markers = true;\n      }\n\n      const countSelected = (zmin, zmax) => {\n         let cnt = 0;\n         for (let i = 0; i < graph.fNpoints; ++i) {\n            if ((graph.fX[i] < fp.scale_xmin) || (graph.fX[i] > fp.scale_xmax) ||\n                (graph.fY[i] < fp.scale_ymin) || (graph.fY[i] > fp.scale_ymax) ||\n                (graph.fZ[i] < zmin) || (graph.fZ[i] >= zmax)) continue;\n\n            ++cnt;\n         }\n         return cnt;\n      };\n\n      // try to define scale-down factor\n      let step = 1;\n      if ((settings.OptimizeDraw > 0) && !fp.webgl) {\n         const numselected = countSelected(fp.scale_zmin, fp.scale_zmax),\n             sizelimit = 50000;\n\n         if (numselected > sizelimit) {\n            step = Math.floor(numselected / sizelimit);\n            if (step <= 2) step = 2;\n         }\n      }\n\n      const markeratt = this.createAttMarker({ attr: graph, std: false }),\n            promises = [];\n      let palette = null,\n          levels = [fp.scale_zmin, fp.scale_zmax],\n          scale = fp.size_x3d / 100 * markeratt.getFullSize();\n\n      if (this.options.Circles)\n         scale = 0.06 * fp.size_x3d;\n\n      if (fp.usesvg) scale *= 0.3;\n\n      scale *= 7 * Math.max(fp.size_x3d / fp.getFrameWidth(), fp.size_z3d / fp.getFrameHeight());\n\n      if (this.options.Color || (this.options.Triangles >= 10)) {\n         levels = main.getContourLevels(true);\n         palette = main.getHistPalette();\n      }\n\n      if (this.options.Triangles)\n         this.drawTriangles(fp, graph, levels, palette);\n\n      for (let lvl = 0; lvl < levels.length-1; ++lvl) {\n         const lvl_zmin = Math.max(levels[lvl], fp.scale_zmin),\n               lvl_zmax = Math.min(levels[lvl+1], fp.scale_zmax);\n\n         if (lvl_zmin >= lvl_zmax) continue;\n\n         const size = Math.floor(countSelected(lvl_zmin, lvl_zmax) / step),\n               index = new Int32Array(size);\n         let pnts = null, select = 0, icnt = 0,\n             err = null, asymm = false, line = null, ierr = 0, iline = 0;\n\n         if (this.options.Markers || this.options.Circles)\n            pnts = new PointsCreator(size, fp.webgl, scale/3);\n\n         if (this.options.Error) {\n            err = new Float32Array(size*6*3);\n            asymm = this.matchObjectType(clTGraph2DAsymmErrors);\n          }\n\n         if (this.options.Line)\n            line = new Float32Array((size-1)*6);\n\n         for (let i = 0; i < graph.fNpoints; ++i) {\n            if ((graph.fX[i] < fp.scale_xmin) || (graph.fX[i] > fp.scale_xmax) ||\n                (graph.fY[i] < fp.scale_ymin) || (graph.fY[i] > fp.scale_ymax) ||\n                (graph.fZ[i] < lvl_zmin) || (graph.fZ[i] >= lvl_zmax)) continue;\n\n            if (step > 1) {\n               select = (select+1) % step;\n               if (select !== 0) continue;\n            }\n\n            index[icnt++] = i; // remember point index for tooltip\n\n            const x = fp.grx(graph.fX[i]),\n                y = fp.gry(graph.fY[i]),\n                z = fp.grz(graph.fZ[i]);\n\n            if (pnts) pnts.addPoint(x, y, z);\n\n            if (err) {\n               err[ierr] = fp.grx(graph.fX[i] - (asymm ? graph.fEXlow[i] : graph.fEX[i]));\n               err[ierr+1] = y;\n               err[ierr+2] = z;\n               err[ierr+3] = fp.grx(graph.fX[i] + (asymm ? graph.fEXhigh[i] : graph.fEX[i]));\n               err[ierr+4] = y;\n               err[ierr+5] = z;\n               ierr+=6;\n               err[ierr] = x;\n               err[ierr+1] = fp.gry(graph.fY[i] - (asymm ? graph.fEYlow[i] : graph.fEY[i]));\n               err[ierr+2] = z;\n               err[ierr+3] = x;\n               err[ierr+4] = fp.gry(graph.fY[i] + (asymm ? graph.fEYhigh[i] : graph.fEY[i]));\n               err[ierr+5] = z;\n               ierr+=6;\n               err[ierr] = x;\n               err[ierr+1] = y;\n               err[ierr+2] = fp.grz(graph.fZ[i] - (asymm ? graph.fEZlow[i] : graph.fEZ[i]));\n               err[ierr+3] = x;\n               err[ierr+4] = y;\n               err[ierr+5] = fp.grz(graph.fZ[i] + (asymm ? graph.fEZhigh[i] : graph.fEZ[i]));\n               ierr+=6;\n            }\n\n            if (line) {\n               if (iline>=6) {\n                  line[iline] = line[iline-3];\n                  line[iline+1] = line[iline-2];\n                  line[iline+2] = line[iline-1];\n                  iline+=3;\n               }\n               line[iline] = x;\n               line[iline+1] = y;\n               line[iline+2] = z;\n               iline+=3;\n            }\n         }\n\n         if (line && (iline > 3) && (line.length === iline)) {\n            const lcolor = this.getColor(graph.fLineColor),\n                  material = new THREE.LineBasicMaterial({ color: new THREE.Color(lcolor), linewidth: graph.fLineWidth }),\n                  linemesh = createLineSegments(line, material);\n            fp.add3DMesh(linemesh, this);\n\n            linemesh.graph = graph;\n            linemesh.index = index;\n            linemesh.fp = fp;\n            linemesh.scale0 = 0.7*scale;\n            linemesh.tip_name = this.getObjectHint();\n            linemesh.tip_color = (graph.fMarkerColor === 3) ? 0xFF0000 : 0x00FF00;\n            linemesh.nvertex = 2;\n            linemesh.check_next = true;\n\n            linemesh.tooltip = graph2DTooltip;\n         }\n\n         if (err) {\n            const lcolor = this.getColor(graph.fLineColor),\n                  material = new THREE.LineBasicMaterial({ color: new THREE.Color(lcolor), linewidth: graph.fLineWidth }),\n                  errmesh = createLineSegments(err, material);\n            fp.add3DMesh(errmesh, this);\n\n            errmesh.graph = graph;\n            errmesh.index = index;\n            errmesh.fp = fp;\n            errmesh.scale0 = 0.7*scale;\n            errmesh.tip_name = this.getObjectHint();\n            errmesh.tip_color = (graph.fMarkerColor === 3) ? 0xFF0000 : 0x00FF00;\n            errmesh.nvertex = 6;\n\n            errmesh.tooltip = graph2DTooltip;\n         }\n\n         if (pnts) {\n            let color = 'blue';\n\n            if (!this.options.Circles || this.options.Color)\n               color = palette?.calcColor(lvl, levels.length) ?? this.getColor(graph.fMarkerColor);\n\n            const pr = pnts.createPoints({ color, style: this.options.Circles ? 4 : graph.fMarkerStyle }).then(mesh => {\n               mesh.graph = graph;\n               mesh.fp = fp;\n               mesh.tip_color = (graph.fMarkerColor === 3) ? 0xFF0000 : 0x00FF00;\n               mesh.scale0 = 0.3*scale;\n               mesh.index = index;\n\n               mesh.tip_name = this.getObjectHint();\n               mesh.tooltip = graph2DTooltip;\n               fp.add3DMesh(mesh, this);\n            });\n\n            promises.push(pr);\n         }\n      }\n\n      return Promise.all(promises).then(() => {\n         const main = this.getMainPainter(),\n               handle_palette = this.axes_draw || (main?.draw_content === false);\n         if (!handle_palette)\n            return;\n\n         const pal = main?.findFunction(clTPaletteAxis),\n               pal_painter = this.getPadPainter()?.findPainterFor(pal);\n         if (!pal_painter)\n            return;\n\n         pal_painter.Enabled = this.options.Zscale;\n\n         if (this.options.Zscale)\n            return pal_painter.drawPave();\n         else\n            pal_painter.removeG(); // completely remove drawing without need to redraw complete pad\n      }).then(() => {\n         fp.render3D(100);\n         return this;\n      });\n   }\n\n   /** @summary draw TGraph2D object */\n   static async draw(dom, gr, opt) {\n      const painter = new TGraph2DPainter(dom, gr);\n      painter.decodeOptions(opt, gr);\n\n      let promise = Promise.resolve(null);\n\n      if (!painter.getMainPainter()) {\n         // histogram is not preserved in TGraph2D\n         promise = TH2Painter.draw(dom, painter.createHistogram(), painter.options.Axis);\n         painter.axes_draw = true;\n      }\n\n      return promise.then(() => {\n         painter.addToPadPrimitives();\n         return painter.drawGraph2D();\n      });\n   }\n\n} // class TGraph2DPainter\n\nexport { TGraph2DPainter };\n"],"x_google_ignoreList":[0]}