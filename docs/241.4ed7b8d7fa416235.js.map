{"version":3,"file":"241.4ed7b8d7fa416235.js","mappings":"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","names":["kNotEditable","BIT","clTGraphErrors","clTGraphAsymmErrors","clTGraphBentErrors","clTGraphMultiErrors","TGraphPainter","ObjectPainter","constructor","dom","graph","super","this","axes_draw","bins","xmin","ymin","xmax","ymax","wheel_zoomy","is_bent","_typename","has_errors","match","redraw","promise","Promise","resolve","_this","$redraw_hist","hist_painter","getMainPainter","$secondary","then","drawGraph","cleanup","interactive_bin","get_gme","getObject","decodeOptions","opt","first_time","isStr","indexOf","slice","is_gme","blocks_gme","has_main","options","decodeBlock","d","res","Object","assign","Line","Curve","Rect","Mark","Bar","OutRange","EF","Fill","MainError","Ends","ScaleErrX","check","partAsFloat","Errors","Axis","NoOpt","PadStats","original","second_x","second_y","individual_styles","split","shift","DrawOptions","hopt","forEach","name","part","empty","pos3d","partAsInt","_pfc","_plc","_pmc","blocks","skip_errors_x0","skip_errors_y0","undefined","length","fMarkerStyle","len","fEX","m","k","Math","max","fEY","pad","getPadPainter","getRootPad","fPrimitives","arr","bl","subres","push","extractGmeErrors","nblock","gr","bin","eylow","fEyL","indx","eyhigh","fEyH","createBins","kind","npoints","fNpoints","clTCutG","Array","p","x","fX","y","fY","exlow","exhigh","fExL","fExH","fEXlow","fEXhigh","fEYlow","fEYhigh","min","createHistogram","set_x","set_y","dx","dy","uxmin","uxmax","minimum","maximum","histo","fHistogram","minimum0","maximum0","fMaximum","kNoZoom","fMinimum","fName","kNoStats","fBits","_own_histogram","fTitle","fXaxis","fXmin","fXmax","fYaxis","unzoomUserRange","dox","doy","extractAxesProperties","canOptimize","settings","optimizeBins","maxpnt","filter_func","selbins","isFunc","n","step","floor","optbins","getTooltips","lines","funcs","get_main","getGrFuncs","gme","getObjectHint","axisAsText","x_handle","ny","fNYErrors","y_handle","pmain","getFramePainter","grx","gry","pp","rect","getPadRect","width","height","pad_layer","pw","ph","getFrameWidth","getFrameHeight","value","fLogx","log10","fUxmin","fX1","fX2","fLogy","fUymin","fY1","fY2","revertAxis","v","appendExclusion","is_curve","path","drawbins","excl_width","extrabins","dlen","sqrt","dgrx","dgry","path2","buildSvgPath","draw_g","append","attr","call","fillatt","func","style","drawBins","w","h","lineatt","main_block","excl_side","path1","bins2","draw_kind","close_symbol","elem","curvebins","nodes","pnt","i","grx1","round","gry1","grx0","grx2","gry0","gry2","grdx0","fEXlowd","grdx2","fEXhighd","grdy0","fEYlowd","grdy2","fEYhighd","selectAll","data","enter","yy0","usefill","fp","fpcol","getFillColor","TAttFillHandler","color","pattern","bar","dw","abs","filter","error_size","lw","gStyle","bb","vv","hh","vleft","vright","htop","hbottom","mainLine","fMarkerSize","visible","isBatchMode","error","createAttMarker","marker_size","markeratt","getFullSize","resetPos","want_tooltip","fill","hints_marker","hsz","maxnummarker","getMarkerLength","create","appendQQ","xqmin","scale_xmin","fXq1","xqmax","scale_xmax","fXq2","yqmin","scale_ymin","fYq1","yqmax","scale_ymax","fYq2","makeLine","x1","y1","x2","y2","yxmin","yxmax","latt1","TAttLineHandler","latt2","drawBins3D","console","log","createG","mp","createAutoColor","icolor","fFillColor","fLineColor","fMarkerColor","createAttLine","can_excl","createAttFill","used","fAttLine","std","fAttFill","svg","getCanvSvg","sub_g","addMoveHandler","testEditable","extractTooltip","extractTooltipForPath","esz","isbar1","findbin","best_dist2","best","msize","each","d3_select","datum","dist2","nproc","marker","matchy","exact","title","color1","d3bin","user_info","obj","cont","color2","menu","menu_dist","binindx","showTooltip","hint","select","remove","usepath","showTooltipForPath","ttrect","changed","property","processTooltipEvent","disabled","findBestBin","dist","islines","bestindx","bestbin","bestdist","radius","IsInside","bin0","posy","linex","liney","linedist","closeline","arg","TestBit","InvertBit","ismark","getColor","ttbin","moveEnabled","moveStart","pos_dx","pos_dy","move_funcs","move_binindx","move_bin","move_x0","move_y0","moveDrag","moveEnd","not_changed","exec","matchObjectType","submitCanvExec","fillContextMenu","snapid","addchk","size","executeMenuCommand","method","args","canp","getCanvPainter","_readonly","getLastEventPos","userx","usery","toFixed","args_menu_id","updateObject","canZoomInside","axis","clickButton","funcname","main","zoom","findFunc","fFunctions","find","clTF1","clTF2","findStat","clTPaveStats","createStat","stats","normal_canvas","create_stats","st","fOptStat","fOptFit","fBorderSize","fX1NDC","fStatX","fStatW","fY1NDC","fStatY","fStatH","fX2NDC","fY2NDC","fStatColor","fFillStyle","fStatStyle","fTextAngle","fTextSize","fStatFontSize","fTextAlign","fTextColor","fStatTextColor","fTextFont","fStatFont","AddText","Add","fillStatistic","stat","dostat","dofit","clearPave","fillFunctionStat","drawNextFunction","_this2","$main_painter","drawObject","getDom","drawAxisHisto","_this3","TH1Painter","static","painter","$primary","addToPadPrimitives","_drawGraph"],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/hist2d/TGraphPainter.mjs"],"sourcesContent":["import { gStyle, BIT, settings, create, createHistogram, isBatchMode, isFunc, isStr,\n         clTPaveStats, clTCutG, clTF1, clTF2, kNoZoom } from '../core.mjs';\nimport { select as d3_select } from '../d3.mjs';\nimport { DrawOptions, buildSvgPath } from '../base/BasePainter.mjs';\nimport { ObjectPainter } from '../base/ObjectPainter.mjs';\nimport { TH1Painter } from './TH1Painter.mjs';\nimport { TAttLineHandler } from '../base/TAttLineHandler.mjs';\nimport { TAttFillHandler } from '../base/TAttFillHandler.mjs';\nimport { addMoveHandler } from '../gui/utils.mjs';\n\n\nconst kNotEditable = BIT(18),   // bit set if graph is non editable\n      clTGraphErrors = 'TGraphErrors',\n      clTGraphAsymmErrors = 'TGraphAsymmErrors',\n      clTGraphBentErrors = 'TGraphBentErrors',\n      clTGraphMultiErrors = 'TGraphMultiErrors';\n\n/**\n * @summary Painter for TGraph object.\n *\n * @private\n */\n\nclass TGraphPainter extends ObjectPainter {\n\n   constructor(dom, graph) {\n      super(dom, graph);\n      this.axes_draw = false; // indicate if graph histogram was drawn for axes\n      this.bins = null;\n      this.xmin = this.ymin = this.xmax = this.ymax = 0;\n      this.wheel_zoomy = true;\n      this.is_bent = (graph._typename == clTGraphBentErrors);\n      this.has_errors = (graph._typename == clTGraphErrors) ||\n                        (graph._typename == clTGraphMultiErrors) ||\n                        (graph._typename == clTGraphAsymmErrors) ||\n                         this.is_bent || graph._typename.match(/^RooHist/);\n   }\n\n   /** @summary Redraw graph\n     * @desc may redraw histogram which was used to draw axes\n     * @return {Promise} for ready */\n   async redraw() {\n      let promise = Promise.resolve(true);\n\n      if (this.$redraw_hist) {\n         delete this.$redraw_hist;\n         let hist_painter = this.getMainPainter();\n         if (hist_painter?.$secondary && this.axes_draw)\n            promise = hist_painter.redraw();\n      }\n\n      return promise.then(() => this.drawGraph());\n   }\n\n   /** @summary Cleanup graph painter */\n   cleanup() {\n      delete this.interactive_bin; // break mouse handling\n      delete this.bins;\n      super.cleanup();\n   }\n\n   /** @summary Returns object if this drawing TGraphMultiErrors object */\n   get_gme() {\n      let graph = this.getObject();\n      return graph?._typename == clTGraphMultiErrors ? graph : null;\n   }\n\n   /** @summary Decode options */\n   decodeOptions(opt, first_time) {\n\n      if (isStr(opt) && (opt.indexOf('same ') == 0))\n         opt = opt.slice(5);\n\n      let graph = this.getObject(),\n          is_gme = !!this.get_gme(),\n          blocks_gme = [],\n          has_main = first_time ? !!this.getMainPainter() : !this.axes_draw;\n\n      if (!this.options) this.options = {};\n\n      // decode main draw options for the graph\n      const decodeBlock = (d, res) => {\n         Object.assign(res, { Line: 0, Curve: 0, Rect: 0, Mark: 0, Bar: 0, OutRange: 0, EF:0, Fill: 0, MainError: 1, Ends: 1, ScaleErrX: 1 });\n\n         if (is_gme && d.check('S=', true)) res.ScaleErrX = d.partAsFloat();\n\n         if (d.check('L')) res.Line = 1;\n         if (d.check('F')) res.Fill = 1;\n         if (d.check('CC')) res.Curve = 2; // draw all points without reduction\n         if (d.check('C')) res.Curve = 1;\n         if (d.check('*')) res.Mark = 103;\n         if (d.check('P0')) res.Mark = 104;\n         if (d.check('P')) res.Mark = 1;\n         if (d.check('B')) { res.Bar = 1; res.Errors = 0; }\n         if (d.check('Z')) { res.Errors = 1; res.Ends = 0; }\n         if (d.check('||')) { res.Errors = 1; res.MainError = 0; res.Ends = 1; }\n         if (d.check('[]')) { res.Errors = 1; res.MainError = 0; res.Ends = 2; }\n         if (d.check('|>')) { res.Errors = 1; res.Ends = 3; }\n         if (d.check('>')) { res.Errors = 1; res.Ends = 4; }\n         if (d.check('0')) { res.Mark = 1; res.Errors = 1; res.OutRange = 1; }\n         if (d.check('1')) { if (res.Bar == 1) res.Bar = 2; }\n         if (d.check('2')) { res.Rect = 1; res.Errors = 0; }\n         if (d.check('3')) { res.EF = 1; res.Errors = 0;  }\n         if (d.check('4')) { res.EF = 2; res.Errors = 0; }\n         if (d.check('5')) { res.Rect = 2; res.Errors = 0; }\n         if (d.check('X')) res.Errors = 0;\n      };\n\n      Object.assign(this.options, { Axis: '', NoOpt: 0, PadStats: false, original: opt, second_x: false, second_y: false, individual_styles: false });\n\n      if (is_gme && opt) {\n         if (opt.indexOf(';') > 0) {\n            blocks_gme = opt.split(';');\n            opt = blocks_gme.shift();\n         } else if (opt.indexOf('_') > 0) {\n            blocks_gme = opt.split('_');\n            opt = blocks_gme.shift();\n         }\n      }\n\n      let res = this.options,\n          d = new DrawOptions(opt);\n\n      // check pad options first\n      res.PadStats = d.check('USE_PAD_STATS');\n      let hopt = '', checkhopt = ['USE_PAD_TITLE', 'LOGXY', 'LOGX', 'LOGY', 'LOGZ', 'GRIDXY', 'GRIDX', 'GRIDY', 'TICKXY', 'TICKX', 'TICKY'];\n      checkhopt.forEach(name => { if (d.check(name)) hopt += ';' + name; });\n      if (d.check('XAXIS_', true)) hopt += ';XAXIS_' + d.part;\n      if (d.check('YAXIS_', true)) hopt += ';YAXIS_' + d.part;\n\n      if (d.empty()) {\n         res.original = has_main ? 'lp' : 'alp';\n         d = new DrawOptions(res.original);\n      }\n\n      if (d.check('NOOPT')) res.NoOpt = 1;\n\n      if (d.check('POS3D_', true)) res.pos3d = d.partAsInt() - 0.5;\n\n      res._pfc = d.check('PFC');\n      res._plc = d.check('PLC');\n      res._pmc = d.check('PMC');\n\n      if (d.check('A')) res.Axis = d.check('I') ? 'A' : 'AXIS'; // I means invisible axis\n      if (d.check('X+')) { res.Axis += 'X+'; res.second_x = has_main; }\n      if (d.check('Y+')) { res.Axis += 'Y+'; res.second_y = has_main; }\n      if (d.check('RX')) res.Axis += 'RX';\n      if (d.check('RY')) res.Axis += 'RY';\n\n      if (is_gme) {\n         res.blocks = [];\n         res.skip_errors_x0 = res.skip_errors_y0 = false;\n         if (d.check('X0')) res.skip_errors_x0 = true;\n         if (d.check('Y0')) res.skip_errors_y0 = true;\n      }\n\n      decodeBlock(d, res);\n\n      if (is_gme) {\n         if (d.check('S')) res.individual_styles = true;\n      }\n\n      // if (d.check('E')) res.Errors = 1; // E option only defined for TGraphPolar\n\n      if (res.Errors === undefined)\n         res.Errors = this.has_errors && (!is_gme || !blocks_gme.length) ? 1 : 0;\n\n      // special case - one could use svg:path to draw many pixels (\n      if ((res.Mark == 1) && (graph.fMarkerStyle == 1)) res.Mark = 101;\n\n      // if no drawing option is selected and if opt == '' nothing is done.\n      if (res.Line + res.Fill + res.Curve + res.Mark + res.Bar + res.EF + res.Rect + res.Errors == 0) {\n         if (d.empty()) res.Line = 1;\n      }\n\n      if (graph._typename == clTGraphErrors) {\n         let len = graph.fEX.length, m = 0;\n         for (let k = 0; k < len; ++k)\n            m = Math.max(m, graph.fEX[k], graph.fEY[k]);\n         if (m < 1e-100)\n            res.Errors = 0;\n      }\n\n      if (!res.Axis) {\n         // check if axis should be drawn\n         // either graph drawn directly or\n         // graph is first object in list of primitives\n         let pp = this.getPadPainter(),\n             pad = pp?.getRootPad(true);\n         if (!pad || (pad?.fPrimitives?.arr[0] === graph)) res.Axis = 'AXIS';\n      } else if (res.Axis.indexOf('A') < 0) {\n         res.Axis = 'AXIS,' + res.Axis;\n      }\n\n      res.Axis += hopt;\n\n      for (let bl = 0; bl < blocks_gme.length; ++bl) {\n         let subd = new DrawOptions(blocks_gme[bl]), subres = {};\n         decodeBlock(subd, subres);\n         subres.skip_errors_x0 = res.skip_errors_x0;\n         subres.skip_errors_y0 = res.skip_errors_y0;\n         res.blocks.push(subres);\n      }\n   }\n\n   /** @summary Extract errors for TGraphMultiErrors */\n   extractGmeErrors(nblock) {\n      if (!this.bins) return;\n      let gr = this.getObject();\n      this.bins.forEach(bin => {\n         bin.eylow  = gr.fEyL[nblock][bin.indx];\n         bin.eyhigh = gr.fEyH[nblock][bin.indx];\n      });\n   }\n\n   /** @summary Create bins for TF1 drawing */\n   createBins() {\n      let gr = this.getObject();\n      if (!gr) return;\n\n      let kind = 0, npoints = gr.fNpoints;\n      if ((gr._typename === clTCutG) && (npoints > 3)) npoints--;\n\n      if (gr._typename == clTGraphErrors)\n         kind = 1;\n      else if (gr._typename == clTGraphMultiErrors)\n         kind = 2;\n      else if (gr._typename == clTGraphAsymmErrors || gr._typename == clTGraphBentErrors || gr._typename.match(/^RooHist/))\n         kind = 3;\n\n      this.bins = new Array(npoints);\n\n      for (let p = 0; p < npoints; ++p) {\n         let bin = this.bins[p] = { x: gr.fX[p], y: gr.fY[p], indx: p };\n         switch(kind) {\n            case 1:\n               bin.exlow = bin.exhigh = gr.fEX[p];\n               bin.eylow = bin.eyhigh = gr.fEY[p];\n               break;\n            case 2:\n               bin.exlow  = gr.fExL[p];\n               bin.exhigh = gr.fExH[p];\n               bin.eylow  = gr.fEyL[0][p];\n               bin.eyhigh = gr.fEyH[0][p];\n               break;\n            case 3:\n               bin.exlow  = gr.fEXlow[p];\n               bin.exhigh = gr.fEXhigh[p];\n               bin.eylow  = gr.fEYlow[p];\n               bin.eyhigh = gr.fEYhigh[p];\n               break;\n         }\n\n         if (p === 0) {\n            this.xmin = this.xmax = bin.x;\n            this.ymin = this.ymax = bin.y;\n         }\n\n         if (kind > 0) {\n            this.xmin = Math.min(this.xmin, bin.x - bin.exlow, bin.x + bin.exhigh);\n            this.xmax = Math.max(this.xmax, bin.x - bin.exlow, bin.x + bin.exhigh);\n            this.ymin = Math.min(this.ymin, bin.y - bin.eylow, bin.y + bin.eyhigh);\n            this.ymax = Math.max(this.ymax, bin.y - bin.eylow, bin.y + bin.eyhigh);\n         } else {\n            this.xmin = Math.min(this.xmin, bin.x);\n            this.xmax = Math.max(this.xmax, bin.x);\n            this.ymin = Math.min(this.ymin, bin.y);\n            this.ymax = Math.max(this.ymax, bin.y);\n         }\n      }\n   }\n\n   /** @summary Create histogram for graph\n     * @desc graph bins should be created when calling this function\n     * @param {boolean} [set_x] - set X axis range\n     * @param {boolean} [set_y] - set Y axis range */\n   createHistogram(set_x, set_y) {\n      if (!set_x && !set_y)\n         set_x = set_y = true;\n\n      let xmin = this.xmin, xmax = this.xmax, ymin = this.ymin, ymax = this.ymax;\n\n      if (xmin >= xmax) xmax = xmin+1;\n      if (ymin >= ymax) ymax = ymin+1;\n      let dx = (xmax-xmin)*0.1, dy = (ymax-ymin)*0.1,\n          uxmin = xmin - dx, uxmax = xmax + dx,\n          minimum = ymin - dy, maximum = ymax + dy;\n\n      if ((uxmin < 0) && (xmin >= 0)) uxmin = xmin*0.9;\n      if ((uxmax > 0) && (xmax <= 0)) uxmax = 0;\n\n      let graph = this.getObject(),\n          histo = graph.fHistogram,\n          minimum0 = minimum, maximum0 = maximum;\n\n      if (!histo) {\n         histo = graph.fHistogram = createHistogram('TH1F', 100);\n         histo.fName = graph.fName + '_h';\n         const kNoStats = BIT(9);\n         histo.fBits = histo.fBits | kNoStats;\n         this._own_histogram = true;\n      } else if ((histo.fMaximum != kNoZoom) && (histo.fMinimum != kNoZoom)) {\n         minimum = histo.fMinimum;\n         maximum = histo.fMaximum;\n      }\n\n      if (graph.fMinimum != kNoZoom) minimum = ymin = graph.fMinimum;\n      if (graph.fMaximum != kNoZoom) maximum = graph.fMaximum;\n      if ((minimum < 0) && (ymin >= 0)) minimum = 0.9*ymin;\n\n      histo.fTitle = graph.fTitle;\n\n      if (set_x) {\n         histo.fXaxis.fXmin = uxmin;\n         histo.fXaxis.fXmax = uxmax;\n      }\n\n      if (set_y) {\n         histo.fYaxis.fXmin = Math.min(minimum0, minimum);\n         histo.fYaxis.fXmax = Math.max(maximum0, maximum);\n         histo.fMinimum = minimum;\n         histo.fMaximum = maximum;\n      }\n\n      return histo;\n   }\n\n   /** @summary Check if user range can be unzommed\n     * @desc Used when graph points covers larger range than provided histogram */\n   unzoomUserRange(dox, doy /*, doz*/) {\n      let graph = this.getObject();\n      if (this._own_histogram || !graph) return false;\n\n      let histo = graph.fHistogram;\n\n      dox = dox && histo && ((histo.fXaxis.fXmin > this.xmin) || (histo.fXaxis.fXmax < this.xmax));\n      doy = doy && histo && ((histo.fYaxis.fXmin > this.ymin) || (histo.fYaxis.fXmax < this.ymax));\n      if (!dox && !doy) return false;\n\n      this.createHistogram(dox, doy);\n      this.getMainPainter()?.extractAxesProperties(1); // just to enforce ranges extraction\n\n      return true;\n   }\n\n   /** @summary Returns true if graph drawing can be optimize */\n   canOptimize() {\n      return (settings.OptimizeDraw > 0) && !this.options.NoOpt;\n   }\n\n   /** @summary Returns optimized bins - if optimization enabled */\n   optimizeBins(maxpnt, filter_func) {\n      if ((this.bins.length < 30) && !filter_func) return this.bins;\n\n      let selbins = null;\n      if (isFunc(filter_func)) {\n         for (let n = 0; n < this.bins.length; ++n) {\n            if (filter_func(this.bins[n],n)) {\n               if (!selbins) selbins = (n == 0) ? [] : this.bins.slice(0, n);\n            } else {\n               if (selbins) selbins.push(this.bins[n]);\n            }\n         }\n      }\n      if (!selbins) selbins = this.bins;\n\n      if (!maxpnt) maxpnt = 500000;\n\n      if ((selbins.length < maxpnt) || !this.canOptimize()) return selbins;\n      let step = Math.floor(selbins.length / maxpnt);\n      if (step < 2) step = 2;\n      let optbins = [];\n      for (let n = 0; n < selbins.length; n+=step)\n         optbins.push(selbins[n]);\n\n      return optbins;\n   }\n\n   /** @summary Returns tooltip for specified bin */\n   getTooltips(d) {\n      let pmain = this.get_main(), lines = [],\n          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),\n          gme = this.get_gme();\n\n      lines.push(this.getObjectHint());\n\n      if (d && funcs) {\n         if (d.indx !== undefined)\n            lines.push('p = ' + d.indx);\n         lines.push('x = ' + funcs.axisAsText('x', d.x), 'y = ' + funcs.axisAsText('y', d.y));\n         if (gme)\n            lines.push('error x = -' + funcs.axisAsText('x', gme.fExL[d.indx]) + '/+' + funcs.axisAsText('x', gme.fExH[d.indx]));\n         else if (this.options.Errors && (funcs.x_handle.kind == 'normal') && (d.exlow || d.exhigh))\n            lines.push('error x = -' + funcs.axisAsText('x', d.exlow) + '/+' + funcs.axisAsText('x', d.exhigh));\n\n         if (gme) {\n            for (let ny = 0; ny < gme.fNYErrors; ++ny)\n               lines.push(`error y${ny} = -${funcs.axisAsText('y', gme.fEyL[ny][d.indx])}/+${funcs.axisAsText('y', gme.fEyH[ny][d.indx])}`);\n         } else if ((this.options.Errors || (this.options.EF > 0)) && (funcs.y_handle.kind == 'normal') && (d.eylow || d.eyhigh))\n            lines.push('error y = -' + funcs.axisAsText('y', d.eylow) + '/+' + funcs.axisAsText('y', d.eyhigh));\n\n      }\n      return lines;\n   }\n\n   /** @summary Provide frame painter for graph\n     * @desc If not exists, emulate its behaviour */\n   get_main() {\n      let pmain = this.getFramePainter();\n\n      if (pmain && pmain.grx && pmain.gry) return pmain;\n\n      // FIXME: check if needed, can be removed easily\n      let pp = this.getPadPainter(),\n          rect = pp?.getPadRect() || { width: 800, height: 600 };\n\n      pmain = {\n          pad_layer: true,\n          pad: pp?.getRootPad(true),\n          pw: rect.width,\n          ph: rect.height,\n          getFrameWidth() { return this.pw; },\n          getFrameHeight() { return this.ph; },\n          grx(value) {\n             if (this.pad.fLogx)\n                value = (value > 0) ? Math.log10(value) : this.pad.fUxmin;\n             else\n                value = (value - this.pad.fX1) / (this.pad.fX2 - this.pad.fX1);\n             return value * this.pw;\n          },\n          gry(value) {\n             if (this.pad.fLogy)\n                value = (value > 0) ? Math.log10(value) : this.pad.fUymin;\n             else\n                value = (value - this.pad.fY1) / (this.pad.fY2 - this.pad.fY1);\n             return (1 - value) * this.ph;\n          },\n          revertAxis(name, v) {\n            if (name == 'x')\n               return v / this.pw * (this.pad.fX2 - this.pad.fX1) + this.pad.fX1;\n            if (name == 'y')\n               return (1 - v / this.ph) * (this.pad.fY2 - this.pad.fY1) + this.pad.fY1;\n            return v;\n          },\n          getGrFuncs() { return this; }\n      }\n\n      return pmain.pad ? pmain : null;\n   }\n\n   /** @summary append exclusion area to created path */\n   appendExclusion(is_curve, path, drawbins, excl_width) {\n      let extrabins = [];\n      for (let n = drawbins.length-1; n >= 0; --n) {\n         let bin = drawbins[n],\n             dlen = Math.sqrt(bin.dgrx**2 + bin.dgry**2);\n         // shift point\n         bin.grx += excl_width*bin.dgry/dlen;\n         bin.gry -= excl_width*bin.dgrx/dlen;\n         extrabins.push(bin);\n      }\n\n      let path2 = buildSvgPath(is_curve ? 'Lbezier' : 'Lline', extrabins);\n\n      this.draw_g.append('svg:path')\n                 .attr('d', path.path + path2.path + 'Z')\n                 .call(this.fillatt.func)\n                 .style('opacity', 0.75);\n   }\n\n   /** @summary draw TGraph bins with specified options\n     * @desc Can be called several times */\n   drawBins(funcs, options, draw_g, w, h, lineatt, fillatt, main_block) {\n      let graph = this.getObject(),\n          excl_width = 0, drawbins = null;\n\n      if (main_block && lineatt.excl_side) {\n         excl_width = lineatt.excl_width;\n         if ((lineatt.width > 0) && !options.Line && !options.Curve) options.Line = 1;\n      }\n\n      if (options.EF) {\n         drawbins = this.optimizeBins((options.EF > 1) ? 20000 : 0);\n\n         // build lower part\n         for (let n = 0; n < drawbins.length; ++n) {\n            let bin = drawbins[n];\n            bin.grx = funcs.grx(bin.x);\n            bin.gry = funcs.gry(bin.y - bin.eylow);\n         }\n\n         let path1 = buildSvgPath((options.EF > 1) ? 'bezier' : 'line', drawbins),\n             bins2 = [];\n\n         for (let n = drawbins.length-1; n >= 0; --n) {\n            let bin = drawbins[n];\n            bin.gry = funcs.gry(bin.y + bin.eyhigh);\n            bins2.push(bin);\n         }\n\n         // build upper part (in reverse direction)\n         let path2 = buildSvgPath((options.EF > 1) ? 'Lbezier' : 'Lline', bins2);\n\n         draw_g.append('svg:path')\n               .attr('d', path1.path + path2.path + 'Z')\n               .call(fillatt.func);\n         if (main_block)\n            this.draw_kind = 'lines';\n      }\n\n      if (options.Line || options.Fill) {\n\n         let close_symbol = '';\n         if (graph._typename == clTCutG) options.Fill = 1;\n\n         if (options.Fill) {\n            close_symbol = 'Z'; // always close area if we want to fill it\n            excl_width = 0;\n         }\n\n         if (!drawbins) drawbins = this.optimizeBins(0);\n\n         for (let n = 0; n < drawbins.length; ++n) {\n            let bin = drawbins[n];\n            bin.grx = funcs.grx(bin.x);\n            bin.gry = funcs.gry(bin.y);\n         }\n\n         let kind = 'line'; // simple line\n         if (excl_width) kind += 'calc'; // we need to calculated deltas to build exclusion points\n\n         let path = buildSvgPath(kind, drawbins);\n\n         if (excl_width)\n             this.appendExclusion(false, path, drawbins, excl_width);\n\n         let elem = draw_g.append('svg:path').attr('d', path.path + close_symbol);\n         if (options.Line)\n            elem.call(lineatt.func);\n\n         if (options.Fill)\n            elem.call(fillatt.func);\n         else\n            elem.style('fill', 'none');\n\n         if (main_block)\n            this.draw_kind = 'lines';\n      }\n\n      if (options.Curve) {\n         let curvebins = drawbins;\n         if ((this.draw_kind != 'lines') || !curvebins || ((options.Curve == 1) && (curvebins.length > 20000))) {\n            curvebins = this.optimizeBins((options.Curve == 1) ? 20000 : 0);\n            for (let n = 0; n < curvebins.length; ++n) {\n               let bin = curvebins[n];\n               bin.grx = funcs.grx(bin.x);\n               bin.gry = funcs.gry(bin.y);\n            }\n         }\n\n         let kind = 'bezier';\n         if (excl_width) kind += 'calc'; // we need to calculated deltas to build exclusion points\n\n         let path = buildSvgPath(kind, curvebins);\n\n         if (excl_width)\n             this.appendExclusion(true, path, curvebins, excl_width);\n\n         draw_g.append('svg:path')\n               .attr('d', path.path)\n               .call(lineatt.func)\n               .style('fill', 'none');\n         if (main_block)\n            this.draw_kind = 'lines'; // handled same way as lines\n      }\n\n      let nodes = null;\n\n      if (options.Errors || options.Rect || options.Bar) {\n\n         drawbins = this.optimizeBins(5000, (pnt,i) => {\n\n            let grx = funcs.grx(pnt.x);\n\n            // when drawing bars, take all points\n            if (!options.Bar && ((grx < 0) || (grx > w))) return true;\n\n            let gry = funcs.gry(pnt.y);\n\n            if (!options.Bar && !options.OutRange && ((gry < 0) || (gry > h))) return true;\n\n            pnt.grx1 = Math.round(grx);\n            pnt.gry1 = Math.round(gry);\n\n            if (this.has_errors) {\n               pnt.grx0 = Math.round(funcs.grx(pnt.x - options.ScaleErrX*pnt.exlow) - grx);\n               pnt.grx2 = Math.round(funcs.grx(pnt.x + options.ScaleErrX*pnt.exhigh) - grx);\n               pnt.gry0 = Math.round(funcs.gry(pnt.y - pnt.eylow) - gry);\n               pnt.gry2 = Math.round(funcs.gry(pnt.y + pnt.eyhigh) - gry);\n\n               if (this.is_bent) {\n                  pnt.grdx0 = Math.round(funcs.gry(pnt.y + graph.fEXlowd[i]) - gry);\n                  pnt.grdx2 = Math.round(funcs.gry(pnt.y + graph.fEXhighd[i]) - gry);\n                  pnt.grdy0 = Math.round(funcs.grx(pnt.x + graph.fEYlowd[i]) - grx);\n                  pnt.grdy2 = Math.round(funcs.grx(pnt.x + graph.fEYhighd[i]) - grx);\n               } else {\n                  pnt.grdx0 = pnt.grdx2 = pnt.grdy0 = pnt.grdy2 = 0;\n               }\n            }\n\n            return false;\n         });\n\n         if (main_block)\n            this.draw_kind = 'nodes';\n\n         nodes = draw_g.selectAll('.grpoint')\n                       .data(drawbins)\n                       .enter()\n                       .append('svg:g')\n                       .attr('class', 'grpoint')\n                       .attr('transform', d => `translate(${d.grx1},${d.gry1})`);\n      }\n\n      if (options.Bar) {\n         // calculate bar width\n         for (let i = 1; i < drawbins.length-1; ++i)\n            drawbins[i].width = Math.max(2, (drawbins[i+1].grx1 - drawbins[i-1].grx1) / 2 - 2);\n\n         // first and last bins\n         switch (drawbins.length) {\n            case 0: break;\n            case 1: drawbins[0].width = w/4; break; // pathologic case of single bin\n            case 2: drawbins[0].width = drawbins[1].width = (drawbins[1].grx1-drawbins[0].grx1)/2; break;\n            default:\n               drawbins[0].width = drawbins[1].width;\n               drawbins[drawbins.length-1].width = drawbins[drawbins.length-2].width;\n         }\n\n         let yy0 = Math.round(funcs.gry(0)), usefill = fillatt;\n\n         if (main_block) {\n            let fp = this.getFramePainter(),\n                fpcol = fp?.fillatt && !fp?.fillatt.empty() ? fp.fillatt.getFillColor() : -1;\n            if (fpcol === fillatt.getFillColor())\n               usefill = new TAttFillHandler({ color: fpcol == 'white' ? 1 : 0, pattern: 1001 });\n         }\n\n         nodes.append('svg:path')\n              .attr('d', d => {\n                 d.bar = true; // element drawn as bar\n                 let dx = Math.round(-d.width/2),\n                     dw = Math.round(d.width),\n                     dy = (options.Bar !== 1) ? 0 : ((d.gry1 > yy0) ? yy0-d.gry1 : 0),\n                     dh = (options.Bar !== 1) ? (h > d.gry1 ? h - d.gry1 : 0) : Math.abs(yy0 - d.gry1);\n                 return `M${dx},${dy}h${dw}v${dh}h${-dw}z`;\n              })\n            .call(usefill.func);\n      }\n\n      if (options.Rect) {\n         nodes.filter(d => (d.exlow > 0) && (d.exhigh > 0) && (d.eylow > 0) && (d.eyhigh > 0))\n           .append('svg:path')\n           .attr('d', d => {\n               d.rect = true;\n               return `M${d.grx0},${d.gry0}H${d.grx2}V${d.gry2}H${d.grx0}Z`;\n            })\n           .call(fillatt.func)\n           .call(options.Rect === 2 ? lineatt.func : () => {});\n      }\n\n      this.error_size = 0;\n\n      if (options.Errors) {\n         // to show end of error markers, use line width attribute\n         let lw = lineatt.width + gStyle.fEndErrorSize, bb = 0,\n             vv = options.Ends ? `m0,${lw}v${-2*lw}` : '',\n             hh = options.Ends ? `m${lw},0h${-2*lw}` : '',\n             vleft = vv, vright = vv, htop = hh, hbottom = hh;\n\n         const mainLine = (dx,dy) => {\n            if (!options.MainError) return `M${dx},${dy}`;\n            let res = 'M0,0';\n            if (dx) return res + (dy ? `L${dx},${dy}` : `H${dx}`);\n            return dy ? res + `V${dy}` : res;\n         };\n\n         switch (options.Ends) {\n            case 2:  // option []\n               bb = Math.max(lineatt.width+1, Math.round(lw*0.66));\n               vleft = `m${bb},${lw}h${-bb}v${-2*lw}h${bb}`;\n               vright = `m${-bb},${lw}h${bb}v${-2*lw}h${-bb}`;\n               htop = `m${-lw},${bb}v${-bb}h${2*lw}v${bb}`;\n               hbottom = `m${-lw},${-bb}v${bb}h${2*lw}v${-bb}`;\n               break;\n            case 3: // option |>\n               lw = Math.max(lw, Math.round(graph.fMarkerSize*8*0.66));\n               bb = Math.max(lineatt.width+1, Math.round(lw*0.66));\n               vleft = `l${bb},${lw}v${-2*lw}l${-bb},${lw}`;\n               vright = `l${-bb},${lw}v${-2*lw}l${bb},${lw}`;\n               htop = `l${-lw},${bb}h${2*lw}l${-lw},${-bb}`;\n               hbottom = `l${-lw},${-bb}h${2*lw}l${-lw},${bb}`;\n               break;\n            case 4: // option >\n               lw = Math.max(lw, Math.round(graph.fMarkerSize*8*0.66));\n               bb = Math.max(lineatt.width+1, Math.round(lw*0.66));\n               vleft = `l${bb},${lw}m0,${-2*lw}l${-bb},${lw}`;\n               vright = `l${-bb},${lw}m0,${-2*lw}l${bb},${lw}`;\n               htop = `l${-lw},${bb}m${2*lw},0l${-lw},${-bb}`;\n               hbottom = `l${-lw},${-bb}m${2*lw},0l${-lw},${bb}`;\n               break;\n         }\n\n         this.error_size = lw;\n\n         lw = Math.floor((lineatt.width-1)/2); // one should take into account half of end-cup line width\n\n         let visible = nodes.filter(d => (d.exlow > 0) || (d.exhigh > 0) || (d.eylow > 0) || (d.eyhigh > 0));\n         if (options.skip_errors_x0 || options.skip_errors_y0)\n            visible = visible.filter(d => ((d.x != 0) || !options.skip_errors_x0) && ((d.y != 0) || !options.skip_errors_y0));\n\n         if (!isBatchMode() && settings.Tooltip && main_block)\n            visible.append('svg:path')\n                   .style('fill', 'none')\n                   .style('pointer-events', 'visibleFill')\n                   .attr('d', d => `M${d.grx0},${d.gry0}h${d.grx2-d.grx0}v${d.gry2-d.gry0}h${d.grx0-d.grx2}z`);\n\n         visible.append('svg:path')\n             .call(lineatt.func)\n             .style('fill', 'none')\n             .attr('d', d => {\n                d.error = true;\n                return ((d.exlow > 0)  ? mainLine(d.grx0+lw, d.grdx0) + vleft : '') +\n                       ((d.exhigh > 0) ? mainLine(d.grx2-lw, d.grdx2) + vright : '') +\n                       ((d.eylow > 0)  ? mainLine(d.grdy0, d.gry0-lw) + hbottom : '') +\n                       ((d.eyhigh > 0) ? mainLine(d.grdy2, d.gry2+lw) + htop : '');\n              });\n      }\n\n      if (options.Mark) {\n         // for tooltips use markers only if nodes were not created\n         this.createAttMarker({ attr: graph, style: options.Mark - 100 });\n\n         this.marker_size = this.markeratt.getFullSize();\n\n         this.markeratt.resetPos();\n\n         let path = '', pnt, grx, gry,\n             want_tooltip = !isBatchMode() && settings.Tooltip && (!this.markeratt.fill || (this.marker_size < 7)) && !nodes && main_block,\n             hints_marker = '', hsz = Math.max(5, Math.round(this.marker_size*0.7)),\n             maxnummarker = 1000000 / (this.markeratt.getMarkerLength() + 7), step = 1; // let produce SVG at maximum 1MB\n\n         if (!drawbins)\n            drawbins = this.optimizeBins(maxnummarker);\n         else if (this.canOptimize() && (drawbins.length > 1.5*maxnummarker))\n            step = Math.min(2, Math.round(drawbins.length/maxnummarker));\n\n         for (let n = 0; n < drawbins.length; n += step) {\n            pnt = drawbins[n];\n            grx = funcs.grx(pnt.x);\n            if ((grx > -this.marker_size) && (grx < w + this.marker_size)) {\n               gry = funcs.gry(pnt.y);\n               if ((gry > -this.marker_size) && (gry < h + this.marker_size)) {\n                  path += this.markeratt.create(grx, gry);\n                  if (want_tooltip) hints_marker += `M${grx-hsz},${gry-hsz}h${2*hsz}v${2*hsz}h${-2*hsz}z`;\n               }\n            }\n         }\n\n         if (path) {\n            draw_g.append('svg:path')\n                  .attr('d', path)\n                  .call(this.markeratt.func);\n            if ((nodes === null) && (this.draw_kind == 'none') && main_block)\n               this.draw_kind = (options.Mark == 101) ? 'path' : 'mark';\n         }\n         if (want_tooltip && hints_marker)\n            draw_g.append('svg:path')\n                  .attr('d', hints_marker)\n                  .style('fill', 'none')\n                  .style('pointer-events', 'visibleFill');\n      }\n   }\n\n   /** @summary append TGraphQQ part */\n   appendQQ(funcs, graph) {\n      let xqmin = Math.max(funcs.scale_xmin, graph.fXq1),\n          xqmax = Math.min(funcs.scale_xmax, graph.fXq2),\n          yqmin = Math.max(funcs.scale_ymin, graph.fYq1),\n          yqmax = Math.min(funcs.scale_ymax, graph.fYq2),\n          path2 = '',\n          makeLine = (x1,y1,x2,y2) => `M${funcs.grx(x1)},${funcs.gry(y1)}L${funcs.grx(x2)},${funcs.gry(y2)}`,\n          yxmin = (graph.fYq2 - graph.fYq1)*(funcs.scale_xmin-graph.fXq1)/(graph.fXq2-graph.fXq1) + graph.fYq1,\n          yxmax = (graph.fYq2-graph.fYq1)*(funcs.scale_xmax-graph.fXq1)/(graph.fXq2-graph.fXq1) + graph.fYq1;\n\n      if (yxmin < funcs.scale_ymin) {\n         let xymin = (graph.fXq2 - graph.fXq1)*(funcs.scale_ymin-graph.fYq1)/(graph.fYq2-graph.fYq1) + graph.fXq1;\n         path2 = makeLine(xymin, funcs.scale_ymin, xqmin, yqmin);\n      } else {\n         path2 = makeLine(funcs.scale_xmin, yxmin, xqmin, yqmin);\n      }\n\n      if (yxmax > funcs.scale_ymax) {\n         let xymax = (graph.fXq2-graph.fXq1)*(funcs.scale_ymax-graph.fYq1)/(graph.fYq2-graph.fYq1) + graph.fXq1;\n         path2 += makeLine(xqmax, yqmax, xymax, funcs.scale_ymax);\n      } else {\n         path2 += makeLine(xqmax, yqmax, funcs.scale_xmax, yxmax);\n      }\n\n      let latt1 = new TAttLineHandler({ style: 1, width: 1, color: 'black' }),\n          latt2 = new TAttLineHandler({ style: 2, width: 1, color: 'black' });\n\n      this.draw_g.append('path')\n                 .attr('d', makeLine(xqmin,yqmin,xqmax,yqmax))\n                 .call(latt1.func)\n                 .style('fill', 'none');\n\n      this.draw_g.append('path')\n                 .attr('d', path2)\n                 .call(latt2.func)\n                 .style('fill', 'none');\n   }\n\n   drawBins3D(/*fp, graph*/) {\n      console.log('Load ./hist/TGraphPainter.mjs to draw graph in 3D');\n   }\n\n   /** @summary draw TGraph */\n   drawGraph() {\n\n      let pmain = this.get_main(),\n          graph = this.getObject();\n      if (!pmain) return;\n\n      // special mode for TMultiGraph 3d drawing\n      if (this.options.pos3d)\n         return this.drawBins3D(pmain, graph);\n\n      let is_gme = !!this.get_gme(),\n          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),\n          w = pmain.getFrameWidth(),\n          h = pmain.getFrameHeight();\n\n      this.createG(!pmain.pad_layer);\n\n      if (this.options._pfc || this.options._plc || this.options._pmc) {\n         let mp = this.getMainPainter();\n         if (isFunc(mp?.createAutoColor)) {\n            let icolor = mp.createAutoColor();\n            if (this.options._pfc) { graph.fFillColor = icolor; delete this.fillatt; }\n            if (this.options._plc) { graph.fLineColor = icolor; delete this.lineatt; }\n            if (this.options._pmc) { graph.fMarkerColor = icolor; delete this.markeratt; }\n            this.options._pfc = this.options._plc = this.options._pmc = false;\n         }\n      }\n\n      this.createAttLine({ attr: graph, can_excl: true });\n      this.createAttFill({ attr: graph });\n\n      this.fillatt.used = false; // mark used only when really used\n\n      this.draw_kind = 'none'; // indicate if special svg:g were created for each bin\n      this.marker_size = 0; // indicate if markers are drawn\n      let draw_g = is_gme ? this.draw_g.append('svg:g') : this.draw_g;\n\n      this.drawBins(funcs, this.options, draw_g, w, h, this.lineatt, this.fillatt, true);\n\n      if (graph._typename == 'TGraphQQ')\n         this.appendQQ(funcs, graph);\n\n      if (is_gme) {\n         for (let k = 0; k < graph.fNYErrors; ++k) {\n            let lineatt = this.lineatt, fillatt = this.fillatt;\n            if (this.options.individual_styles) {\n               lineatt = new TAttLineHandler({ attr: graph.fAttLine[k], std: false });\n               fillatt = new TAttFillHandler({ attr: graph.fAttFill[k], std: false, svg: this.getCanvSvg() });\n            }\n            let sub_g = this.draw_g.append('svg:g'),\n                options = k < this.options.blocks.length ? this.options.blocks[k] : this.options;\n            this.extractGmeErrors(k);\n            this.drawBins(funcs, options, sub_g, w, h, lineatt, fillatt);\n         }\n         this.extractGmeErrors(0); // ensure that first block kept at the end\n      }\n\n      if (!isBatchMode())\n         addMoveHandler(this, this.testEditable());\n   }\n\n   /** @summary Provide tooltip at specified point */\n   extractTooltip(pnt) {\n      if (!pnt) return null;\n\n      if ((this.draw_kind == 'lines') || (this.draw_kind == 'path') || (this.draw_kind == 'mark'))\n         return this.extractTooltipForPath(pnt);\n\n      if (this.draw_kind != 'nodes') return null;\n\n      let pmain = this.get_main(),\n          height = pmain.getFrameHeight(),\n          esz = this.error_size,\n          isbar1 = (this.options.Bar === 1),\n          funcs = isbar1 ? pmain.getGrFuncs(this.options.second_x, this.options.second_y) : null,\n          findbin = null, best_dist2 = 1e10, best = null,\n          msize = this.marker_size ? Math.round(this.marker_size/2 + 1.5) : 0;\n\n      this.draw_g.selectAll('.grpoint').each(function() {\n         let d = d3_select(this).datum();\n         if (d === undefined) return;\n         let dist2 = (pnt.x - d.grx1) ** 2;\n         if (pnt.nproc === 1) dist2 += (pnt.y - d.gry1) ** 2;\n         if (dist2 >= best_dist2) return;\n\n         let rect;\n\n         if (d.error || d.rect || d.marker) {\n            rect = { x1: Math.min(-esz, d.grx0, -msize),\n                     x2: Math.max(esz, d.grx2, msize),\n                     y1: Math.min(-esz, d.gry2, -msize),\n                     y2: Math.max(esz, d.gry0, msize) };\n         } else if (d.bar) {\n             rect = { x1: -d.width/2, x2: d.width/2, y1: 0, y2: height - d.gry1 };\n\n             if (isbar1) {\n                let yy0 = funcs.gry(0);\n                rect.y1 = (d.gry1 > yy0) ? yy0-d.gry1 : 0;\n                rect.y2 = (d.gry1 > yy0) ? 0 : yy0-d.gry1;\n             }\n          } else {\n             rect = { x1: -5, x2: 5, y1: -5, y2: 5 };\n          }\n          let matchx = (pnt.x >= d.grx1 + rect.x1) && (pnt.x <= d.grx1 + rect.x2),\n              matchy = (pnt.y >= d.gry1 + rect.y1) && (pnt.y <= d.gry1 + rect.y2);\n\n          if (matchx && (matchy || (pnt.nproc > 1))) {\n             best_dist2 = dist2;\n             findbin = this;\n             best = rect;\n             best.exact = /* matchx && */ matchy;\n          }\n       });\n\n      if (findbin === null) return null;\n\n      let d = d3_select(findbin).datum(),\n          gr = this.getObject(),\n          res = { name: gr.fName, title: gr.fTitle,\n                  x: d.grx1, y: d.gry1,\n                  color1: this.lineatt.color,\n                  lines: this.getTooltips(d),\n                  rect: best, d3bin: findbin };\n\n       res.user_info = { obj: gr, name: gr.fName, bin: d.indx, cont: d.y, grx: d.grx1, gry: d.gry1 };\n\n      if (this.fillatt && this.fillatt.used && !this.fillatt.empty())\n         res.color2 = this.fillatt.getFillColor();\n\n      if (best.exact) res.exact = true;\n      res.menu = res.exact; // activate menu only when exactly locate bin\n      res.menu_dist = 3; // distance always fixed\n      res.bin = d;\n      res.binindx = d.indx;\n\n      return res;\n   }\n\n   /** @summary Show tooltip */\n   showTooltip(hint) {\n\n      if (!hint) {\n         if (this.draw_g) this.draw_g.select('.tooltip_bin').remove();\n         return;\n      }\n\n      if (hint.usepath) return this.showTooltipForPath(hint);\n\n      let d = d3_select(hint.d3bin).datum(),\n          ttrect = this.draw_g.select('.tooltip_bin');\n\n      if (ttrect.empty())\n         ttrect = this.draw_g.append('svg:rect')\n                             .attr('class', 'tooltip_bin h1bin')\n                             .style('pointer-events', 'none');\n\n      hint.changed = ttrect.property('current_bin') !== hint.d3bin;\n\n      if (hint.changed)\n         ttrect.attr('x', d.grx1 + hint.rect.x1)\n               .attr('width', hint.rect.x2 - hint.rect.x1)\n               .attr('y', d.gry1 + hint.rect.y1)\n               .attr('height', hint.rect.y2 - hint.rect.y1)\n               .style('opacity', '0.3')\n               .property('current_bin', hint.d3bin);\n   }\n\n   /** @summary Process tooltip event */\n   processTooltipEvent(pnt) {\n      let hint = this.extractTooltip(pnt);\n      if (!pnt || !pnt.disabled) this.showTooltip(hint);\n      return hint;\n   }\n\n   /** @summary Find best bin index for specified point */\n   findBestBin(pnt) {\n      if (!this.bins) return null;\n\n      let islines = (this.draw_kind == 'lines'),\n          bestindx = -1,\n          bestbin = null,\n          bestdist = 1e10,\n          funcs = this.get_main().getGrFuncs(this.options.second_x, this.options.second_y),\n          dist, grx, gry, n, bin;\n\n      for (n = 0; n < this.bins.length; ++n) {\n         bin = this.bins[n];\n\n         grx = funcs.grx(bin.x);\n         gry = funcs.gry(bin.y);\n\n         dist = (pnt.x-grx)**2 + (pnt.y-gry)**2;\n\n         if (dist < bestdist) {\n            bestdist = dist;\n            bestbin = bin;\n            bestindx = n;\n         }\n      }\n\n      // check last point\n      if ((bestdist > 100) && islines) bestbin = null;\n\n      let radius = Math.max(this.lineatt.width + 3, 4);\n\n      if (this.marker_size > 0) radius = Math.max(this.marker_size, radius);\n\n      if (bestbin)\n         bestdist = Math.sqrt((pnt.x-funcs.grx(bestbin.x))**2 + (pnt.y-funcs.gry(bestbin.y))**2);\n\n      if (!islines && (bestdist > radius)) bestbin = null;\n\n      if (!bestbin) bestindx = -1;\n\n      let res = { bin: bestbin, indx: bestindx, dist: bestdist, radius: Math.round(radius) };\n\n      if (!bestbin && islines) {\n\n         bestdist = 1e10;\n\n         const IsInside = (x, x1, x2) => ((x1 >= x) && (x >= x2)) || ((x1 <= x) && (x <= x2));\n\n         let bin0 = this.bins[0], grx0 = funcs.grx(bin0.x), gry0, posy = 0;\n         for (n = 1; n < this.bins.length; ++n) {\n            bin = this.bins[n];\n            grx = funcs.grx(bin.x);\n\n            if (IsInside(pnt.x, grx0, grx)) {\n               // if inside interval, check Y distance\n               gry0 = funcs.gry(bin0.y);\n               gry = funcs.gry(bin.y);\n\n               if (Math.abs(grx - grx0) < 1) {\n                  // very close x - check only y\n                  posy = pnt.y;\n                  dist = IsInside(pnt.y, gry0, gry) ? 0 : Math.min(Math.abs(pnt.y-gry0), Math.abs(pnt.y-gry));\n               } else {\n                  posy = gry0 + (pnt.x - grx0) / (grx - grx0) * (gry - gry0);\n                  dist = Math.abs(posy - pnt.y);\n               }\n\n               if (dist < bestdist) {\n                  bestdist = dist;\n                  res.linex = pnt.x;\n                  res.liney = posy;\n               }\n            }\n\n            bin0 = bin;\n            grx0 = grx;\n         }\n\n         if (bestdist < radius*0.5) {\n            res.linedist = bestdist;\n            res.closeline = true;\n         }\n      }\n\n      return res;\n   }\n\n   /** @summary Check editable flag for TGraph\n     * @desc if arg specified changes or toggles editable flag */\n   testEditable(arg) {\n      let obj = this.getObject();\n      if (!obj) return false;\n      if ((arg == 'toggle') || ((arg !== undefined) && (!arg != obj.TestBit(kNotEditable))))\n         obj.InvertBit(kNotEditable);\n      return !obj.TestBit(kNotEditable);\n   }\n\n   /** @summary Provide tooltip at specified point for path-based drawing */\n   extractTooltipForPath(pnt) {\n\n      if (this.bins === null) return null;\n\n      let best = this.findBestBin(pnt);\n\n      if (!best || (!best.bin && !best.closeline)) return null;\n\n      let islines = (this.draw_kind == 'lines'),\n          ismark = (this.draw_kind == 'mark'),\n          pmain = this.get_main(),\n          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),\n          gr = this.getObject(),\n          res = { name: gr.fName, title: gr.fTitle,\n                  x: best.bin ? funcs.grx(best.bin.x) : best.linex,\n                  y: best.bin ? funcs.gry(best.bin.y) : best.liney,\n                  color1: this.lineatt.color,\n                  lines: this.getTooltips(best.bin),\n                  usepath: true };\n\n      res.user_info = { obj: gr, name: gr.fName, bin: 0, cont: 0, grx: res.x, gry: res.y };\n\n      res.ismark = ismark;\n      res.islines = islines;\n\n      if (best.closeline) {\n         res.menu = res.exact = true;\n         res.menu_dist = best.linedist;\n      } else if (best.bin) {\n         if (this.options.EF && islines) {\n            res.gry1 = funcs.gry(best.bin.y - best.bin.eylow);\n            res.gry2 = funcs.gry(best.bin.y + best.bin.eyhigh);\n         } else {\n            res.gry1 = res.gry2 = funcs.gry(best.bin.y);\n         }\n\n         res.binindx = best.indx;\n         res.bin = best.bin;\n         res.radius = best.radius;\n         res.user_info.bin = best.indx;\n         res.user_info.cont = best.bin.y;\n\n         res.exact = (Math.abs(pnt.x - res.x) <= best.radius) &&\n            ((Math.abs(pnt.y - res.gry1) <= best.radius) || (Math.abs(pnt.y - res.gry2) <= best.radius));\n\n         res.menu = res.exact;\n         res.menu_dist = Math.sqrt((pnt.x-res.x)**2 + Math.min(Math.abs(pnt.y-res.gry1), Math.abs(pnt.y-res.gry2))**2);\n      }\n\n      if (this.fillatt && this.fillatt.used && !this.fillatt.empty())\n         res.color2 = this.fillatt.getFillColor();\n\n      if (!islines) {\n         res.color1 = this.getColor(gr.fMarkerColor);\n         if (!res.color2) res.color2 = res.color1;\n      }\n\n      return res;\n   }\n\n   /** @summary Show tooltip for path drawing */\n   showTooltipForPath(hint) {\n\n      let ttbin = this.draw_g.select('.tooltip_bin');\n\n      if (!hint || !hint.bin) {\n         ttbin.remove();\n         return;\n      }\n\n      if (ttbin.empty())\n         ttbin = this.draw_g.append('svg:g').attr('class', 'tooltip_bin');\n\n      hint.changed = ttbin.property('current_bin') !== hint.bin;\n\n      if (hint.changed) {\n         ttbin.selectAll('*').remove(); // first delete all children\n         ttbin.property('current_bin', hint.bin);\n\n         if (hint.ismark) {\n            ttbin.append('svg:rect')\n                 .attr('class','h1bin')\n                 .style('pointer-events','none')\n                 .style('opacity', '0.3')\n                 .attr('x', Math.round(hint.x - hint.radius))\n                 .attr('y', Math.round(hint.y - hint.radius))\n                 .attr('width', 2*hint.radius)\n                 .attr('height', 2*hint.radius);\n         } else {\n            ttbin.append('svg:circle').attr('cy', Math.round(hint.gry1));\n            if (Math.abs(hint.gry1-hint.gry2) > 1)\n               ttbin.append('svg:circle').attr('cy', Math.round(hint.gry2));\n\n            let elem = ttbin.selectAll('circle')\n                            .attr('r', hint.radius)\n                            .attr('cx', Math.round(hint.x));\n\n            if (!hint.islines) {\n               elem.style('stroke', hint.color1 == 'black' ? 'green' : 'black').style('fill','none');\n            } else {\n               if (this.options.Line || this.options.Curve)\n                  elem.call(this.lineatt.func);\n               else\n                  elem.style('stroke','black');\n               if (this.options.Fill)\n                  elem.call(this.fillatt.func);\n               else\n                  elem.style('fill','none');\n            }\n         }\n      }\n   }\n\n   /** @summary Check if graph moving is enabled */\n   moveEnabled() {\n      return this.testEditable();\n   }\n\n   /** @summary Start moving of TGraph */\n   moveStart(x,y) {\n      this.pos_dx = this.pos_dy = 0;\n      this.move_funcs = this.get_main().getGrFuncs(this.options.second_x, this.options.second_y);\n      let hint = this.extractTooltip({x, y});\n      if (hint && hint.exact && (hint.binindx !== undefined)) {\n         this.move_binindx = hint.binindx;\n         this.move_bin = hint.bin;\n         this.move_x0 = this.move_funcs.grx(this.move_bin.x);\n         this.move_y0 = this.move_funcs.gry(this.move_bin.y);\n      } else {\n         delete this.move_binindx;\n      }\n   }\n\n   /** @summary Perform moving */\n   moveDrag(dx,dy) {\n      this.pos_dx += dx;\n      this.pos_dy += dy;\n\n      if (this.move_binindx === undefined) {\n         this.draw_g.attr('transform', `translate(${this.pos_dx},${this.pos_dy})`);\n      } else if (this.move_funcs && this.move_bin) {\n         this.move_bin.x = this.move_funcs.revertAxis('x', this.move_x0 + this.pos_dx);\n         this.move_bin.y = this.move_funcs.revertAxis('y', this.move_y0 + this.pos_dy);\n         this.drawGraph();\n      }\n   }\n\n   /** @summary Complete moving */\n   moveEnd(not_changed) {\n      let exec = '';\n\n      if (this.move_binindx === undefined) {\n         this.draw_g.attr('transform', null);\n\n         if (this.move_funcs && this.bins && !not_changed) {\n            for (let k = 0; k < this.bins.length; ++k) {\n               let bin = this.bins[k];\n               bin.x = this.move_funcs.revertAxis('x', this.move_funcs.grx(bin.x) + this.pos_dx);\n               bin.y = this.move_funcs.revertAxis('y', this.move_funcs.gry(bin.y) + this.pos_dy);\n               exec += `SetPoint(${bin.indx},${bin.x},${bin.y});;`;\n               if ((bin.indx == 0) && this.matchObjectType(clTCutG))\n                  exec += `SetPoint(${this.getObject().fNpoints-1},${bin.x},${bin.y});;`;\n            }\n            this.drawGraph();\n         }\n      } else {\n         exec = `SetPoint(${this.move_bin.indx},${this.move_bin.x},${this.move_bin.y});;`;\n         if ((this.move_bin.indx == 0) && this.matchObjectType(clTCutG))\n            exec += `SetPoint(${this.getObject().fNpoints-1},${this.move_bin.x},${this.move_bin.y});;`;\n         delete this.move_binindx;\n      }\n\n      delete this.move_funcs;\n\n      if (exec && !not_changed)\n         this.submitCanvExec(exec);\n   }\n\n   /** @summary Fill context menu */\n   fillContextMenu(menu) {\n      super.fillContextMenu(menu);\n\n      if (!this.snapid)\n         menu.addchk(this.testEditable(), 'Editable', () => { this.testEditable('toggle'); this.drawGraph(); });\n\n      return menu.size() > 0;\n   }\n\n   /** @summary Execute menu command\n     * @private */\n   executeMenuCommand(method, args) {\n      if (super.executeMenuCommand(method,args)) return true;\n\n      let canp = this.getCanvPainter(), pmain = this.get_main();\n\n      if ((method.fName == 'RemovePoint') || (method.fName == 'InsertPoint')) {\n         if (!canp || canp._readonly) return true; // ignore function\n\n         let hint = this.extractTooltip(pnt);\n\n         if (method.fName == 'InsertPoint') {\n            let pnt = isFunc(pmain.getLastEventPos) ? pmain.getLastEventPos() : null;\n            if (pnt) {\n               let funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),\n                   userx = funcs.revertAxis('x', pnt.x) ?? 0,\n                   usery = funcs.revertAxis('y', pnt.y) ?? 0;\n               this.submitCanvExec(`AddPoint(${userx.toFixed(3)}, ${usery.toFixed(3)})`, this.args_menu_id);\n            }\n         } else if (this.args_menu_id && (hint?.binindx !== undefined)) {\n            this.submitCanvExec(`RemovePoint(${hint.binindx})`, this.args_menu_id);\n         }\n\n         return true; // call is processed\n      }\n\n      return false;\n   }\n\n   /** @summary Update TGraph object */\n   updateObject(obj, opt) {\n      if (!this.matchObjectType(obj)) return false;\n\n      if (opt && (opt != this.options.original))\n         this.decodeOptions(opt);\n\n      let graph = this.getObject();\n      // TODO: make real update of TGraph object content\n      graph.fBits = obj.fBits;\n      graph.fTitle = obj.fTitle;\n      graph.fX = obj.fX;\n      graph.fY = obj.fY;\n      graph.fNpoints = obj.fNpoints;\n      graph.fMinimum = obj.fMinimum;\n      graph.fMaximum = obj.fMaximum;\n      this.createBins();\n\n      delete this.$redraw_hist;\n\n      // if our own histogram was used as axis drawing, we need update histogram as well\n      if (this.axes_draw) {\n         let histo = this.createHistogram();\n         histo.fTitle = graph.fTitle; // copy title\n\n         let hist_painter = this.getMainPainter();\n         if (hist_painter?.$secondary) {\n            hist_painter.updateObject(histo, this.options.Axis);\n            this.$redraw_hist = true;\n         }\n      }\n\n      return true;\n   }\n\n   /** @summary Checks if it makes sense to zoom inside specified axis range\n     * @desc allow to zoom TGraph only when at least one point in the range */\n   canZoomInside(axis,min,max) {\n      let gr = this.getObject();\n      if (!gr || (axis !== (this.options.pos3d ? 'y' : 'x'))) return false;\n\n      for (let n = 0; n < gr.fNpoints; ++n)\n         if ((min < gr.fX[n]) && (gr.fX[n] < max)) return true;\n\n      return false;\n   }\n\n   /** @summary Process click on graph-defined buttons */\n   clickButton(funcname) {\n      if (funcname !== 'ToggleZoom') return false;\n\n      let main = this.getFramePainter();\n      if (!main) return false;\n\n      if ((this.xmin === this.xmax) && (this.ymin === this.ymax)) return false;\n\n      main.zoom(this.xmin, this.xmax, this.ymin, this.ymax);\n\n      return true;\n   }\n\n   /** @summary Find TF1/TF2 in TGraph list of functions */\n   findFunc() {\n      let gr = this.getObject();\n      if (gr?.fFunctions?.arr)\n         return gr?.fFunctions?.arr.find(func => (func._typename == clTF1) || (func._typename == clTF2));\n      return null;\n   }\n\n   /** @summary Find stat box in TGraph list of functions */\n   findStat() {\n      let gr = this.getObject();\n      if (gr?.fFunctions?.arr)\n         for (let i = 0; i < gr.fFunctions.arr.length; ++i) {\n            let func = gr.fFunctions.arr[i];\n            if ((func._typename == clTPaveStats) && (func.fName == 'stats')) return func;\n         }\n      return null;\n   }\n\n   /** @summary Create stat box */\n   createStat() {\n      let func = this.findFunc();\n      if (!func) return null;\n\n      let stats = this.findStat();\n      if (stats) return stats;\n\n      // do not create stats box when drawing canvas\n      if (this.getCanvPainter()?.normal_canvas || this.options.PadStats) return null;\n\n      this.create_stats = true;\n\n      const st = gStyle;\n\n      stats = create(clTPaveStats);\n      Object.assign(stats, { fName : 'stats', fOptStat: 0, fOptFit: st.fOptFit || 111, fBorderSize: 1 });\n\n      stats.fX1NDC = st.fStatX - st.fStatW;\n      stats.fY1NDC = st.fStatY - st.fStatH;\n      stats.fX2NDC = st.fStatX;\n      stats.fY2NDC = st.fStatY;\n\n      stats.fFillColor = st.fStatColor;\n      stats.fFillStyle = st.fStatStyle;\n\n      stats.fTextAngle = 0;\n      stats.fTextSize = st.fStatFontSize; // 9 ??\n      stats.fTextAlign = 12;\n      stats.fTextColor = st.fStatTextColor;\n      stats.fTextFont = st.fStatFont;\n\n      stats.AddText(func.fName);\n\n      // while TF1 was found, one can be sure that stats is existing\n      this.getObject().fFunctions.Add(stats);\n\n      return stats;\n   }\n\n   /** @summary Fill statistic */\n   fillStatistic(stat, dostat, dofit) {\n\n      // cannot fill stats without func\n      let func = this.findFunc();\n\n      if (!func || !dofit || !this.create_stats) return false;\n\n      stat.clearPave();\n\n      stat.fillFunctionStat(func, dofit);\n\n      return true;\n   }\n\n   /** @summary method draws next function from the functions list\n     * @return {Promise} */\n   async drawNextFunction(indx) {\n\n      let graph = this.getObject();\n\n      if (indx >= (graph?.fFunctions?.arr?.length || 0))\n         return this;\n\n      let pp = this.getPadPainter(),\n          func = graph.fFunctions.arr[indx],\n          opt = graph.fFunctions.opt[indx];\n\n      //  required for stats filling\n      // TODO: use weak reference (via pad list of painters and any kind of string)\n      func.$main_painter = this;\n\n      return pp.drawObject(this.getDom(), func, opt).then(() => this.drawNextFunction(indx+1));\n   }\n\n   /** @summary Draw axis histogram\n     * @private */\n   async drawAxisHisto() {\n      let histo = this.createHistogram();\n      return TH1Painter.draw(this.getDom(), histo, this.options.Axis)\n   }\n\n   /** @summary Draw TGraph\n     * @private */\n   static async _drawGraph(painter, opt) {\n      painter.decodeOptions(opt, true);\n      painter.createBins();\n      painter.createStat();\n      if (!settings.DragGraphs && !graph.TestBit(kNotEditable))\n         graph.InvertBit(kNotEditable);\n\n      let promise = Promise.resolve();\n\n      if ((!painter.getMainPainter() || painter.options.second_x || painter.options.second_y) && painter.options.Axis)\n         promise = painter.drawAxisHisto().then(hist_painter => {\n            if (hist_painter) {\n               painter.axes_draw = true;\n               if (!painter._own_histogram) painter.$primary = true;\n               hist_painter.$secondary = 'hist';\n            }\n         });\n\n      return promise.then(() => {\n         painter.addToPadPrimitives();\n         return painter.drawGraph();\n      }).then(() => painter.drawNextFunction(0));\n   }\n\n   static async draw(dom, graph, opt) {\n      return TGraphPainter._drawGraph(new TGraphPainter(dom, graph), opt);\n   }\n\n} // class TGraphPainter\n\nexport { clTGraphAsymmErrors, TGraphPainter };\n"],"x_google_ignoreList":[0]}