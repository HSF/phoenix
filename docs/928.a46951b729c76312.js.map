{"version":3,"file":"928.a46951b729c76312.js","mappings":"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","names":["RPavePainter","RObjectPainter","drawContent","_this","drawPave","rect","_this2","getPadPainter","getPadRect","fp","getFramePainter","onFrame","v7EvalAttr","corner","visible","offsetx","v7EvalLength","width","offsety","height","pave_width","pave_height","createG","draw_g","classed","createv7AttLine","createv7AttFill","pave_x","pave_y","fr","getFrameRect","x","y","attr","append","call","lineatt","func","fillatt","then","isBatchMode","settings","paveContextMenu","on","evnt","addDragHandler","minwidth","minheight","redraw","d","sizeChanged","drag","this","changes","v7AttrChange","v7SendAttrChanges","select","_this3","static","dom","pave","opt","painter","ensureRCanvas","RLegendPainter","legend","_this4","getObject","textFont","v7EvalFont","size","color","align","nlines","fEntries","length","pp","fTitle","stepy","posy","margin_x","setSize","startTextDrawing","drawText","latex","text","i","objp","entry","w4","Math","round","fLabel","fDrawableId","findSnap","fDrawable","fIO","getDom","fLine","fFill","fMarker","createv7AttMarker","fError","markeratt","create","finishTextDrawing","RPaveTextPainter","pavetext","fText","undefined","RHistStatsPainter","clearStat","stats_lines","addText","line","push","updateStatistic","reply","lines","drawStatistic","fillStatistic","_fast_drawing","obj","fLines","v7OfflineMode","main","getMainPainter","isFunc","gStyle","format","value","fmt","abs","toFixed","lastformat","res","floatToString","_this5","changeMask","nbit","mask","fShowMask","statsContextMenu","preventDefault","stopPropagation","createMenu","menu","action","bind","add","n","addchk","fillObjectExecMenu","show","_this6","first_stat","num_cols","maxlen","j","max","indexOf","parts","split","has_head","text_g","empty","selectAll","remove","max_hlen","slice","args","_expected_width","_args","post_process","ready","scaleTextDrawing","result_width","__expected_width","lpath","nrow","ncol","reason","isStr","_this7","v7NormalMode","req","_typename","v7SubmitRequest","stats"],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/hist/RPavePainter.mjs"],"sourcesContent":["import { settings, isBatchMode, isFunc, isStr, gStyle } from '../core.mjs';\nimport { floatToString } from '../base/BasePainter.mjs';\nimport { RObjectPainter } from '../base/RObjectPainter.mjs';\nimport { ensureRCanvas } from '../gpad/RCanvasPainter.mjs';\nimport { addDragHandler } from '../gpad/TFramePainter.mjs';\n\n\nconst ECorner = { kTopLeft: 1, kTopRight: 2, kBottomLeft: 3, kBottomRight: 4 };\n\n/**\n * @summary Painter for RPave class\n *\n * @private\n */\n\nclass RPavePainter extends RObjectPainter {\n\n   /** @summary Draw pave content\n     * @desc assigned depending on pave class */\n   async drawContent() { return this; }\n\n   /** @summary Draw pave */\n   async drawPave() {\n\n      let rect = this.getPadPainter().getPadRect(),\n          fp = this.getFramePainter();\n\n      this.onFrame = fp && this.v7EvalAttr('onFrame', true);\n      this.corner = this.v7EvalAttr('corner', ECorner.kTopRight);\n\n      let visible      = this.v7EvalAttr('visible', true),\n          offsetx      = this.v7EvalLength('offsetX', rect.width, 0.02),\n          offsety      = this.v7EvalLength('offsetY', rect.height, 0.02),\n          pave_width   = this.v7EvalLength('width', rect.width, 0.3),\n          pave_height  = this.v7EvalLength('height', rect.height, 0.3);\n\n      this.createG();\n\n      this.draw_g.classed('most_upper_primitives', true); // this primitive will remain on top of list\n\n      if (!visible)\n         return this;\n\n      this.createv7AttLine('border_');\n\n      this.createv7AttFill();\n\n      let pave_x = 0, pave_y = 0,\n          fr = this.onFrame ? fp.getFrameRect() : rect;\n      switch (this.corner) {\n         case ECorner.kTopLeft:\n            pave_x = fr.x + offsetx;\n            pave_y = fr.y + offsety;\n            break;\n         case ECorner.kBottomLeft:\n            pave_x = fr.x + offsetx;\n            pave_y = fr.y + fr.height - offsety - pave_height;\n            break;\n         case ECorner.kBottomRight:\n            pave_x = fr.x + fr.width - offsetx - pave_width;\n            pave_y = fr.y + fr.height - offsety - pave_height;\n            break;\n         case ECorner.kTopRight:\n         default:\n            pave_x = fr.x + fr.width - offsetx - pave_width;\n            pave_y = fr.y + offsety;\n      }\n\n      this.draw_g.attr('transform', `translate(${pave_x},${pave_y})`);\n\n      this.draw_g.append('svg:rect')\n                 .attr('x', 0)\n                 .attr('width', pave_width)\n                 .attr('y', 0)\n                 .attr('height', pave_height)\n                 .call(this.lineatt.func)\n                 .call(this.fillatt.func);\n\n      this.pave_width = pave_width;\n      this.pave_height = pave_height;\n\n      // here should be fill and draw of text\n\n      return this.drawContent().then(() => {\n\n         if (isBatchMode()) return this;\n\n         // TODO: provide pave context menu as in v6\n         if (settings.ContextMenu && this.paveContextMenu)\n            this.draw_g.on('contextmenu', evnt => this.paveContextMenu(evnt));\n\n         addDragHandler(this, { x: pave_x, y: pave_y, width: pave_width, height: pave_height,\n                                minwidth: 20, minheight: 20, redraw: d => this.sizeChanged(d) });\n\n         return this;\n      });\n   }\n\n   /** @summary Process interactive moving of the stats box */\n   sizeChanged(drag) {\n      this.pave_width = drag.width;\n      this.pave_height = drag.height;\n\n      let pave_x = drag.x,\n          pave_y = drag.y,\n          rect = this.getPadPainter().getPadRect(),\n          fr = this.onFrame ? this.getFramePainter().getFrameRect() : rect,\n          offsetx = 0, offsety = 0, changes = {};\n\n      switch (this.corner) {\n         case ECorner.kTopLeft:\n            offsetx = pave_x - fr.x;\n            offsety = pave_y - fr.y;\n            break;\n         case ECorner.kBottomLeft:\n            offsetx = pave_x - fr.x;\n            offsety = fr.y + fr.height - pave_y - this.pave_height;\n            break;\n         case ECorner.kBottomRight:\n            offsetx = fr.x + fr.width - pave_x - this.pave_width;\n            offsety = fr.y + fr.height - pave_y - this.pave_height;\n            break;\n         case ECorner.kTopRight:\n         default:\n            offsetx = fr.x + fr.width - pave_x - this.pave_width;\n            offsety = pave_y - fr.y;\n      }\n\n      this.v7AttrChange(changes, 'offsetX', offsetx / rect.width);\n      this.v7AttrChange(changes, 'offsetY', offsety / rect.height);\n      this.v7AttrChange(changes, 'width', this.pave_width / rect.width);\n      this.v7AttrChange(changes, 'height', this.pave_height / rect.height);\n      this.v7SendAttrChanges(changes, false); // do not invoke canvas update on the server\n\n      this.draw_g.select('rect')\n                 .attr('width', this.pave_width)\n                 .attr('height', this.pave_height);\n\n      this.drawContent();\n   }\n\n   /** @summary Redraw RPave object */\n   async redraw(/*reason*/) {\n      return this.drawPave();\n   }\n\n   /** @summary draw RPave object */\n   static async draw(dom, pave, opt) {\n      let painter = new RPavePainter(dom, pave, opt, 'pave');\n      return ensureRCanvas(painter, false).then(() => painter.drawPave());\n   }\n}\n\n\n/**\n * @summary Painter for RLegend class\n *\n * @private\n */\n\nclass RLegendPainter extends RPavePainter {\n\n   /** @summary draw RLegend content */\n   async drawContent() {\n      let legend     = this.getObject(),\n          textFont   = this.v7EvalFont('text', { size: 12, color: 'black', align: 22 }),\n          width      = this.pave_width,\n          height     = this.pave_height,\n          nlines     = legend.fEntries.length,\n          pp         = this.getPadPainter();\n\n      if (legend.fTitle) nlines++;\n\n      if (!nlines || !pp) return this;\n\n      let stepy = height / nlines, posy = 0, margin_x = 0.02 * width;\n\n      textFont.setSize(height/(nlines * 1.2));\n      this.startTextDrawing(textFont, 'font');\n\n      if (legend.fTitle) {\n         this.drawText({ latex: 1, width: width - 2*margin_x, height: stepy, x: margin_x, y: posy, text: legend.fTitle });\n         posy += stepy;\n      }\n\n      for (let i = 0; i < legend.fEntries.length; ++i) {\n         let objp = null, entry = legend.fEntries[i], w4 = Math.round(width/4);\n\n         this.drawText({ latex: 1, width: 0.75*width - 3*margin_x, height: stepy, x: 2*margin_x + w4, y: posy, text: entry.fLabel });\n\n         if (entry.fDrawableId != 'custom') {\n            objp = pp.findSnap(entry.fDrawableId, true);\n         } else if (entry.fDrawable.fIO) {\n            objp = new RObjectPainter(this.getDom(), entry.fDrawable.fIO);\n            if (entry.fLine) objp.createv7AttLine();\n            if (entry.fFill) objp.createv7AttFill();\n            if (entry.fMarker) objp.createv7AttMarker();\n         }\n\n         if (objp && entry.fFill && objp.fillatt)\n            this.draw_g\n              .append('svg:path')\n              .attr('d', `M${Math.round(margin_x)},${Math.round(posy + stepy*0.1)}h${w4}v${Math.round(stepy*0.8)}h${-w4}z`)\n              .call(objp.fillatt.func);\n\n         if (objp && entry.fLine && objp.lineatt)\n            this.draw_g\n              .append('svg:path')\n              .attr('d', `M${Math.round(margin_x)},${Math.round(posy + stepy/2)}h${w4}`)\n              .call(objp.lineatt.func);\n\n         if (objp && entry.fError && objp.lineatt)\n            this.draw_g\n              .append('svg:path')\n              .attr('d', `M${Math.round(margin_x + width/8)},${Math.round(posy + stepy*0.2)}v${Math.round(stepy*0.6)}`)\n              .call(objp.lineatt.func);\n\n         if (objp && entry.fMarker && objp.markeratt)\n            this.draw_g.append('svg:path')\n                .attr('d', objp.markeratt.create(margin_x + width/8, posy + stepy/2))\n                .call(objp.markeratt.func);\n\n         posy += stepy;\n      }\n\n      return this.finishTextDrawing();\n   }\n\n   /** @summary draw RLegend object */\n   static async draw(dom, legend, opt) {\n      let painter = new RLegendPainter(dom, legend, opt, 'legend');\n      return ensureRCanvas(painter, false).then(() => painter.drawPave());\n   }\n\n} // class RLegendPainter\n\n\n/**\n * @summary Painter for RPaveText class\n *\n * @private\n */\n\nclass RPaveTextPainter extends RPavePainter {\n\n   /** @summary draw RPaveText content */\n   drawContent() {\n      let pavetext  = this.getObject(),\n          textFont  = this.v7EvalFont('text', { size: 12, color: 'black', align: 22 }),\n          width     = this.pave_width,\n          height    = this.pave_height,\n          nlines    = pavetext.fText.length;\n\n      if (!nlines) return;\n\n      let stepy = height / nlines, posy = 0, margin_x = 0.02 * width;\n\n      textFont.setSize(height/(nlines * 1.2))\n\n      this.startTextDrawing(textFont, 'font');\n\n      for (let i = 0; i < pavetext.fText.length; ++i) {\n         let line = pavetext.fText[i];\n\n         this.drawText({ latex: 1, width: width - 2*margin_x, height: stepy, x: margin_x, y: posy, text: line });\n         posy += stepy;\n      }\n\n      return this.finishTextDrawing(undefined, true);\n   }\n\n   /** @summary draw RPaveText object */\n   static async draw(dom, pave, opt) {\n      let painter = new RPaveTextPainter(dom, pave, opt, 'pavetext');\n      return ensureRCanvas(painter, false).then(() => painter.drawPave());\n   }\n\n} // class RPaveTextPainter\n\n/**\n * @summary Painter for RHistStats class\n *\n * @private\n */\n\nclass RHistStatsPainter extends RPavePainter {\n\n   /** @summary clear entries from stat box */\n   clearStat() {\n      this.stats_lines = [];\n   }\n\n   /** @summary add text entry to stat box */\n   addText(line) {\n      this.stats_lines.push(line);\n   }\n\n   /** @summary update statistic from the server */\n   updateStatistic(reply) {\n      this.stats_lines = reply.lines;\n      this.drawStatistic(this.stats_lines);\n   }\n\n   /** @summary fill statistic */\n   fillStatistic() {\n      let pp = this.getPadPainter();\n      if (pp?._fast_drawing) return false;\n\n      let obj = this.getObject();\n      if (obj.fLines !== undefined) {\n         this.stats_lines = obj.fLines;\n         delete obj.fLines;\n         return true;\n      }\n\n      if (this.v7OfflineMode()) {\n         let main = this.getMainPainter();\n         if (!isFunc(main?.fillStatistic)) return false;\n         // we take statistic from main painter\n         return main.fillStatistic(this, gStyle.fOptStat, gStyle.fOptFit);\n      }\n\n      // show lines which are exists, maybe server request will be recieved later\n      return (this.stats_lines !== undefined);\n   }\n\n   /** @summary format float value as string\n     * @private */\n   format(value, fmt) {\n      if (!fmt) fmt = 'stat';\n\n      switch(fmt) {\n         case 'stat' : fmt = gStyle.fStatFormat; break;\n         case 'fit': fmt = gStyle.fFitFormat; break;\n         case 'entries': if ((Math.abs(value) < 1e9) && (Math.round(value) == value)) return value.toFixed(0); fmt = '14.7g'; break;\n         case 'last': fmt = this.lastformat; break;\n      }\n\n      let res = floatToString(value, fmt || '6.4g', true);\n\n      this.lastformat = res[1];\n\n      return res[0];\n   }\n\n   /** @summary Draw content */\n   async drawContent() {\n      if (this.fillStatistic())\n         return this.drawStatistic(this.stats_lines);\n\n      return this;\n   }\n\n   /** @summary Change mask */\n   changeMask(nbit) {\n      let obj = this.getObject(), mask = (1<<nbit);\n      if (obj.fShowMask & mask)\n         obj.fShowMask = obj.fShowMask & ~mask;\n      else\n         obj.fShowMask = obj.fShowMask | mask;\n\n      if (this.fillStatistic())\n         this.drawStatistic(this.stats_lines);\n   }\n\n   /** @summary Context menu */\n   statsContextMenu(evnt) {\n      evnt.preventDefault();\n      evnt.stopPropagation(); // disable main context menu\n\n      createMenu(evnt, this).then(menu => {\n         let obj = this.getObject(),\n             action = this.changeMask.bind(this);\n\n         menu.add('header: StatBox');\n\n         for (let n=0;n<obj.fEntries.length; ++n)\n            menu.addchk((obj.fShowMask & (1<<n)), obj.fEntries[n], n, action);\n\n         return this.fillObjectExecMenu(menu);\n     }).then(menu => menu.show());\n   }\n\n   /** @summary Draw statistic */\n   async drawStatistic(lines) {\n\n      let textFont = this.v7EvalFont('stats_text', { size: 12, color: 'black', align: 22 }),\n          first_stat = 0, num_cols = 0, maxlen = 0,\n          width = this.pave_width,\n          height = this.pave_height;\n\n      if (!lines) return this;\n\n      let nlines = lines.length;\n      // adjust font size\n      for (let j = 0; j < nlines; ++j) {\n         let line = lines[j];\n         if (j > 0) maxlen = Math.max(maxlen, line.length);\n         if ((j == 0) || (line.indexOf('|') < 0)) continue;\n         if (first_stat === 0) first_stat = j;\n         let parts = line.split('|');\n         if (parts.length > num_cols)\n            num_cols = parts.length;\n      }\n\n      // for characters like 'p' or 'y' several more pixels required to stay in the box when drawn in last line\n      let stepy = height / nlines, has_head = false, margin_x = 0.02 * width;\n\n      let text_g = this.draw_g.select('.statlines');\n      if (text_g.empty())\n         text_g = this.draw_g.append('svg:g').attr('class', 'statlines');\n      else\n         text_g.selectAll('*').remove();\n\n      textFont.setSize(height/(nlines * 1.2));\n      this.startTextDrawing(textFont, 'font' , text_g);\n\n      if (nlines == 1) {\n         this.drawText({ width: width, height: height, text: lines[0], latex: 1, draw_g: text_g });\n      } else\n      for (let j = 0; j < nlines; ++j) {\n         let posy = j*stepy;\n\n         if (first_stat && (j >= first_stat)) {\n            let parts = lines[j].split('|');\n            for (let n = 0; n < parts.length; ++n)\n               this.drawText({ align: 'middle', x: width * n / num_cols, y: posy, latex: 0,\n                               width: width/num_cols, height: stepy, text: parts[n], draw_g: text_g });\n         } else if (lines[j].indexOf('=') < 0) {\n            if (j == 0) {\n               has_head = true;\n               let max_hlen = Math.max(maxlen, Math.round((width-2*margin_x)/stepy/0.65));\n               if (lines[j].length > max_hlen + 5)\n                  lines[j] = lines[j].slice(0,max_hlen+2) + '...';\n            }\n            this.drawText({ align: (j == 0) ? 'middle' : 'start', x: margin_x, y: posy,\n                            width: width - 2*margin_x, height: stepy, text: lines[j], draw_g: text_g });\n         } else {\n            let parts = lines[j].split('='), args = [];\n\n            for (let n = 0; n < 2; ++n) {\n               let arg = {\n                  align: (n == 0) ? 'start' : 'end', x: margin_x, y: posy,\n                  width: width-2*margin_x, height: stepy, text: parts[n], draw_g: text_g,\n                  _expected_width: width-2*margin_x, _args: args,\n                  post_process(painter) {\n                    if (this._args[0].ready && this._args[1].ready)\n                       painter.scaleTextDrawing(1.05*(this._args[0].result_width && this._args[1].result_width)/this.__expected_width, this.draw_g);\n                  }\n               };\n               args.push(arg);\n            }\n\n            for (let n = 0; n < 2; ++n)\n               this.drawText(args[n]);\n         }\n      }\n\n      let lpath = '';\n\n      if (has_head)\n         lpath += 'M0,' + Math.round(stepy) + 'h' + width;\n\n      if ((first_stat > 0) && (num_cols > 1)) {\n         for (let nrow = first_stat; nrow < nlines; ++nrow)\n            lpath += 'M0,' + Math.round(nrow * stepy) + 'h' + width;\n         for (let ncol = 0; ncol < num_cols - 1; ++ncol)\n            lpath += 'M' + Math.round(width / num_cols * (ncol + 1)) + ',' + Math.round(first_stat * stepy) + 'V' + height;\n      }\n\n      if (lpath) this.draw_g.append('svg:path').attr('d',lpath) /*.call(this.lineatt.func)*/;\n\n      return this.finishTextDrawing(text_g);\n   }\n\n   /** @summary Redraw stats box */\n   async redraw(reason) {\n      if (reason && isStr(reason) && (reason.indexOf('zoom') == 0) && this.v7NormalMode()) {\n         let req = {\n            _typename: 'ROOT::Experimental::RHistStatBoxBase::RRequest',\n            mask: this.getObject().fShowMask // lines to show in stat box\n         };\n\n         this.v7SubmitRequest('stat', req, reply => this.updateStatistic(reply));\n      }\n\n      return this.drawPave();\n   }\n\n   /** @summary draw RHistStats object */\n   static async draw(dom, stats, opt) {\n      let painter = new RHistStatsPainter(dom, stats, opt, stats);\n      return ensureRCanvas(painter, false).then(() => painter.drawPave());\n   }\n\n} // class RHistStatsPainter\n\n\nexport { RPavePainter, RLegendPainter, RPaveTextPainter, RHistStatsPainter };\n"],"x_google_ignoreList":[0]}