{"version":3,"file":"294.9ff3d4f232472e13.js","mappings":"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","names":["RH1Painter","RHistPainter","constructor","dom","histo","super","this","wheel_zoomy","scanContent","when_axis_changed","getHisto","nbinsx","extractAxesProperties","hmin","hmin_nz","hmax","hsum","isDisplayItem","fContMin","fContMinPos","fContMax","left","getSelectIndex","right","scan_xleft","scan_xright","value","err","first","i","getBinContent","Math","min","max","stat_entries","ymin_nz","draw_content","abs","ymin","ymax","dy","countStat","cond","xaxis","getAxis","res","name","meanx","meany","rmsx","rmsy","integral","entries","xmax","wmax","stat_sumw","stat_sumwx","stat_sumwx2","xx","w","GetBinCoord","sqrt","fillStatistic","stat","dostat","data","print_name","print_entries","floor","print_mean","print_rms","print_under","print_over","print_integral","print_skew","print_kurt","clearStat","addText","format","drawBars","handle","funcs","width","height","_this","_asyncToGenerator","createG","i1","i2","di","stepi","pmain","getFramePainter","x1","x2","grx1","grx2","y","gry1","gry2","bars","barsl","barsr","swap_xy","Number","isFinite","options","BaseLine","scale_ymin","round","gry","logx","grx","logy","BarOffset","BarWidth","BarStyle","fillatt","empty","setSolidColor","draw_g","append","attr","call","func","style","d3_rgb","color","brighter","formatHex","darker","drawFilledErrors","_this2","bins1","bins2","x","yerr","getBinError","push","unshift","path1","buildSvgCurve","line","ErrorKind","path2","cmd","draw1DBins","_this3","rect","getFrameRect","removeG","createHistDrawAttributes","prepareDraw","extra","only_indexes","getGrFuncs","second_x","second_y","Bar","drawHistBins","_this4","want_tooltip","isBatchMode","settings","Tooltip","exclude_zero","Zero","show_errors","Error","show_line","Line","show_text","Text","startx","currx","curry","curry_min","curry_max","prevy","prevx","bestimin","bestimax","my","yerr1","yerr2","bincont","binerr","mx1","mx2","midx","text_font","show_markers","Mark","lastbin","path_fill","path_err","path_marker","path_line","hints_err","endx","endy","dend","v7EvalAttr","createv7AttMarker","markeratt","size","resetPos","v7EvalFont","align","angle","TextKind","space","setAngle","setSize","startTextDrawing","use_minmax","lw","lineatt","gStyle","fEndErrorSize","draw_markers","draw_bin","besti","lbl","toString","floatToString","fPaintTextFormat","drawText","text","latex","length","create","edx","errorX","mmx1","fill_for_interactive","Hist","h0","gry0","close_path","finishTextDrawing","getBinTooltips","bin","tips","getObjectHint","stepx","xlbl","getAxisBinTip","cont","axisAsText","toPrecision","$baseh","fStatFormat","processTooltipEvent","pnt","ttrect","selectChild","Mode3D","remove","getFrameWidth","getFrameHeight","show_rect","findbin","gapx","l","r","GetBinGrX","GetBinGrY","yy","pnt_x","pnt_y","m","best","dist","dx","nx","midy","touch","nproc","msize","getFullSize","title","fTitle","exact","color1","color2","getFillColorAlt","lines","disabled","changed","addHighlightStyle","property","menu","menu_dist","radius","user_info","obj","fillHistContextMenu","add","autoZoom","opts","getSupportedDrawOptions","addDrawMenu","arg","indexOf","kInspect","showInspector","decodeOptions","need_fillcol","change","interactiveRedraw","indx","zoom","canZoomInside","axis","FindBin","callDrawFunc","reason","_this5","main","mode3d","isMainPainter","draw3D","draw2D","_this6","clear3DScene","drawFrameAxes","then","drawingBins","addInteractivity","_this7","console","log","redraw","_this8","_draw","painter","opt","ensureRCanvas","setAsMainPainter","fErrorX","Fill","Lego","Surf","TextAngle","AutoColor","FrontBox","BackBox","d","DrawOptions","check","Render3D","constants","fromString","part","toLowerCase","kind","sub","has_main","getMainPainter","o","draw","RH1Painter2D","is_main","zmult","fHistTopMargin","pr","Promise","resolve","resize3D","render3D","deleteAttr","assignFrame3DMethods","create3DScene","setAxesRanges","xmin","set3DOptions","drawXYZ","toplevel","RAxisPainter","use_y_for_z","Zooming","ndim","v7","drawBinsLego","updatePaletteDraw","addKeysHandler"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/hist2d/RH1Painter.mjs","../node_modules/jsroot/modules/hist/RH1Painter.mjs"],"sourcesContent":["import { gStyle, settings, constants, kInspect } from '../core.mjs';\nimport { rgb as d3_rgb } from '../d3.mjs';\nimport { floatToString, DrawOptions, buildSvgCurve, addHighlightStyle } from '../base/BasePainter.mjs';\nimport { RHistPainter } from './RHistPainter.mjs';\nimport { ensureRCanvas } from '../gpad/RCanvasPainter.mjs';\n\n\n/**\n * @summary Painter for RH1 classes\n *\n * @private\n */\n\nclass RH1Painter extends RHistPainter {\n\n   /** @summary Constructor\n     * @param {object|string} dom - DOM element or id\n     * @param {object} histo - histogram object */\n   constructor(dom, histo) {\n      super(dom, histo);\n      this.wheel_zoomy = false;\n   }\n\n   /** @summary Scan content */\n   scanContent(when_axis_changed) {\n      // if when_axis_changed === true specified, content will be scanned after axis zoom changed\n\n      const histo = this.getHisto();\n      if (!histo) return;\n\n      if (!this.nbinsx && when_axis_changed) when_axis_changed = false;\n\n      if (!when_axis_changed)\n         this.extractAxesProperties(1);\n\n      let hmin = 0, hmin_nz = 0, hmax = 0, hsum = 0;\n\n      if (this.isDisplayItem()) {\n         // take min/max values from the display item\n         hmin = histo.fContMin;\n         hmin_nz = histo.fContMinPos;\n         hmax = histo.fContMax;\n         hsum = hmax;\n      } else {\n         const left = this.getSelectIndex('x', 'left'),\n               right = this.getSelectIndex('x', 'right');\n\n         if (when_axis_changed)\n            if ((left === this.scan_xleft) && (right === this.scan_xright)) return;\n\n\n         this.scan_xleft = left;\n         this.scan_xright = right;\n\n         let first = true, value, err;\n\n         for (let i = 0; i < this.nbinsx; ++i) {\n            value = histo.getBinContent(i+1);\n            hsum += value;\n\n            if ((i<left) || (i>=right)) continue;\n\n            if (value > 0)\n               if ((hmin_nz === 0) || (value<hmin_nz)) hmin_nz = value;\n            if (first) {\n               hmin = hmax = value;\n               first = false;\n            }\n\n            err = 0;\n\n            hmin = Math.min(hmin, value - err);\n            hmax = Math.max(hmax, value + err);\n         }\n      }\n\n      this.stat_entries = hsum;\n\n      this.hmin = hmin;\n      this.hmax = hmax;\n\n      this.ymin_nz = hmin_nz; // value can be used to show optimal log scale\n\n      if ((this.nbinsx === 0) || ((Math.abs(hmin) < 1e-300) && (Math.abs(hmax) < 1e-300)))\n         this.draw_content = false;\n      else\n         this.draw_content = true;\n\n      if (this.draw_content) {\n         if (hmin >= hmax) {\n            if (hmin === 0) {\n               this.ymin = 0;\n               this.ymax = 1;\n            } else if (hmin < 0) {\n               this.ymin = 2 * hmin;\n               this.ymax = 0;\n            } else {\n               this.ymin = 0;\n               this.ymax = hmin * 2;\n            }\n         } else {\n            const dy = (hmax - hmin) * 0.05;\n            this.ymin = hmin - dy;\n            if ((this.ymin < 0) && (hmin >= 0)) this.ymin = 0;\n            this.ymax = hmax + dy;\n         }\n      }\n   }\n\n   /** @summary Count statistic */\n   countStat(cond) {\n      const histo = this.getHisto(), xaxis = this.getAxis('x'),\n            left = this.getSelectIndex('x', 'left'),\n            right = this.getSelectIndex('x', 'right'),\n            stat_sumwy = 0, stat_sumwy2 = 0,\n            res = { name: 'histo', meanx: 0, meany: 0, rmsx: 0, rmsy: 0, integral: 0, entries: this.stat_entries, xmax: 0, wmax: 0 };\n      let stat_sumw = 0, stat_sumwx = 0, stat_sumwx2 = 0,\n          i, xx = 0, w = 0, xmax = null, wmax = null;\n\n      for (i = left; i < right; ++i) {\n         xx = xaxis.GetBinCoord(i+0.5);\n\n         if (cond && !cond(xx)) continue;\n\n         w = histo.getBinContent(i + 1);\n\n         if ((xmax === null) || (w > wmax)) { xmax = xx; wmax = w; }\n\n         stat_sumw += w;\n         stat_sumwx += w * xx;\n         stat_sumwx2 += w * xx**2;\n      }\n\n      res.integral = stat_sumw;\n\n      if (Math.abs(stat_sumw) > 1e-300) {\n         res.meanx = stat_sumwx / stat_sumw;\n         res.meany = stat_sumwy / stat_sumw;\n         res.rmsx = Math.sqrt(Math.abs(stat_sumwx2 / stat_sumw - res.meanx**2));\n         res.rmsy = Math.sqrt(Math.abs(stat_sumwy2 / stat_sumw - res.meany**2));\n      }\n\n      if (xmax !== null) {\n         res.xmax = xmax;\n         res.wmax = wmax;\n      }\n\n      return res;\n   }\n\n   /** @summary Fill statistic */\n   fillStatistic(stat, dostat/*, dofit */) {\n      const histo = this.getHisto(),\n          data = this.countStat(),\n          print_name = dostat % 10,\n          print_entries = Math.floor(dostat / 10) % 10,\n          print_mean = Math.floor(dostat / 100) % 10,\n          print_rms = Math.floor(dostat / 1000) % 10,\n          print_under = Math.floor(dostat / 10000) % 10,\n          print_over = Math.floor(dostat / 100000) % 10,\n          print_integral = Math.floor(dostat / 1000000) % 10,\n          print_skew = Math.floor(dostat / 10000000) % 10,\n          print_kurt = Math.floor(dostat / 100000000) % 10;\n\n      // make empty at the beginning\n      stat.clearStat();\n\n      if (print_name > 0)\n         stat.addText(data.name);\n\n      if (print_entries > 0)\n         stat.addText('Entries = ' + stat.format(data.entries, 'entries'));\n\n      if (print_mean > 0)\n         stat.addText('Mean = ' + stat.format(data.meanx));\n\n      if (print_rms > 0)\n         stat.addText('Std Dev = ' + stat.format(data.rmsx));\n\n      if (print_under > 0)\n         stat.addText('Underflow = ' + stat.format(histo.getBinContent(0), 'entries'));\n\n      if (print_over > 0)\n         stat.addText('Overflow = ' + stat.format(histo.getBinContent(this.nbinsx+1), 'entries'));\n\n      if (print_integral > 0)\n         stat.addText('Integral = ' + stat.format(data.integral, 'entries'));\n\n      if (print_skew > 0)\n         stat.addText('Skew = <not avail>');\n\n      if (print_kurt > 0)\n         stat.addText('Kurt = <not avail>');\n\n      return true;\n   }\n\n   /** @summary Draw histogram as bars */\n   async drawBars(handle, funcs, width, height) {\n      this.createG(true);\n\n      const left = handle.i1, right = handle.i2, di = handle.stepi,\n            pmain = this.getFramePainter(),\n            histo = this.getHisto(), xaxis = this.getAxis('x');\n      let i, x1, x2, grx1, grx2, y, gry1, gry2, w,\n          bars = '', barsl = '', barsr = '';\n\n      gry2 = pmain.swap_xy ? 0 : height;\n      if (Number.isFinite(this.options.BaseLine)) {\n         if (this.options.BaseLine >= funcs.scale_ymin)\n            gry2 = Math.round(funcs.gry(this.options.BaseLine));\n      }\n\n      for (i = left; i < right; i += di) {\n         x1 = xaxis.GetBinCoord(i);\n         x2 = xaxis.GetBinCoord(i+di);\n\n         if (funcs.logx && (x2 <= 0)) continue;\n\n         grx1 = Math.round(funcs.grx(x1));\n         grx2 = Math.round(funcs.grx(x2));\n\n         y = histo.getBinContent(i+1);\n         if (funcs.logy && (y < funcs.scale_ymin)) continue;\n         gry1 = Math.round(funcs.gry(y));\n\n         w = grx2 - grx1;\n         grx1 += Math.round(this.options.BarOffset*w);\n         w = Math.round(this.options.BarWidth*w);\n\n         if (pmain.swap_xy)\n            bars += `M${gry2},${grx1}h${gry1-gry2}v${w}h${gry2-gry1}z`;\n         else\n            bars += `M${grx1},${gry1}h${w}v${gry2-gry1}h${-w}z`;\n\n         if (this.options.BarStyle > 0) {\n            grx2 = grx1 + w;\n            w = Math.round(w / 10);\n            if (pmain.swap_xy) {\n               barsl += `M${gry2},${grx1}h${gry1-gry2}v${w}h${gry2-gry1}z`;\n               barsr += `M${gry2},${grx2}h${gry1-gry2}v${-w}h${gry2-gry1}z`;\n            } else {\n               barsl += `M${grx1},${gry1}h${w}v${gry2-gry1}h${-w}z`;\n               barsr += `M${grx2},${gry1}h${-w}v${gry2-gry1}h${w}z`;\n            }\n         }\n      }\n\n      if (this.fillatt.empty()) this.fillatt.setSolidColor('blue');\n\n      if (bars) {\n         this.draw_g.append('svg:path')\n                    .attr('d', bars)\n                    .call(this.fillatt.func);\n      }\n\n      if (barsl) {\n         this.draw_g.append('svg:path')\n               .attr('d', barsl)\n               .call(this.fillatt.func)\n               .style('fill', d3_rgb(this.fillatt.color).brighter(0.5).formatHex());\n      }\n\n      if (barsr) {\n         this.draw_g.append('svg:path')\n               .attr('d', barsr)\n               .call(this.fillatt.func)\n               .style('fill', d3_rgb(this.fillatt.color).darker(0.5).formatHex());\n       }\n\n       return true;\n   }\n\n   /** @summary Draw histogram as filled errors */\n   async drawFilledErrors(handle, funcs /*, width, height */) {\n      this.createG(true);\n\n      const left = handle.i1, right = handle.i2, di = handle.stepi,\n            histo = this.getHisto(), xaxis = this.getAxis('x'),\n            bins1 = [], bins2 = [];\n      let i, x, grx, y, yerr, gry;\n\n      for (i = left; i < right; i += di) {\n         x = xaxis.GetBinCoord(i+0.5);\n         if (funcs.logx && (x <= 0)) continue;\n         grx = Math.round(funcs.grx(x));\n\n         y = histo.getBinContent(i+1);\n         yerr = histo.getBinError(i+1);\n         if (funcs.logy && (y-yerr < funcs.scale_ymin)) continue;\n\n         gry = Math.round(funcs.gry(y + yerr));\n         bins1.push({ grx, gry });\n\n         gry = Math.round(funcs.gry(y - yerr));\n         bins2.unshift({ grx, gry });\n      }\n\n      const path1 = buildSvgCurve(bins1, { line: this.options.ErrorKind !== 4 }),\n            path2 = buildSvgCurve(bins2, { line: this.options.ErrorKind !== 4, cmd: 'L' });\n\n      if (this.fillatt.empty()) this.fillatt.setSolidColor('blue');\n\n      this.draw_g.append('svg:path')\n                 .attr('d', path1 + path2 + 'Z')\n                 .call(this.fillatt.func);\n\n      return true;\n   }\n\n   /** @summary Draw 1D histogram as SVG */\n   async draw1DBins() {\n      const pmain = this.getFramePainter(),\n          rect = pmain.getFrameRect();\n\n      if (!this.draw_content || (rect.width <= 0) || (rect.height <= 0)) {\n         this.removeG();\n         return false;\n      }\n\n      this.createHistDrawAttributes();\n\n      const handle = this.prepareDraw({ extra: 1, only_indexes: true }),\n          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y);\n\n      if (this.options.Bar)\n         return this.drawBars(handle, funcs, rect.width, rect.height);\n\n      if ((this.options.ErrorKind === 3) || (this.options.ErrorKind === 4))\n         return this.drawFilledErrors(handle, funcs, rect.width, rect.height);\n\n      return this.drawHistBins(handle, funcs, rect.width, rect.height);\n   }\n\n   /** @summary Draw histogram bins */\n   async drawHistBins(handle, funcs, width, height) {\n      this.createG(true);\n\n      const options = this.options,\n            left = handle.i1,\n            right = handle.i2,\n            di = handle.stepi,\n            histo = this.getHisto(),\n            want_tooltip = !this.isBatchMode() && settings.Tooltip,\n            xaxis = this.getAxis('x'),\n            exclude_zero = !options.Zero,\n            show_errors = options.Error,\n            show_line = options.Line,\n            show_text = options.Text;\n      let show_markers = options.Mark,\n          res = '', lastbin = false,\n          startx, currx, curry, x, grx, y, gry, curry_min, curry_max, prevy, prevx, i, bestimin, bestimax,\n          path_fill = null, path_err = null, path_marker = null, path_line = null,\n          hints_err = null,\n          endx = '', endy = '', dend = 0, my, yerr1, yerr2, bincont, binerr, mx1, mx2, midx,\n          text_font;\n\n      if (show_errors && !show_markers && (this.v7EvalAttr('marker_style', 1) > 1))\n         show_markers = true;\n\n      if (options.ErrorKind === 2) {\n         if (this.fillatt.empty()) show_markers = true;\n                              else path_fill = '';\n      } else if (options.Error) {\n         path_err = '';\n         hints_err = want_tooltip ? '' : null;\n      }\n\n      if (show_line) path_line = '';\n\n      if (show_markers) {\n         // draw markers also when e2 option was specified\n         this.createv7AttMarker();\n         if (this.markeratt.size > 0) {\n            // simply use relative move from point, can optimize in the future\n            path_marker = '';\n            this.markeratt.resetPos();\n         } else\n            show_markers = false;\n      }\n\n      if (show_text) {\n         text_font = this.v7EvalFont('text', { size: 20, color: 'black', align: 22 });\n\n         if (!text_font.angle && !options.TextKind) {\n             const space = width / (right - left + 1);\n             if (space < 3 * text_font.size) {\n                text_font.setAngle(270);\n                text_font.setSize(Math.round(space*0.7));\n             }\n         }\n\n         this.startTextDrawing(text_font, 'font');\n      }\n\n      // if there are too many points, exclude many vertical drawings at the same X position\n      // instead define min and max value and made min-max drawing\n      let use_minmax = ((right-left) > 3*width);\n\n      if (options.ErrorKind === 1) {\n         const lw = this.lineatt.width + gStyle.fEndErrorSize;\n         endx = `m0,${lw}v${-2*lw}m0,${lw}`;\n         endy = `m${lw},0h${-2*lw}m${lw},0`;\n         dend = Math.floor((this.lineatt.width-1)/2);\n      }\n\n      const draw_markers = show_errors || show_markers;\n\n      if (draw_markers || show_text || show_line) use_minmax = true;\n\n      const draw_bin = besti => {\n         bincont = histo.getBinContent(besti+1);\n         if (!exclude_zero || (bincont !== 0)) {\n            mx1 = Math.round(funcs.grx(xaxis.GetBinCoord(besti)));\n            mx2 = Math.round(funcs.grx(xaxis.GetBinCoord(besti+di)));\n            midx = Math.round((mx1+mx2)/2);\n            my = Math.round(funcs.gry(bincont));\n            yerr1 = yerr2 = 20;\n            if (show_errors) {\n               binerr = histo.getBinError(besti+1);\n               yerr1 = Math.round(my - funcs.gry(bincont + binerr)); // up\n               yerr2 = Math.round(funcs.gry(bincont - binerr) - my); // down\n            }\n\n            if (show_text && (bincont !== 0)) {\n               const lbl = (bincont === Math.round(bincont)) ? bincont.toString() : floatToString(bincont, gStyle.fPaintTextFormat);\n\n               if (text_font.angle)\n                  this.drawText({ align: 12, x: midx, y: Math.round(my - 2 - text_font.size / 5), text: lbl, latex: 0 });\n               else\n                  this.drawText({ x: Math.round(mx1 + (mx2 - mx1) * 0.1), y: Math.round(my - 2 - text_font.size), width: Math.round((mx2 - mx1) * 0.8), height: text_font.size, text: lbl, latex: 0 });\n            }\n\n            if (show_line && (path_line !== null))\n               path_line += ((path_line.length === 0) ? 'M' : 'L') + midx + ',' + my;\n\n            if (draw_markers) {\n               if ((my >= -yerr1) && (my <= height + yerr2)) {\n                  if (path_fill !== null)\n                     path_fill += `M${mx1},${my-yerr1}h${mx2-mx1}v${yerr1+yerr2+1}h${mx1-mx2}z`;\n                  if (path_marker !== null)\n                     path_marker += this.markeratt.create(midx, my);\n                  if (path_err !== null) {\n                     let edx = 5;\n                     if (this.options.errorX > 0) {\n                        edx = Math.round((mx2-mx1)*this.options.errorX);\n                        const mmx1 = midx - edx, mmx2 = midx + edx;\n                        path_err += `M${mmx1+dend},${my}${endx}h${mmx2-mmx1-2*dend}${endx}`;\n                     }\n                     path_err += `M${midx},${my-yerr1+dend}${endy}v${yerr1+yerr2-2*dend}${endy}`;\n                     if (hints_err !== null)\n                        hints_err += `M${midx-edx},${my-yerr1}h${2*edx}v${yerr1+yerr2}h${-2*edx}z`;\n                  }\n               }\n            }\n         }\n      };\n\n      for (i = left; i <= right; i += di) {\n         x = xaxis.GetBinCoord(i);\n\n         if (funcs.logx && (x <= 0)) continue;\n\n         grx = Math.round(funcs.grx(x));\n\n         lastbin = (i > right - di);\n\n         if (lastbin && (left < right))\n            gry = curry;\n          else {\n            y = histo.getBinContent(i+1);\n            gry = Math.round(funcs.gry(y));\n         }\n\n         if (res.length === 0) {\n            bestimin = bestimax = i;\n            prevx = startx = currx = grx;\n            prevy = curry_min = curry_max = curry = gry;\n            res = 'M'+currx+','+curry;\n         } else\n         if (use_minmax) {\n            if ((grx === currx) && !lastbin) {\n               if (gry < curry_min) bestimax = i; else\n               if (gry > curry_max) bestimin = i;\n               curry_min = Math.min(curry_min, gry);\n               curry_max = Math.max(curry_max, gry);\n               curry = gry;\n            } else {\n               if (draw_markers || show_text || show_line) {\n                  if (bestimin === bestimax) draw_bin(bestimin); else\n                     if (bestimin < bestimax) { draw_bin(bestimin); draw_bin(bestimax); } else {\n                        draw_bin(bestimax); draw_bin(bestimin);\n                     }\n               }\n\n               // when several points as same X differs, need complete logic\n               if (!draw_markers && ((curry_min !== curry_max) || (prevy !== curry_min))) {\n                  if (prevx !== currx)\n                     res += 'h'+(currx-prevx);\n\n                  if (curry === curry_min) {\n                     if (curry_max !== prevy)\n                        res += 'v' + (curry_max - prevy);\n                     if (curry_min !== curry_max)\n                        res += 'v' + (curry_min - curry_max);\n                  } else {\n                     if (curry_min !== prevy)\n                        res += 'v' + (curry_min - prevy);\n                     if (curry_max !== curry_min)\n                        res += 'v' + (curry_max - curry_min);\n                     if (curry !== curry_max)\n                       res += 'v' + (curry - curry_max);\n                  }\n\n                  prevx = currx;\n                  prevy = curry;\n               }\n\n               if (lastbin && (prevx !== grx))\n                  res += 'h'+(grx-prevx);\n\n               bestimin = bestimax = i;\n               curry_min = curry_max = curry = gry;\n               currx = grx;\n            }\n         } else\n         if ((gry !== curry) || lastbin) {\n            if (grx !== currx) res += 'h'+(grx-currx);\n            if (gry !== curry) res += 'v'+(gry-curry);\n            curry = gry;\n            currx = grx;\n         }\n      }\n\n      const fill_for_interactive = !this.isBatchMode() && this.fillatt.empty() && options.Hist && settings.Tooltip && !draw_markers && !show_line;\n      let h0 = height + 3;\n      if (!fill_for_interactive) {\n         const gry0 = Math.round(funcs.gry(0));\n         if (gry0 <= 0)\n            h0 = -3;\n         else if (gry0 < height)\n            h0 = gry0;\n      }\n      const close_path = `L${currx},${h0}H${startx}Z`;\n\n      if (draw_markers || show_line) {\n         if (path_fill) {\n            this.draw_g.append('svg:path')\n                       .attr('d', path_fill)\n                       .call(this.fillatt.func);\n         }\n\n         if (path_err) {\n            this.draw_g.append('svg:path')\n                   .attr('d', path_err)\n                   .call(this.lineatt.func);\n         }\n\n         if (hints_err) {\n            this.draw_g.append('svg:path')\n                   .attr('d', hints_err)\n                   .style('fill', 'none')\n                   .style('pointer-events', this.isBatchMode() ? null : 'visibleFill');\n         }\n\n         if (path_line) {\n            if (!this.fillatt.empty() && !options.Hist) {\n               this.draw_g.append('svg:path')\n                     .attr('d', path_line + close_path)\n                     .call(this.fillatt.func);\n            }\n\n            this.draw_g.append('svg:path')\n                   .attr('d', path_line)\n                   .style('fill', 'none')\n                   .call(this.lineatt.func);\n         }\n\n         if (path_marker) {\n            this.draw_g.append('svg:path')\n                .attr('d', path_marker)\n                .call(this.markeratt.func);\n         }\n      } else if (res && options.Hist) {\n         this.draw_g.append('svg:path')\n                    .attr('d', res + ((!this.fillatt.empty() || fill_for_interactive) ? close_path : ''))\n                    .style('stroke-linejoin', 'miter')\n                    .call(this.lineatt.func)\n                    .call(this.fillatt.func);\n      }\n\n      return show_text ? this.finishTextDrawing() : true;\n   }\n\n   /** @summary Provide text information (tooltips) for histogram bin */\n   getBinTooltips(bin) {\n      const tips = [],\n            name = this.getObjectHint(),\n            pmain = this.getFramePainter(),\n            histo = this.getHisto(),\n            xaxis = this.getAxis('x'),\n            di = this.isDisplayItem() ? histo.stepx : 1,\n            x1 = xaxis.GetBinCoord(bin),\n            x2 = xaxis.GetBinCoord(bin+di),\n            xlbl = this.getAxisBinTip('x', bin, di);\n\n      let cont = histo.getBinContent(bin+1);\n\n      if (name) tips.push(name);\n\n      if (this.options.Error || this.options.Mark) {\n         tips.push(`x = ${xlbl}`, `y = ${pmain.axisAsText('y', cont)}`);\n         if (this.options.Error) {\n            if (xlbl[0] === '[') tips.push('error x = ' + ((x2 - x1) / 2).toPrecision(4));\n            tips.push('error y = ' + histo.getBinError(bin + 1).toPrecision(4));\n         }\n      } else {\n         tips.push(`bin = ${bin+1}`, `x = ${xlbl}`);\n         if (histo.$baseh) cont -= histo.$baseh.getBinContent(bin+1);\n         const lbl = 'entries = ' + (di > 1 ? '~' : '');\n         if (cont === Math.round(cont))\n            tips.push(lbl + cont);\n         else\n            tips.push(lbl + floatToString(cont, gStyle.fStatFormat));\n      }\n\n      return tips;\n   }\n\n   /** @summary Process tooltip event */\n   processTooltipEvent(pnt) {\n      let ttrect = this.draw_g?.selectChild('.tooltip_bin');\n\n      if (!pnt || !this.draw_content || this.options.Mode3D || !this.draw_g) {\n         ttrect?.remove();\n         return null;\n      }\n\n      const pmain = this.getFramePainter(),\n            funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),\n            width = pmain.getFrameWidth(),\n            height = pmain.getFrameHeight(),\n            histo = this.getHisto(), xaxis = this.getAxis('x'),\n            left = this.getSelectIndex('x', 'left', -1),\n            right = this.getSelectIndex('x', 'right', 2);\n\n      let findbin = null, show_rect,\n          grx1, grx2, gry1, gry2, gapx = 2,\n          l = left, r = right;\n\n      function GetBinGrX(i) {\n         const xx = xaxis.GetBinCoord(i);\n         return (funcs.logx && (xx <= 0)) ? null : funcs.grx(xx);\n      }\n\n      function GetBinGrY(i) {\n         const yy = histo.getBinContent(i + 1);\n         if (funcs.logy && (yy < funcs.scale_ymin))\n            return funcs.swap_xy ? -1000 : 10*height;\n         return Math.round(funcs.gry(yy));\n      }\n\n      const pnt_x = funcs.swap_xy ? pnt.y : pnt.x,\n            pnt_y = funcs.swap_xy ? pnt.x : pnt.y;\n\n      while (l < r-1) {\n         const m = Math.round((l+r)*0.5),\n               xx = GetBinGrX(m);\n         if ((xx === null) || (xx < pnt_x - 0.5))\n            if (funcs.swap_xy) r = m; else l = m;\n          else if (xx > pnt_x + 0.5)\n            if (funcs.swap_xy) l = m; else r = m;\n          else { l++; r--; }\n      }\n\n      findbin = r = l;\n      grx1 = GetBinGrX(findbin);\n\n      if (funcs.swap_xy) {\n         while ((l > left) && (GetBinGrX(l-1) < grx1 + 2)) --l;\n         while ((r < right) && (GetBinGrX(r+1) > grx1 - 2)) ++r;\n      } else {\n         while ((l > left) && (GetBinGrX(l-1) > grx1 - 2)) --l;\n         while ((r < right) && (GetBinGrX(r+1) < grx1 + 2)) ++r;\n      }\n\n      if (l < r) {\n         // many points can be assigned with the same cursor position\n         // first try point around mouse y\n         let best = height;\n         for (let m = l; m <= r; m++) {\n            const dist = Math.abs(GetBinGrY(m) - pnt_y);\n            if (dist < best) { best = dist; findbin = m; }\n         }\n\n         // if best distance still too far from mouse position, just take from between\n         if (best > height/10)\n            findbin = Math.round(l + (r-l) / height * pnt_y);\n\n         grx1 = GetBinGrX(findbin);\n      }\n\n      grx1 = Math.round(grx1);\n      grx2 = Math.round(GetBinGrX(findbin+1));\n\n      if (this.options.Bar) {\n         const w = grx2 - grx1;\n         grx1 += Math.round(this.options.BarOffset*w);\n         grx2 = grx1 + Math.round(this.options.BarWidth*w);\n      }\n\n      if (grx1 > grx2)\n         [grx1, grx2] = [grx2, grx1];\n\n      if (this.isDisplayItem() && ((findbin <= histo.dx) || (findbin >= histo.dx + histo.nx))) {\n         // special case when zoomed out of scale and bin is not available\n         ttrect.remove();\n         return null;\n      }\n\n      const midx = Math.round((grx1 + grx2)/2),\n            midy = gry1 = gry2 = GetBinGrY(findbin);\n\n      if (this.options.Bar) {\n         show_rect = true;\n\n         gapx = 0;\n\n         gry1 = Math.round(funcs.gry(((this.options.BaseLine!==false) && (this.options.BaseLine > funcs.scale_ymin)) ? this.options.BaseLine : funcs.scale_ymin));\n\n         if (gry1 > gry2)\n            [gry1, gry2] = [gry2, gry1];\n\n         if (!pnt.touch && (pnt.nproc === 1))\n            if ((pnt_y < gry1) || (pnt_y > gry2)) findbin = null;\n      } else if (this.options.Error || this.options.Mark) {\n         show_rect = true;\n\n         let msize = 3;\n         if (this.markeratt) msize = Math.max(msize, this.markeratt.getFullSize());\n\n         if (this.options.Error) {\n            const cont = histo.getBinContent(findbin+1),\n                  binerr = histo.getBinError(findbin+1);\n\n            gry1 = Math.round(funcs.gry(cont + binerr)); // up\n            gry2 = Math.round(funcs.gry(cont - binerr)); // down\n\n            const dx = (grx2-grx1)*this.options.errorX;\n            grx1 = Math.round(midx - dx);\n            grx2 = Math.round(midx + dx);\n         }\n\n         // show at least 6 pixels as tooltip rect\n         if (grx2 - grx1 < 2*msize) { grx1 = midx-msize; grx2 = midx+msize; }\n\n         gry1 = Math.min(gry1, midy - msize);\n         gry2 = Math.max(gry2, midy + msize);\n\n         if (!pnt.touch && (pnt.nproc === 1))\n            if ((pnt_y < gry1) || (pnt_y > gry2)) findbin = null;\n      } else if (this.options.Line)\n\n         show_rect = false;\n\n       else {\n         // if histogram alone, use old-style with rects\n         // if there are too many points at pixel, use circle\n         show_rect = (pnt.nproc === 1) && (right-left < width);\n\n         if (show_rect) {\n            gry2 = height;\n\n            if (!this.fillatt.empty()) {\n               gry2 = Math.min(height, Math.max(0, Math.round(funcs.gry(0))));\n               if (gry2 < gry1)\n                  [gry1, gry2] = [gry2, gry1];\n            }\n\n            // for mouse events pointer should be between y1 and y2\n            if (((pnt.y < gry1) || (pnt.y > gry2)) && !pnt.touch) findbin = null;\n         }\n      }\n\n      if (findbin !== null) {\n         // if bin on boundary found, check that x position is ok\n         if ((findbin === left) && (grx1 > pnt_x + gapx)) findbin = null; else\n         if ((findbin === right-1) && (grx2 < pnt_x - gapx)) findbin = null; else\n         // if bars option used check that bar is not match\n         if ((pnt_x < grx1 - gapx) || (pnt_x > grx2 + gapx)) findbin = null; else\n         // exclude empty bin if empty bins suppressed\n         if (!this.options.Zero && (histo.getBinContent(findbin+1) === 0)) findbin = null;\n      }\n\n      if ((findbin === null) || ((gry2 <= 0) || (gry1 >= height))) {\n         ttrect.remove();\n         return null;\n      }\n\n      const res = { name: 'histo', title: histo.fTitle,\n                  x: midx, y: midy, exact: true,\n                  color1: this.lineatt?.color ?? 'green',\n                  color2: this.fillatt?.getFillColorAlt('blue') ?? 'blue',\n                  lines: this.getBinTooltips(findbin) };\n\n      if (pnt.disabled) {\n         // case when tooltip should not highlight bin\n\n         ttrect.remove();\n         res.changed = true;\n      } else if (show_rect) {\n         if (ttrect.empty()) {\n            ttrect = this.draw_g.append('svg:rect')\n                                .attr('class', 'tooltip_bin')\n                                .style('pointer-events', 'none')\n                                .call(addHighlightStyle);\n         }\n\n         res.changed = ttrect.property('current_bin') !== findbin;\n\n         if (res.changed) {\n            ttrect.attr('x', pmain.swap_xy ? gry1 : grx1)\n                  .attr('width', pmain.swap_xy ? gry2-gry1 : grx2-grx1)\n                  .attr('y', pmain.swap_xy ? grx1 : gry1)\n                  .attr('height', pmain.swap_xy ? grx2-grx1 : gry2-gry1)\n                  .style('opacity', '0.3')\n                  .property('current_bin', findbin);\n         }\n\n         res.exact = (Math.abs(midy - pnt_y) <= 5) || ((pnt_y>=gry1) && (pnt_y<=gry2));\n\n         res.menu = res.exact; // one could show context menu\n         // distance to middle point, use to decide which menu to activate\n         res.menu_dist = Math.sqrt((midx-pnt_x)**2 + (midy-pnt_y)**2);\n      } else {\n         const radius = this.lineatt.width + 3;\n\n         if (ttrect.empty()) {\n            ttrect = this.draw_g.append('svg:circle')\n                                .attr('class', 'tooltip_bin')\n                                .style('pointer-events', 'none')\n                                .attr('r', radius)\n                                .call(this.lineatt.func)\n                                .call(this.fillatt.func);\n         }\n\n         res.exact = (Math.abs(midx - pnt.x) <= radius) && (Math.abs(midy - pnt.y) <= radius);\n\n         res.menu = res.exact; // show menu only when mouse pointer exactly over the histogram\n         res.menu_dist = Math.sqrt((midx-pnt.x)**2 + (midy-pnt.y)**2);\n\n         res.changed = ttrect.property('current_bin') !== findbin;\n\n         if (res.changed) {\n            ttrect.attr('cx', midx)\n                  .attr('cy', midy)\n                  .property('current_bin', findbin);\n         }\n      }\n\n      if (res.changed) {\n         res.user_info = { obj: histo, name: 'histo',\n                           bin: findbin, cont: histo.getBinContent(findbin+1),\n                           grx: midx, gry: midy };\n      }\n\n      return res;\n   }\n\n   /** @summary Fill histogram context menu */\n   fillHistContextMenu(menu) {\n      menu.add('Auto zoom-in', () => this.autoZoom());\n\n      const opts = this.getSupportedDrawOptions();\n\n      menu.addDrawMenu('Draw with', opts, arg => {\n         if (arg.indexOf(kInspect) === 0)\n            return this.showInspector(arg);\n\n         this.decodeOptions(arg); // obsolete, should be implemented differently\n\n         if (this.options.need_fillcol && this.fillatt?.empty())\n            this.fillatt.change(5, 1001);\n\n         // redraw all objects\n         this.interactiveRedraw('pad', 'drawopt');\n      });\n   }\n\n   /** @summary Perform automatic zoom inside non-zero region of histogram */\n   autoZoom() {\n      let left = this.getSelectIndex('x', 'left', -1),\n          right = this.getSelectIndex('x', 'right', 1);\n      const dist = right - left, histo = this.getHisto(), xaxis = this.getAxis('x');\n\n      if (dist === 0) return;\n\n      // first find minimum\n      let min = histo.getBinContent(left + 1);\n      for (let indx = left; indx < right; ++indx)\n         min = Math.min(min, histo.getBinContent(indx+1));\n      if (min > 0) return; // if all points positive, no chance for autoscale\n\n      while ((left < right) && (histo.getBinContent(left+1) <= min)) ++left;\n      while ((left < right) && (histo.getBinContent(right) <= min)) --right;\n\n      // if singular bin\n      if ((left === right-1) && (left > 2) && (right < this.nbinsx-2)) {\n         --left; ++right;\n      }\n\n      if ((right - left < dist) && (left < right))\n         return this.getFramePainter().zoom(xaxis.GetBinCoord(left), xaxis.GetBinCoord(right));\n   }\n\n   /** @summary Checks if it makes sense to zoom inside specified axis range */\n   canZoomInside(axis, min, max) {\n      const xaxis = this.getAxis('x');\n\n      if ((axis === 'x') && (xaxis.FindBin(max, 0.5) - xaxis.FindBin(min, 0) > 1)) return true;\n\n      if ((axis === 'y') && (Math.abs(max-min) > Math.abs(this.ymax-this.ymin)*1e-6)) return true;\n\n      return false;\n   }\n\n   /** @summary Call appropriate draw function */\n   async callDrawFunc(reason) {\n      const main = this.getFramePainter();\n\n      if (main && (main.mode3d !== this.options.Mode3D) && !this.isMainPainter())\n         this.options.Mode3D = main.mode3d;\n\n      return this.options.Mode3D ? this.draw3D(reason) : this.draw2D(reason);\n   }\n\n   /** @summary Draw in 2d */\n   async draw2D(reason) {\n      this.clear3DScene();\n\n      return this.drawFrameAxes().then(res => {\n         return res ? this.drawingBins(reason) : false;\n      }).then(res => {\n         if (res)\n            return this.draw1DBins().then(() => this.addInteractivity());\n      }).then(() => this);\n   }\n\n   /** @summary Draw in 3d */\n   async draw3D(reason) {\n      console.log('3D drawing is disabled, load ./hist/RH1Painter.mjs');\n      return this.draw2D(reason);\n   }\n\n   /** @summary Readraw histogram */\n   async redraw(reason) {\n      return this.callDrawFunc(reason);\n   }\n\n   static async _draw(painter, opt) {\n      return ensureRCanvas(painter).then(() => {\n         painter.setAsMainPainter();\n\n         painter.options = { Hist: false, Bar: false, BarStyle: 0,\n                             Error: false, ErrorKind: -1, errorX: gStyle.fErrorX,\n                             Zero: false, Mark: false,\n                             Line: false, Fill: false, Lego: 0, Surf: 0,\n                             Text: false, TextAngle: 0, TextKind: '', AutoColor: 0,\n                             BarOffset: 0, BarWidth: 1, BaseLine: false,\n                             Mode3D: false, FrontBox: false, BackBox: false };\n\n         const d = new DrawOptions(opt);\n         if (d.check('R3D_', true))\n            painter.options.Render3D = constants.Render3D.fromString(d.part.toLowerCase());\n\n         const kind = painter.v7EvalAttr('kind', 'hist'),\n             sub = painter.v7EvalAttr('sub', 0),\n             has_main = !!painter.getMainPainter(),\n             o = painter.options;\n\n         o.Text = painter.v7EvalAttr('drawtext', false);\n         o.BarOffset = painter.v7EvalAttr('baroffset', 0.0);\n         o.BarWidth = painter.v7EvalAttr('barwidth', 1.0);\n         o.second_x = has_main && painter.v7EvalAttr('secondx', false);\n         o.second_y = has_main && painter.v7EvalAttr('secondy', false);\n\n         switch (kind) {\n            case 'bar': o.Bar = true; o.BarStyle = sub; break;\n            case 'err': o.Error = true; o.ErrorKind = sub; break;\n            case 'p': o.Mark = true; break;\n            case 'l': o.Line = true; break;\n            case 'lego': o.Lego = sub > 0 ? 10+sub : 12; o.Mode3D = true; break;\n            default: o.Hist = true;\n         }\n\n         painter.scanContent();\n\n         return painter.callDrawFunc();\n      });\n   }\n\n   /** @summary draw RH1 object */\n   static async draw(dom, histo, opt) {\n      return RH1Painter._draw(new RH1Painter(dom, histo), opt);\n   }\n\n} // class RH1Painter\n\nexport { RH1Painter };\n","import { settings, gStyle } from '../core.mjs';\nimport { RH1Painter as RH1Painter2D } from '../hist2d/RH1Painter.mjs';\nimport { RAxisPainter } from '../gpad/RAxisPainter.mjs';\nimport { assignFrame3DMethods, drawBinsLego } from './hist3d.mjs';\n\n\nclass RH1Painter extends RH1Painter2D {\n\n   /** @summary Draw 1-D histogram in 3D mode */\n   draw3D(reason) {\n      this.mode3d = true;\n\n      const main = this.getFramePainter(), // who makes axis drawing\n            is_main = this.isMainPainter(), // is main histogram\n            zmult = 1 + 2*gStyle.fHistTopMargin;\n      let pr = Promise.resolve(this);\n\n      if (reason === 'resize') {\n         if (is_main && main.resize3D()) main.render3D();\n         return pr;\n      }\n\n      this.deleteAttr();\n\n      this.scanContent(true); // may be required for axis drawings\n\n      if (is_main) {\n         assignFrame3DMethods(main);\n         pr = main.create3DScene(this.options.Render3D).then(() => {\n            main.setAxesRanges(this.getAxis('x'), this.xmin, this.xmax, null, this.ymin, this.ymax, null, 0, 0);\n            main.set3DOptions(this.options);\n            main.drawXYZ(main.toplevel, RAxisPainter, { use_y_for_z: true, zmult, zoom: settings.Zooming, ndim: 1, draw: true, v7: true });\n         });\n      }\n\n      if (!main.mode3d)\n         return pr;\n\n      return pr.then(() => this.drawingBins(reason)).then(() => {\n         // called when bins received from server, must be reentrant\n         const main = this.getFramePainter();\n\n         drawBinsLego(this, true);\n         this.updatePaletteDraw();\n         main.render3D();\n         main.addKeysHandler();\n         return this;\n      });\n   }\n\n      /** @summary draw RH1 object */\n   static async draw(dom, histo, opt) {\n      return RH1Painter._draw(new RH1Painter(dom, histo), opt);\n   }\n\n} // class RH1Painter\n\nexport { RH1Painter };\n"],"x_google_ignoreList":[0,1]}