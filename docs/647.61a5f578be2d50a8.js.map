{"version":3,"file":"647.61a5f578be2d50a8.js","mappings":"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","names":["TASImagePainter","ObjectPainter","decodeOptions","opt","this","options","Zscale","indexOf","createRGBA","nlevels","obj","getObject","fPalette","rgba","Array","indx","pal","lvl","l","fPoints","length","r1","r2","Math","min","round","fColorRed","fColorGreen","fColorBlue","fColorAlpha","makeUrlFromImageBuf","fp","_this","fImgBuf","max","k","v","fContour","arr","getLevels","getPaletteColor","zval","toHex","xmin","xmax","fWidth","ymin","ymax","fHeight","zoom_xmin","zoom_xmax","zoom_ymin","zoom_ymax","isNodeJs","__webpack_require__","then","h","default","createCanvas","Promise","resolveFunc","c","document","createElement","width","height","canvas","context","getContext","imageData","getImageData","data","i","dst","row","j","iii","putImageData","url","toDataURL","constRatio","fConstRatio","is_buf","makeUrlFromPngBuf","buf","fPngBuf","pngbuf","isStr","String","fromCharCode","btoa_func","drawImage","promise","_this2","getFramePainter","rect","getFrameRect","getPadPainter","getPadRect","wheel_zoomy","_blob","console","error","fImageQuality","fImageCompression","_typename","fUniqueID","fBits","fNumPoints","resolve","res","createG","append","attr","isMainPainter","drawColorPalette","setAxesRanges","create","clTAxis","createXY","ndim","check_pad_range","addInteractivity","canZoomInside","axis","enabled","can_move","_this3","draw_palette","clTPaletteAxis","Object","assign","fX1NDC","fX2NDC","fY1NDC","fY2NDC","fInit","fAxis","fChopt","pal_painter","findPainterFor","Enabled","removeG","frame_painter","drawPave","prev_name","selectCurrentPad","getPadName","TPavePainter","getDom","p","$secondary","redraw","toggleColz","reason","img","draw_g","select","empty","getFrameWidth","getFrameHeight","clickButton","funcname","fillToolbar","pp","addPadButton","showPadButtons","static","dom","painter","ensureTCanvas"],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/draw/TASImagePainter.mjs"],"sourcesContent":["import { create, isNodeJs, isStr, btoa_func, clTPave, clTGaxis, clTAxis, clTPaletteAxis } from '../core.mjs';\nimport { toHex } from '../base/colors.mjs';\nimport { ObjectPainter } from '../base/ObjectPainter.mjs';\nimport { TPavePainter } from '../hist/TPavePainter.mjs';\nimport { ensureTCanvas } from '../gpad/TCanvasPainter.mjs';\n\n/**\n * @summary Painter for TASImage object.\n *\n * @private\n */\n\nclass TASImagePainter extends ObjectPainter {\n\n   /** @summary Decode options string  */\n   decodeOptions(opt) {\n      this.options = { Zscale: false };\n\n      if (opt && (opt.indexOf('z') >= 0)) this.options.Zscale = true;\n   }\n\n   /** @summary Create RGBA buffers */\n   createRGBA(nlevels) {\n      let obj = this.getObject();\n\n      if (!obj?.fPalette) return null;\n\n      let rgba = new Array((nlevels+1) * 4), indx = 1, pal = obj.fPalette; // precaclucated colors\n\n      for(let lvl = 0; lvl <= nlevels; ++lvl) {\n         let l = 1.*lvl/nlevels;\n         while ((pal.fPoints[indx] < l) && (indx < pal.fPoints.length-1)) indx++;\n\n         let r1 = (pal.fPoints[indx] - l) / (pal.fPoints[indx] - pal.fPoints[indx-1]),\n             r2 = (l - pal.fPoints[indx-1]) / (pal.fPoints[indx] - pal.fPoints[indx-1]);\n\n         rgba[lvl*4]   = Math.min(255, Math.round((pal.fColorRed[indx-1] * r1 + pal.fColorRed[indx] * r2) / 256));\n         rgba[lvl*4+1] = Math.min(255, Math.round((pal.fColorGreen[indx-1] * r1 + pal.fColorGreen[indx] * r2) / 256));\n         rgba[lvl*4+2] = Math.min(255, Math.round((pal.fColorBlue[indx-1] * r1 + pal.fColorBlue[indx] * r2) / 256));\n         rgba[lvl*4+3] = Math.min(255, Math.round((pal.fColorAlpha[indx-1] * r1 + pal.fColorAlpha[indx] * r2) / 256));\n      }\n\n      return rgba;\n   }\n\n   /** @summary Create url using image buffer\n     * @private */\n   async makeUrlFromImageBuf(obj, fp) {\n\n      let nlevels = 1000;\n      this.rgba = this.createRGBA(nlevels); // precaclucated colors\n\n      let min = obj.fImgBuf[0], max = obj.fImgBuf[0];\n      for (let k = 1; k < obj.fImgBuf.length; ++k) {\n         let v = obj.fImgBuf[k];\n         min = Math.min(v, min);\n         max = Math.max(v, max);\n      }\n\n      // does not work properly in Node.js, causes 'Maximum call stack size exceeded' error\n      // min = Math.min.apply(null, obj.fImgBuf),\n      // max = Math.max.apply(null, obj.fImgBuf);\n\n      // create countor like in hist painter to allow palette drawing\n      this.fContour = {\n         arr: new Array(200),\n         rgba: this.rgba,\n         getLevels() { return this.arr; },\n         getPaletteColor(pal, zval) {\n            if (!this.arr || !this.rgba) return 'white';\n            let indx = Math.round((zval - this.arr[0]) / (this.arr[this.arr.length-1] - this.arr[0]) * (this.rgba.length-4)/4) * 4;\n            return '#' + toHex(this.rgba[indx],1) + toHex(this.rgba[indx+1],1) + toHex(this.rgba[indx+2],1) + toHex(this.rgba[indx+3],1);\n         }\n      };\n      for (let k = 0; k < 200; k++)\n         this.fContour.arr[k] = min + (max-min)/(200-1)*k;\n\n      if (min >= max) max = min + 1;\n\n      let xmin = 0, xmax = obj.fWidth, ymin = 0, ymax = obj.fHeight; // dimension in pixels\n\n      if (fp && (fp.zoom_xmin != fp.zoom_xmax)) {\n         xmin = Math.round(fp.zoom_xmin * obj.fWidth);\n         xmax = Math.round(fp.zoom_xmax * obj.fWidth);\n      }\n\n      if (fp && (fp.zoom_ymin != fp.zoom_ymax)) {\n         ymin = Math.round(fp.zoom_ymin * obj.fHeight);\n         ymax = Math.round(fp.zoom_ymax * obj.fHeight);\n      }\n\n      let pr = isNodeJs() ?\n                 import('canvas').then(h => h.default.createCanvas(xmax - xmin, ymax - ymin)) :\n                 new Promise(resolveFunc => {\n                    let c = document.createElement('canvas');\n                    c.width = xmax - xmin;\n                    c.height = ymax - ymin;\n                    resolveFunc(c);\n                 });\n\n      return pr.then(canvas => {\n\n         let context = canvas.getContext('2d'),\n             imageData = context.getImageData(0, 0, canvas.width, canvas.height),\n             arr = imageData.data;\n\n         for(let i = ymin; i < ymax; ++i) {\n            let dst = (ymax - i - 1) * (xmax - xmin) * 4,\n                row = i * obj.fWidth;\n            for(let j = xmin; j < xmax; ++j) {\n               let iii = Math.round((obj.fImgBuf[row + j] - min) / (max - min) * nlevels) * 4;\n               // copy rgba value for specified point\n               arr[dst++] = this.rgba[iii++];\n               arr[dst++] = this.rgba[iii++];\n               arr[dst++] = this.rgba[iii++];\n               arr[dst++] = this.rgba[iii++];\n            }\n         }\n\n         context.putImageData(imageData, 0, 0);\n\n         return { url: canvas.toDataURL(), constRatio: obj.fConstRatio, is_buf: true };\n      });\n   }\n\n   /** @summary Produce data url from png data */\n   async makeUrlFromPngBuf(obj) {\n      let buf = obj.fPngBuf, pngbuf = '';\n\n      if (isStr(buf))\n         pngbuf = buf;\n      else\n         for (let k = 0; k < buf.length; ++k)\n            pngbuf += String.fromCharCode(buf[k] < 0 ? 256 + buf[k] : buf[k]);\n\n      return { url: 'data:image/png;base64,' + btoa_func(pngbuf), constRatio: true };\n   }\n\n   /** @summary Draw image */\n   async drawImage() {\n      let obj = this.getObject(),\n          fp = this.getFramePainter(),\n          rect = fp ? fp.getFrameRect() : this.getPadPainter().getPadRect();\n\n      this.wheel_zoomy = true;\n\n      if (obj._blob) {\n         // try to process blob data due to custom streamer\n         if ((obj._blob.length == 15) && !obj._blob[0]) {\n            obj.fImageQuality = obj._blob[1];\n            obj.fImageCompression = obj._blob[2];\n            obj.fConstRatio = obj._blob[3];\n            obj.fPalette = {\n                _typename: 'TImagePalette',\n                fUniqueID: obj._blob[4],\n                fBits: obj._blob[5],\n                fNumPoints: obj._blob[6],\n                fPoints: obj._blob[7],\n                fColorRed: obj._blob[8],\n                fColorGreen: obj._blob[9],\n                fColorBlue: obj._blob[10],\n                fColorAlpha: obj._blob[11]\n            };\n\n            obj.fWidth = obj._blob[12];\n            obj.fHeight = obj._blob[13];\n            obj.fImgBuf = obj._blob[14];\n\n            if ((obj.fWidth * obj.fHeight != obj.fImgBuf.length) ||\n                  (obj.fPalette.fNumPoints != obj.fPalette.fPoints.length)) {\n               console.error(`TASImage _blob decoding error ${obj.fWidth * obj.fHeight} != ${obj.fImgBuf.length} ${obj.fPalette.fNumPoints} != ${obj.fPalette.fPoints.length}`);\n               delete obj.fImgBuf;\n               delete obj.fPalette;\n            }\n\n         } else if ((obj._blob.length == 3) && obj._blob[0]) {\n            obj.fPngBuf = obj._blob[2];\n            if (obj.fPngBuf?.length != obj._blob[1]) {\n               console.error(`TASImage with png buffer _blob error ${obj._blob[1]} != ${obj.fPngBuf?.length}`);\n               delete obj.fPngBuf;\n            }\n         } else {\n            console.error(`TASImage _blob len ${obj._blob.length} not recognized`);\n         }\n\n         delete obj._blob;\n      }\n\n      let promise;\n\n      if (obj.fImgBuf && obj.fPalette) {\n         promise = this.makeUrlFromImageBuf(obj, fp);\n      } else if (obj.fPngBuf) {\n         promise = this.makeUrlFromPngBuf(obj);\n      } else {\n         promise = Promise.resolve({});\n      }\n\n      return promise.then(res => {\n\n         if (res.url)\n            this.createG(fp ? true : false)\n                .append('image')\n                .attr('href', res.url)\n                .attr('width', rect.width)\n                .attr('height', rect.height)\n                .attr('preserveAspectRatio', res.constRatio ? null : 'none');\n\n         if (!res.url || !this.isMainPainter() || !res.is_buf || !fp)\n            return this;\n\n         return this.drawColorPalette(this.options.Zscale, true).then(() => {\n            fp.setAxesRanges(create(clTAxis), 0, 1, create(clTAxis), 0, 1, null, 0, 0);\n            fp.createXY({ ndim: 2, check_pad_range: false });\n            return fp.addInteractivity();\n         })\n      });\n   }\n\n   /** @summary Checks if it makes sense to zoom inside specified axis range */\n   canZoomInside(axis,min,max) {\n      let obj = this.getObject();\n\n      if (!obj?.fImgBuf)\n         return false;\n\n      if ((axis == 'x') && ((max - min) * obj.fWidth > 3)) return true;\n\n      if ((axis == 'y') && ((max - min) * obj.fHeight > 3)) return true;\n\n      return false;\n   }\n\n   /** @summary Draw color palette\n     * @private */\n   async drawColorPalette(enabled, can_move) {\n\n      if (!this.isMainPainter())\n         return null;\n\n      if (!this.draw_palette) {\n         let pal = create(clTPaletteAxis);\n         Object.assign(pal, { fX1NDC: 0.91, fX2NDC: 0.95, fY1NDC: 0.1, fY2NDC: 0.9, fInit: 1 });\n         pal.fAxis.fChopt = '+';\n         this.draw_palette = pal;\n         this.fPalette = true; // to emulate behaviour of hist painter\n      }\n\n      let pal_painter = this.getPadPainter().findPainterFor(this.draw_palette);\n\n      if (!enabled) {\n         if (pal_painter) {\n            pal_painter.Enabled = false;\n            pal_painter.removeG(); // completely remove drawing without need to redraw complete pad\n         }\n         return null;\n      }\n\n      let frame_painter = this.getFramePainter();\n\n      // keep palette width\n      if (can_move && frame_painter) {\n         let pal = this.draw_palette;\n         pal.fX2NDC = frame_painter.fX2NDC + 0.01 + (pal.fX2NDC - pal.fX1NDC);\n         pal.fX1NDC = frame_painter.fX2NDC + 0.01;\n         pal.fY1NDC = frame_painter.fY1NDC;\n         pal.fY2NDC = frame_painter.fY2NDC;\n      }\n\n      if (pal_painter) {\n         pal_painter.Enabled = true;\n         return pal_painter.drawPave('');\n      }\n\n\n      let prev_name = this.selectCurrentPad(this.getPadName());\n\n      return TPavePainter.draw(this.getDom(), this.draw_palette).then(p => {\n\n         pal_painter = p;\n\n         this.selectCurrentPad(prev_name);\n         // mark painter as secondary - not in list of TCanvas primitives\n         pal_painter.$secondary = true;\n\n         // make dummy redraw, palette will be updated only from histogram painter\n         pal_painter.redraw = function() {};\n      });\n   }\n\n   /** @summary Toggle colz draw option\n     * @private */\n   toggleColz() {\n      let obj = this.getObject(),\n          can_toggle = obj && obj.fPalette;\n\n      if (can_toggle) {\n         this.options.Zscale = !this.options.Zscale;\n         this.drawColorPalette(this.options.Zscale, true);\n      }\n   }\n\n   /** @summary Redraw image */\n   redraw(reason) {\n      let img = this.draw_g ? this.draw_g.select('image') : null,\n          fp = this.getFramePainter();\n\n      if (img && !img.empty() && (reason !== 'zoom') && fp) {\n         img.attr('width', fp.getFrameWidth()).attr('height', fp.getFrameHeight());\n      } else {\n         return this.drawImage();\n      }\n   }\n\n   /** @summary Process click on TASImage-defined buttons */\n   clickButton(funcname) {\n      if (!this.isMainPainter()) return false;\n\n      switch(funcname) {\n         case 'ToggleColorZ': this.toggleColz(); break;\n         default: return false;\n      }\n\n      return true;\n   }\n\n   /** @summary Fill pad toolbar for TASImage */\n   fillToolbar() {\n      let pp = this.getPadPainter(), obj = this.getObject();\n      if (pp && obj?.fPalette) {\n         pp.addPadButton('th2colorz', 'Toggle color palette', 'ToggleColorZ');\n         pp.showPadButtons();\n      }\n   }\n\n   /** @summary Draw TASImage object */\n   static async draw(dom, obj, opt) {\n      let painter = new TASImagePainter(dom, obj, opt);\n      painter.decodeOptions(opt);\n      return ensureTCanvas(painter, false)\n                 .then(() => painter.drawImage())\n                 .then(() => {\n                     painter.fillToolbar();\n                     return painter;\n                 });\n   }\n\n} // class TASImagePainter\n\nexport { TASImagePainter };\n"],"x_google_ignoreList":[0]}