{"version":3,"file":"18.53db17338b338e15.js","mappings":"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","names":["RH1Painter","RHistPainter","constructor","dom","histo","super","this","wheel_zoomy","scanContent","when_axis_changed","getHisto","nbinsx","extractAxesProperties","hmin","hmin_nz","hmax","hsum","isDisplayItem","fContMin","fContMinPos","fContMax","left","getSelectIndex","right","scan_xleft","scan_xright","value","err","first","i","getBinContent","Math","min","max","stat_entries","ymin_nz","draw_content","abs","ymin","ymax","dy","countStat","cond","xaxis","getAxis","stat_sumw","stat_sumwx","stat_sumwx2","xx","w","xmax","wmax","res","getFramePainter","name","meanx","meany","rmsx","rmsy","integral","entries","GetBinCoord","sqrt","fillStatistic","stat","dostat","data","print_name","print_entries","floor","print_mean","print_rms","print_under","print_over","print_integral","print_skew","print_kurt","clearStat","addText","format","drawBars","handle","funcs","width","height","_this","createG","x1","x2","grx1","grx2","y","gry1","gry2","i1","i2","di","stepi","pmain","bars","barsl","barsr","swap_xy","Number","isFinite","options","BaseLine","scale_ymin","round","gry","logx","grx","logy","BarOffset","BarWidth","BarStyle","fillatt","empty","setSolidColor","draw_g","append","attr","call","func","style","d3_rgb","color","brighter","formatHex","darker","drawFilledErrors","_this2","x","yerr","bins1","bins2","getBinError","push","unshift","kind","ErrorKind","path1","buildSvgPath","path2","path","draw1DBins","_this3","rect","getFrameRect","removeG","createHistDrawAttributes","prepareDraw","extra","only_indexes","getGrFuncs","second_x","second_y","Bar","drawHistBins","_this4","startx","currx","curry","curry_min","curry_max","prevy","prevx","bestimin","bestimax","my","yerr1","yerr2","bincont","binerr","mx1","mx2","midx","text_font","want_tooltip","isBatchMode","settings","lastbin","exclude_zero","Zero","show_errors","Error","show_markers","Mark","show_line","Line","show_text","Text","path_fill","path_err","path_marker","path_line","hints_err","endx","endy","dend","v7EvalAttr","createv7AttMarker","markeratt","size","resetPos","v7EvalFont","align","angle","TextKind","space","setAngle","setSize","startTextDrawing","use_minmax","lw","lineatt","gStyle","draw_markers","draw_bin","besti","lbl","toString","floatToString","drawText","text","latex","length","create","edx","errorX","mmx1","close_path","fill_for_interactive","Hist","h0","gry0","Fill","finishTextDrawing","getBinTooltips","bin","tips","getObjectHint","stepx","cont","xlbl","getAxisBinTip","axisAsText","toPrecision","$baseh","processTooltipEvent","pnt","Mode3D","select","remove","show_rect","midy","getFrameWidth","getFrameHeight","findbin","gapx","l","r","GetBinGrX","GetBinGrY","yy","pnt_x","pnt_y","m","best","dist","touch","nproc","msize","getFullSize","dx","ttrect","title","fTitle","exact","color1","color2","getFillColorAlt","lines","disabled","changed","property","menu","menu_dist","radius","user_info","obj","fillHistContextMenu","add","autoZoom","opts","getSupportedDrawOptions","addDrawMenu","arg","showInspector","decodeOptions","need_fillcol","change","interactiveRedraw","indx","zoom","canZoomInside","axis","FindBin","callDrawFunc","reason","main","_this5","mode3d","isMainPainter","draw3D","draw2D","clear3DScene","_this6","drawFrameAxes","then","drawingBins","addInteractivity","console","log","_this7","redraw","_this8","static","painter","opt","ensureRCanvas","setAsMainPainter","Lego","Surf","TextAngle","AutoColor","d","DrawOptions","check","Render3D","constants","part","toLowerCase","sub","has_main","getMainPainter","o","_draw","RH1Painter2D","is_main","zmult","pr","Promise","resolve","resize3D","render3D","deleteAttr","assignFrame3DMethods","create3DScene","setAxesRanges","xmin","set3DOptions","drawXYZ","toplevel","RAxisPainter","use_y_for_z","ndim","draw","v7","drawBinsLego","updatePaletteDraw","addKeysHandler"],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/hist2d/RH1Painter.mjs","../node_modules/jsroot/modules/hist/RH1Painter.mjs"],"sourcesContent":["import { gStyle, settings, constants, isBatchMode } from '../core.mjs';\nimport { rgb as d3_rgb } from '../d3.mjs';\nimport { floatToString, DrawOptions, buildSvgPath } from '../base/BasePainter.mjs';\nimport { RHistPainter } from './RHistPainter.mjs';\nimport { ensureRCanvas } from '../gpad/RCanvasPainter.mjs';\n\n/**\n * @summary Painter for RH1 classes\n *\n * @private\n */\n\nclass RH1Painter extends RHistPainter {\n\n   /** @summary Constructor\n     * @param {object|string} dom - DOM element or id\n     * @param {object} histo - histogram object */\n   constructor(dom, histo) {\n      super(dom, histo);\n      this.wheel_zoomy = false;\n   }\n\n   /** @summary Scan content */\n   scanContent(when_axis_changed) {\n      // if when_axis_changed === true specified, content will be scanned after axis zoom changed\n\n      let histo = this.getHisto();\n      if (!histo) return;\n\n      if (!this.nbinsx && when_axis_changed) when_axis_changed = false;\n\n      if (!when_axis_changed)\n         this.extractAxesProperties(1);\n\n      let hmin = 0, hmin_nz = 0, hmax = 0, hsum = 0;\n\n      if (this.isDisplayItem()) {\n         // take min/max values from the display item\n         hmin = histo.fContMin;\n         hmin_nz = histo.fContMinPos;\n         hmax = histo.fContMax;\n         hsum = hmax;\n      } else {\n\n         let left = this.getSelectIndex('x', 'left'),\n             right = this.getSelectIndex('x', 'right');\n\n         if (when_axis_changed) {\n            if ((left === this.scan_xleft) && (right === this.scan_xright)) return;\n         }\n\n         this.scan_xleft = left;\n         this.scan_xright = right;\n\n         let first = true, value, err;\n\n         for (let i = 0; i < this.nbinsx; ++i) {\n            value = histo.getBinContent(i+1);\n            hsum += value;\n\n            if ((i<left) || (i>=right)) continue;\n\n            if (value > 0)\n               if ((hmin_nz == 0) || (value<hmin_nz)) hmin_nz = value;\n            if (first) {\n               hmin = hmax = value;\n               first = false;\n            }\n\n            err =  0;\n\n            hmin = Math.min(hmin, value - err);\n            hmax = Math.max(hmax, value + err);\n         }\n      }\n\n      this.stat_entries = hsum;\n\n      this.hmin = hmin;\n      this.hmax = hmax;\n\n      this.ymin_nz = hmin_nz; // value can be used to show optimal log scale\n\n      if ((this.nbinsx == 0) || ((Math.abs(hmin) < 1e-300 && Math.abs(hmax) < 1e-300))) {\n         this.draw_content = false;\n      } else {\n         this.draw_content = true;\n      }\n\n      if (this.draw_content) {\n         if (hmin >= hmax) {\n            if (hmin == 0) { this.ymin = 0; this.ymax = 1; }\n            else if (hmin < 0) { this.ymin = 2 * hmin; this.ymax = 0; }\n            else { this.ymin = 0; this.ymax = hmin * 2; }\n         } else {\n            let dy = (hmax - hmin) * 0.05;\n            this.ymin = hmin - dy;\n            if ((this.ymin < 0) && (hmin >= 0)) this.ymin = 0;\n            this.ymax = hmax + dy;\n         }\n      }\n   }\n\n   /** @summary Count statistic */\n   countStat(cond) {\n      let histo = this.getHisto(), xaxis = this.getAxis('x'),\n          left = this.getSelectIndex('x', 'left'),\n          right = this.getSelectIndex('x', 'right'),\n          stat_sumw = 0, stat_sumwx = 0, stat_sumwx2 = 0, stat_sumwy = 0, stat_sumwy2 = 0,\n          i, xx = 0, w = 0, xmax = null, wmax = null,\n          fp = this.getFramePainter(),\n          res = { name: 'histo', meanx: 0, meany: 0, rmsx: 0, rmsy: 0, integral: 0, entries: this.stat_entries, xmax: 0, wmax: 0 };\n\n      for (i = left; i < right; ++i) {\n         xx = xaxis.GetBinCoord(i+0.5);\n\n         if (cond && !cond(xx)) continue;\n\n         w = histo.getBinContent(i + 1);\n\n         if ((xmax === null) || (w > wmax)) { xmax = xx; wmax = w; }\n\n         stat_sumw += w;\n         stat_sumwx += w * xx;\n         stat_sumwx2 += w * xx**2;\n      }\n\n      res.integral = stat_sumw;\n\n      if (Math.abs(stat_sumw) > 1e-300) {\n         res.meanx = stat_sumwx / stat_sumw;\n         res.meany = stat_sumwy / stat_sumw;\n         res.rmsx = Math.sqrt(Math.abs(stat_sumwx2 / stat_sumw - res.meanx**2));\n         res.rmsy = Math.sqrt(Math.abs(stat_sumwy2 / stat_sumw - res.meany**2));\n      }\n\n      if (xmax !== null) {\n         res.xmax = xmax;\n         res.wmax = wmax;\n      }\n\n      return res;\n   }\n\n   /** @summary Fill statistic */\n   fillStatistic(stat, dostat/*, dofit*/) {\n\n      let data = this.countStat(),\n          print_name = dostat % 10,\n          print_entries = Math.floor(dostat / 10) % 10,\n          print_mean = Math.floor(dostat / 100) % 10,\n          print_rms = Math.floor(dostat / 1000) % 10,\n          print_under = Math.floor(dostat / 10000) % 10,\n          print_over = Math.floor(dostat / 100000) % 10,\n          print_integral = Math.floor(dostat / 1000000) % 10,\n          print_skew = Math.floor(dostat / 10000000) % 10,\n          print_kurt = Math.floor(dostat / 100000000) % 10;\n\n      // make empty at the beginning\n      stat.clearStat();\n\n      if (print_name > 0)\n         stat.addText(data.name);\n\n      if (print_entries > 0)\n         stat.addText('Entries = ' + stat.format(data.entries,'entries'));\n\n      if (print_mean > 0)\n         stat.addText('Mean = ' + stat.format(data.meanx));\n\n      if (print_rms > 0)\n         stat.addText('Std Dev = ' + stat.format(data.rmsx));\n\n      if (print_under > 0)\n         stat.addText('Underflow = ' + stat.format(histo.getBinContent(0), 'entries'));\n\n      if (print_over > 0)\n         stat.addText('Overflow = ' + stat.format(histo.getBinContent(this.nbinsx+1), 'entries'));\n\n      if (print_integral > 0)\n         stat.addText('Integral = ' + stat.format(data.integral,'entries'));\n\n      if (print_skew > 0)\n         stat.addText('Skew = <not avail>');\n\n      if (print_kurt > 0)\n         stat.addText('Kurt = <not avail>');\n\n      return true;\n   }\n\n   /** @summary Draw histogram as bars */\n   async drawBars(handle, funcs, width, height) {\n\n      this.createG(true);\n\n      let left = handle.i1, right = handle.i2, di = handle.stepi,\n          pmain = this.getFramePainter(),\n          histo = this.getHisto(), xaxis = this.getAxis('x'),\n          i, x1, x2, grx1, grx2, y, gry1, gry2, w,\n          bars = '', barsl = '', barsr = '';\n\n      gry2 = pmain.swap_xy ? 0 : height;\n      if (Number.isFinite(this.options.BaseLine))\n         if (this.options.BaseLine >= funcs.scale_ymin)\n            gry2 = Math.round(funcs.gry(this.options.BaseLine));\n\n      for (i = left; i < right; i += di) {\n         x1 = xaxis.GetBinCoord(i);\n         x2 = xaxis.GetBinCoord(i+di);\n\n         if (funcs.logx && (x2 <= 0)) continue;\n\n         grx1 = Math.round(funcs.grx(x1));\n         grx2 = Math.round(funcs.grx(x2));\n\n         y = histo.getBinContent(i+1);\n         if (funcs.logy && (y < funcs.scale_ymin)) continue;\n         gry1 = Math.round(funcs.gry(y));\n\n         w = grx2 - grx1;\n         grx1 += Math.round(this.options.BarOffset*w);\n         w = Math.round(this.options.BarWidth*w);\n\n         if (pmain.swap_xy)\n            bars += `M${gry2},${grx1}h${gry1-gry2}v${w}h${gry2-gry1}z`;\n         else\n            bars += `M${grx1},${gry1}h${w}v${gry2-gry1}h${-w}z`;\n\n         if (this.options.BarStyle > 0) {\n            grx2 = grx1 + w;\n            w = Math.round(w / 10);\n            if (pmain.swap_xy) {\n               barsl += `M${gry2},${grx1}h${gry1-gry2}v${w}h${gry2-gry1}z`;\n               barsr += `M${gry2},${grx2}h${gry1-gry2}v${-w}h${gry2-gry1}z`;\n            } else {\n               barsl += `M${grx1},${gry1}h${w}v${gry2-gry1}h${-w}z`;\n               barsr += `M${grx2},${gry1}h${-w}v${gry2-gry1}h${w}z`;\n            }\n         }\n      }\n\n      if (this.fillatt.empty()) this.fillatt.setSolidColor('blue');\n\n      if (bars)\n         this.draw_g.append('svg:path')\n                    .attr('d', bars)\n                    .call(this.fillatt.func);\n\n      if (barsl)\n         this.draw_g.append('svg:path')\n               .attr('d', barsl)\n               .call(this.fillatt.func)\n               .style('fill', d3_rgb(this.fillatt.color).brighter(0.5).formatHex());\n\n      if (barsr)\n         this.draw_g.append('svg:path')\n               .attr('d', barsr)\n               .call(this.fillatt.func)\n               .style('fill', d3_rgb(this.fillatt.color).darker(0.5).formatHex());\n\n       return true;\n   }\n\n   /** @summary Draw histogram as filled errors */\n   async drawFilledErrors(handle, funcs /*, width, height*/) {\n      this.createG(true);\n\n      let left = handle.i1, right = handle.i2, di = handle.stepi,\n          histo = this.getHisto(), xaxis = this.getAxis('x'),\n          i, x, grx, y, yerr, gry1, gry2,\n          bins1 = [], bins2 = [];\n\n      for (i = left; i < right; i += di) {\n         x = xaxis.GetBinCoord(i+0.5);\n         if (funcs.logx && (x <= 0)) continue;\n         grx = Math.round(funcs.grx(x));\n\n         y = histo.getBinContent(i+1);\n         yerr = histo.getBinError(i+1);\n         if (funcs.logy && (y-yerr < funcs.scale_ymin)) continue;\n\n         gry1 = Math.round(funcs.gry(y + yerr));\n         gry2 = Math.round(funcs.gry(y - yerr));\n\n         bins1.push({grx: grx, gry: gry1});\n         bins2.unshift({grx: grx, gry: gry2});\n      }\n\n      let kind = (this.options.ErrorKind === 4) ? 'bezier' : 'line',\n          path1 = buildSvgPath(kind, bins1),\n          path2 = buildSvgPath('L'+kind, bins2);\n\n      if (this.fillatt.empty()) this.fillatt.setSolidColor('blue');\n\n      this.draw_g.append('svg:path')\n                 .attr('d', path1.path + path2.path + 'Z')\n                 .call(this.fillatt.func);\n\n      return true;\n   }\n\n   /** @summary Draw 1D histogram as SVG */\n   async draw1DBins() {\n\n      let pmain = this.getFramePainter(),\n          rect = pmain.getFrameRect();\n\n      if (!this.draw_content || (rect.width <= 0) || (rect.height <= 0)) {\n         this.removeG()\n         return false;\n      }\n\n      this.createHistDrawAttributes();\n\n      let handle = this.prepareDraw({ extra: 1, only_indexes: true }),\n          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y);\n\n      if (this.options.Bar)\n         return this.drawBars(handle, funcs, rect.width, rect.height);\n\n      if ((this.options.ErrorKind === 3) || (this.options.ErrorKind === 4))\n         return this.drawFilledErrors(handle, funcs, rect.width, rect.height);\n\n      return this.drawHistBins(handle, funcs, rect.width, rect.height);\n   }\n\n   /** @summary Draw histogram bins */\n   async drawHistBins(handle, funcs, width, height) {\n      this.createG(true);\n\n      let options = this.options,\n          left = handle.i1,\n          right = handle.i2,\n          di = handle.stepi,\n          histo = this.getHisto(),\n          want_tooltip = !isBatchMode() && settings.Tooltip,\n          xaxis = this.getAxis('x'),\n          res = '', lastbin = false,\n          startx, currx, curry, x, grx, y, gry, curry_min, curry_max, prevy, prevx, i, bestimin, bestimax,\n          exclude_zero = !options.Zero,\n          show_errors = options.Error,\n          show_markers = options.Mark,\n          show_line = options.Line,\n          show_text = options.Text,\n          path_fill = null, path_err = null, path_marker = null, path_line = null,\n          hints_err = null,\n          endx = '', endy = '', dend = 0, my, yerr1, yerr2, bincont, binerr, mx1, mx2, midx,\n          text_font;\n\n      if (show_errors && !show_markers && (this.v7EvalAttr('marker_style',1) > 1))\n         show_markers = true;\n\n      if (options.ErrorKind === 2) {\n         if (this.fillatt.empty()) show_markers = true;\n                              else path_fill = '';\n      } else if (options.Error) {\n         path_err = '';\n         hints_err = want_tooltip ? '' : null;\n      }\n\n      if (show_line) path_line = '';\n\n      if (show_markers) {\n         // draw markers also when e2 option was specified\n         this.createv7AttMarker();\n         if (this.markeratt.size > 0) {\n            // simply use relative move from point, can optimize in the future\n            path_marker = '';\n            this.markeratt.resetPos();\n         } else {\n            show_markers = false;\n         }\n      }\n\n      if (show_text) {\n         text_font = this.v7EvalFont('text', { size: 20, color: 'black', align: 22 });\n\n         if (!text_font.angle && !options.TextKind) {\n             let space = width / (right - left + 1);\n             if (space < 3 * text_font.size) {\n                text_font.setAngle(270);\n                text_font.setSize(Math.round(space*0.7));\n             }\n         }\n\n         this.startTextDrawing(text_font, 'font');\n      }\n\n      // if there are too many points, exclude many vertical drawings at the same X position\n      // instead define min and max value and made min-max drawing\n      let use_minmax = ((right-left) > 3*width);\n\n      if (options.ErrorKind === 1) {\n         let lw = this.lineatt.width + gStyle.fEndErrorSize;\n         endx = `m0,${lw}v${-2*lw}m0,${lw}`;\n         endy = `m${lw},0h${-2*lw}m${lw},0`;\n         dend = Math.floor((this.lineatt.width-1)/2);\n      }\n\n      let draw_markers = show_errors || show_markers;\n\n      if (draw_markers || show_text || show_line) use_minmax = true;\n\n      let draw_bin = besti => {\n         bincont = histo.getBinContent(besti+1);\n         if (!exclude_zero || (bincont !== 0)) {\n            mx1 = Math.round(funcs.grx(xaxis.GetBinCoord(besti)));\n            mx2 = Math.round(funcs.grx(xaxis.GetBinCoord(besti+di)));\n            midx = Math.round((mx1+mx2)/2);\n            my = Math.round(funcs.gry(bincont));\n            yerr1 = yerr2 = 20;\n            if (show_errors) {\n               binerr = histo.getBinError(besti+1);\n               yerr1 = Math.round(my - funcs.gry(bincont + binerr)); // up\n               yerr2 = Math.round(funcs.gry(bincont - binerr) - my); // down\n            }\n\n            if (show_text && (bincont !== 0)) {\n               let lbl = (bincont === Math.round(bincont)) ? bincont.toString() : floatToString(bincont, gStyle.fPaintTextFormat);\n\n               if (text_font.angle)\n                  this.drawText({ align: 12, x: midx, y: Math.round(my - 2 - text_font.size / 5), text: lbl, latex: 0 });\n               else\n                  this.drawText({ x: Math.round(mx1 + (mx2 - mx1) * 0.1), y: Math.round(my - 2 - text_font.size), width: Math.round((mx2 - mx1) * 0.8), height: text_font.size, text: lbl, latex: 0 });\n            }\n\n            if (show_line && (path_line !== null))\n               path_line += ((path_line.length === 0) ? 'M' : 'L') + midx + ',' + my;\n\n            if (draw_markers) {\n               if ((my >= -yerr1) && (my <= height + yerr2)) {\n                  if (path_fill !== null)\n                     path_fill += `M${mx1},${my-yerr1}h${mx2-mx1}v${yerr1+yerr2+1}h${mx1-mx2}z`;\n                  if (path_marker !== null)\n                     path_marker += this.markeratt.create(midx, my);\n                  if (path_err !== null) {\n                     let edx = 5;\n                     if (this.options.errorX > 0) {\n                        edx = Math.round((mx2-mx1)*this.options.errorX);\n                        let mmx1 = midx - edx, mmx2 = midx + edx;\n                        path_err += `M${mmx1+dend},${my}${endx}h${mmx2-mmx1-2*dend}${endx}`;\n                     }\n                     path_err += `M${midx},${my-yerr1+dend}${endy}v${yerr1+yerr2-2*dend}${endy}`;\n                     if (hints_err !== null)\n                        hints_err += `M${midx-edx},${my-yerr1}h${2*edx}v${yerr1+yerr2}h${-2*edx}z`;\n                  }\n               }\n            }\n         }\n      };\n\n      for (i = left; i <= right; i += di) {\n\n         x = xaxis.GetBinCoord(i);\n\n         if (funcs.logx && (x <= 0)) continue;\n\n         grx = Math.round(funcs.grx(x));\n\n         lastbin = (i > right - di);\n\n         if (lastbin && (left < right)) {\n            gry = curry;\n         } else {\n            y = histo.getBinContent(i+1);\n            gry = Math.round(funcs.gry(y));\n         }\n\n         if (res.length === 0) {\n            bestimin = bestimax = i;\n            prevx = startx = currx = grx;\n            prevy = curry_min = curry_max = curry = gry;\n            res = 'M'+currx+','+curry;\n         } else\n         if (use_minmax) {\n            if ((grx === currx) && !lastbin) {\n               if (gry < curry_min) bestimax = i; else\n               if (gry > curry_max) bestimin = i;\n               curry_min = Math.min(curry_min, gry);\n               curry_max = Math.max(curry_max, gry);\n               curry = gry;\n            } else {\n\n               if (draw_markers || show_text || show_line) {\n                  if (bestimin === bestimax) { draw_bin(bestimin); } else\n                     if (bestimin < bestimax) { draw_bin(bestimin); draw_bin(bestimax); } else {\n                        draw_bin(bestimax); draw_bin(bestimin);\n                     }\n               }\n\n               // when several points as same X differs, need complete logic\n               if (!draw_markers && ((curry_min !== curry_max) || (prevy !== curry_min))) {\n\n                  if (prevx !== currx)\n                     res += 'h'+(currx-prevx);\n\n                  if (curry === curry_min) {\n                     if (curry_max !== prevy)\n                        res += 'v' + (curry_max - prevy);\n                     if (curry_min !== curry_max)\n                        res += 'v' + (curry_min - curry_max);\n                  } else {\n                     if (curry_min !== prevy)\n                        res += 'v' + (curry_min - prevy);\n                     if (curry_max !== curry_min)\n                        res += 'v' + (curry_max - curry_min);\n                     if (curry !== curry_max)\n                       res += 'v' + (curry - curry_max);\n                  }\n\n                  prevx = currx;\n                  prevy = curry;\n               }\n\n               if (lastbin && (prevx !== grx))\n                  res += 'h'+(grx-prevx);\n\n               bestimin = bestimax = i;\n               curry_min = curry_max = curry = gry;\n               currx = grx;\n            }\n         } else\n         if ((gry !== curry) || lastbin) {\n            if (grx !== currx) res += 'h'+(grx-currx);\n            if (gry !== curry) res += 'v'+(gry-curry);\n            curry = gry;\n            currx = grx;\n         }\n      }\n\n      let close_path = '',\n          fill_for_interactive = !isBatchMode() && this.fillatt.empty() && options.Hist && settings.Tooltip && !draw_markers && !show_line;\n      if (!this.fillatt.empty() || fill_for_interactive) {\n         let h0 = height + 3;\n         if (fill_for_interactive) {\n            let gry0 = Math.round(funcs.gry(0));\n            if (gry0 <= 0)\n               h0 = -3;\n            else if (gry0 < height)\n               h0 = gry0;\n         }\n         close_path = `L${currx},${h0}H${startx}Z`;\n         if (res) res += close_path;\n      }\n\n      if (draw_markers || show_line) {\n         if (path_fill)\n            this.draw_g.append('svg:path')\n                       .attr('d', path_fill)\n                       .call(this.fillatt.func);\n\n         if (path_err)\n               this.draw_g.append('svg:path')\n                   .attr('d', path_err)\n                   .call(this.lineatt.func);\n\n         if (hints_err)\n               this.draw_g.append('svg:path')\n                   .attr('d', hints_err)\n                   .style('fill', 'none')\n                   .style('pointer-events', isBatchMode() ? null : 'visibleFill');\n\n         if (path_line) {\n            if (!this.fillatt.empty())\n               this.draw_g.append('svg:path')\n                     .attr('d', options.Fill ? (path_line + close_path) : res)\n                     .call(this.fillatt.func);\n\n            this.draw_g.append('svg:path')\n                   .attr('d', path_line)\n                   .style('fill', 'none')\n                   .call(this.lineatt.func);\n         }\n\n         if (path_marker)\n            this.draw_g.append('svg:path')\n                .attr('d', path_marker)\n                .call(this.markeratt.func);\n\n      } else if (res && options.Hist) {\n         this.draw_g.append('svg:path')\n                    .attr('d', res)\n                    .style('stroke-linejoin','miter')\n                    .call(this.lineatt.func)\n                    .call(this.fillatt.func);\n      }\n\n      return show_text ? this.finishTextDrawing() : true;\n   }\n\n   /** @summary Provide text information (tooltips) for histogram bin */\n   getBinTooltips(bin) {\n      let tips = [],\n          name = this.getObjectHint(),\n          pmain = this.getFramePainter(),\n          histo = this.getHisto(),\n          xaxis = this.getAxis('x'),\n          di = this.isDisplayItem() ? histo.stepx : 1,\n          x1 = xaxis.GetBinCoord(bin),\n          x2 = xaxis.GetBinCoord(bin+di),\n          cont = histo.getBinContent(bin+1),\n          xlbl = this.getAxisBinTip('x', bin, di);\n\n      if (name) tips.push(name);\n\n      if (this.options.Error || this.options.Mark) {\n         tips.push('x = ' + xlbl, 'y = ' + pmain.axisAsText('y', cont));\n         if (this.options.Error) {\n            if (xlbl[0] == '[') tips.push('error x = ' + ((x2 - x1) / 2).toPrecision(4));\n            tips.push('error y = ' + histo.getBinError(bin + 1).toPrecision(4));\n         }\n      } else {\n         tips.push(`bin = ${bin+1}`);\n         tips.push('x = ' + xlbl);\n         if (histo['$baseh']) cont -= histo['$baseh'].getBinContent(bin+1);\n         let lbl = 'entries = ' + (di > 1 ? '~' : '');\n         if (cont === Math.round(cont))\n            tips.push(lbl + cont);\n         else\n            tips.push(lbl + floatToString(cont, gStyle.fStatFormat));\n      }\n\n      return tips;\n   }\n\n   /** @summary Process tooltip event */\n   processTooltipEvent(pnt) {\n      if (!pnt || !this.draw_content || this.options.Mode3D || !this.draw_g) {\n         if (this.draw_g)\n            this.draw_g.select('.tooltip_bin').remove();\n         return null;\n      }\n\n      let pmain = this.getFramePainter(),\n          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),\n          width = pmain.getFrameWidth(),\n          height = pmain.getFrameHeight(),\n          histo = this.getHisto(), xaxis = this.getAxis('x'),\n          findbin = null, show_rect,\n          grx1, midx, grx2, gry1, midy, gry2, gapx = 2,\n          left = this.getSelectIndex('x', 'left', -1),\n          right = this.getSelectIndex('x', 'right', 2),\n          l = left, r = right;\n\n      function GetBinGrX(i) {\n         let xx = xaxis.GetBinCoord(i);\n         return (funcs.logx && (xx <= 0)) ? null : funcs.grx(xx);\n      }\n\n      function GetBinGrY(i) {\n         let yy = histo.getBinContent(i + 1);\n         if (funcs.logy && (yy < funcs.scale_ymin))\n            return funcs.swap_xy ? -1000 : 10*height;\n         return Math.round(funcs.gry(yy));\n      }\n\n      let pnt_x = funcs.swap_xy ? pnt.y : pnt.x,\n          pnt_y = funcs.swap_xy ? pnt.x : pnt.y;\n\n      while (l < r-1) {\n         let m = Math.round((l+r)*0.5),\n             xx = GetBinGrX(m);\n         if ((xx === null) || (xx < pnt_x - 0.5)) {\n            if (funcs.swap_xy) r = m; else l = m;\n         } else if (xx > pnt_x + 0.5) {\n            if (funcs.swap_xy) l = m; else r = m;\n         } else { l++; r--; }\n      }\n\n      findbin = r = l;\n      grx1 = GetBinGrX(findbin);\n\n      if (funcs.swap_xy) {\n         while ((l>left) && (GetBinGrX(l-1) < grx1 + 2)) --l;\n         while ((r<right) && (GetBinGrX(r+1) > grx1 - 2)) ++r;\n      } else {\n         while ((l>left) && (GetBinGrX(l-1) > grx1 - 2)) --l;\n         while ((r<right) && (GetBinGrX(r+1) < grx1 + 2)) ++r;\n      }\n\n      if (l < r) {\n         // many points can be assigned with the same cursor position\n         // first try point around mouse y\n         let best = height;\n         for (let m=l;m<=r;m++) {\n            let dist = Math.abs(GetBinGrY(m) - pnt_y);\n            if (dist < best) { best = dist; findbin = m; }\n         }\n\n         // if best distance still too far from mouse position, just take from between\n         if (best > height/10)\n            findbin = Math.round(l + (r-l) / height * pnt_y);\n\n         grx1 = GetBinGrX(findbin);\n      }\n\n      grx1 = Math.round(grx1);\n      grx2 = Math.round(GetBinGrX(findbin+1));\n\n      if (this.options.Bar) {\n         let w = grx2 - grx1;\n         grx1 += Math.round(this.options.BarOffset*w);\n         grx2 = grx1 + Math.round(this.options.BarWidth*w);\n      }\n\n      if (grx1 > grx2)\n         [grx1, grx2] = [grx2, grx1];\n\n      midx = Math.round((grx1 + grx2)/2);\n\n      midy = gry1 = gry2 = GetBinGrY(findbin);\n\n      if (this.options.Bar) {\n         show_rect = true;\n\n         gapx = 0;\n\n         gry1 = Math.round(funcs.gry(((this.options.BaseLine!==false) && (this.options.BaseLine > funcs.scale_ymin)) ? this.options.BaseLine : funcs.scale_ymin));\n\n         if (gry1 > gry2)\n            [gry1, gry2] = [gry2, gry1];\n\n         if (!pnt.touch && (pnt.nproc === 1))\n            if ((pnt_y < gry1) || (pnt_y > gry2)) findbin = null;\n\n      } else if (this.options.Error || this.options.Mark) {\n\n         show_rect = true;\n\n         let msize = 3;\n         if (this.markeratt) msize = Math.max(msize, this.markeratt.getFullSize());\n\n         if (this.options.Error) {\n            let cont = histo.getBinContent(findbin+1),\n                binerr = histo.getBinError(findbin+1);\n\n            gry1 = Math.round(funcs.gry(cont + binerr)); // up\n            gry2 = Math.round(funcs.gry(cont - binerr)); // down\n\n            let dx = (grx2-grx1)*this.options.errorX;\n            grx1 = Math.round(midx - dx);\n            grx2 = Math.round(midx + dx);\n         }\n\n         // show at least 6 pixels as tooltip rect\n         if (grx2 - grx1 < 2*msize) { grx1 = midx-msize; grx2 = midx+msize; }\n\n         gry1 = Math.min(gry1, midy - msize);\n         gry2 = Math.max(gry2, midy + msize);\n\n         if (!pnt.touch && (pnt.nproc === 1))\n            if ((pnt_y<gry1) || (pnt_y>gry2)) findbin = null;\n\n      } else if (this.options.Line) {\n\n         show_rect = false;\n\n      } else {\n\n         // if histogram alone, use old-style with rects\n         // if there are too many points at pixel, use circle\n         show_rect = (pnt.nproc === 1) && (right-left < width);\n\n         if (show_rect) {\n            gry2 = height;\n\n            if (!this.fillatt.empty()) {\n               gry2 = Math.min(height, Math.max(0, Math.round(funcs.gry(0))));\n               if (gry2 < gry1)\n                  [gry1, gry2] = [gry2, gry1];\n            }\n\n            // for mouse events pointer should be between y1 and y2\n            if (((pnt.y < gry1) || (pnt.y > gry2)) && !pnt.touch) findbin = null;\n         }\n      }\n\n      if (findbin !== null) {\n         // if bin on boundary found, check that x position is ok\n         if ((findbin === left) && (grx1 > pnt_x + gapx))  findbin = null; else\n         if ((findbin === right-1) && (grx2 < pnt_x - gapx)) findbin = null; else\n         // if bars option used check that bar is not match\n         if ((pnt_x < grx1 - gapx) || (pnt_x > grx2 + gapx)) findbin = null; else\n         // exclude empty bin if empty bins suppressed\n         if (!this.options.Zero && (histo.getBinContent(findbin+1) === 0)) findbin = null;\n      }\n\n      let ttrect = this.draw_g.select('.tooltip_bin');\n\n      if ((findbin === null) || ((gry2 <= 0) || (gry1 >= height))) {\n         ttrect.remove();\n         return null;\n      }\n\n      let res = { name: 'histo', title: histo.fTitle,\n                  x: midx, y: midy, exact: true,\n                  color1: this.lineatt ? this.lineatt.color : 'green',\n                  color2: this.fillatt ? this.fillatt.getFillColorAlt('blue') : 'blue',\n                  lines: this.getBinTooltips(findbin) };\n\n      if (pnt.disabled) {\n         // case when tooltip should not highlight bin\n\n         ttrect.remove();\n         res.changed = true;\n      } else if (show_rect) {\n\n         if (ttrect.empty())\n            ttrect = this.draw_g.append('svg:rect')\n                                .attr('class','tooltip_bin h1bin')\n                                .style('pointer-events','none');\n\n         res.changed = ttrect.property('current_bin') !== findbin;\n\n         if (res.changed)\n            ttrect.attr('x', pmain.swap_xy ? gry1 : grx1)\n                  .attr('width', pmain.swap_xy ? gry2-gry1 : grx2-grx1)\n                  .attr('y', pmain.swap_xy ? grx1 : gry1)\n                  .attr('height', pmain.swap_xy ? grx2-grx1 : gry2-gry1)\n                  .style('opacity', '0.3')\n                  .property('current_bin', findbin);\n\n         res.exact = (Math.abs(midy - pnt_y) <= 5) || ((pnt_y>=gry1) && (pnt_y<=gry2));\n\n         res.menu = res.exact; // one could show context menu\n         // distance to middle point, use to decide which menu to activate\n         res.menu_dist = Math.sqrt((midx-pnt_x)**2 + (midy-pnt_y)**2);\n\n      } else {\n         let radius = this.lineatt.width + 3;\n\n         if (ttrect.empty())\n            ttrect = this.draw_g.append('svg:circle')\n                                .attr('class','tooltip_bin')\n                                .style('pointer-events','none')\n                                .attr('r', radius)\n                                .call(this.lineatt.func)\n                                .call(this.fillatt.func);\n\n         res.exact = (Math.abs(midx - pnt.x) <= radius) && (Math.abs(midy - pnt.y) <= radius);\n\n         res.menu = res.exact; // show menu only when mouse pointer exactly over the histogram\n         res.menu_dist = Math.sqrt((midx-pnt.x)**2 + (midy-pnt.y)**2);\n\n         res.changed = ttrect.property('current_bin') !== findbin;\n\n         if (res.changed)\n            ttrect.attr('cx', midx)\n                  .attr('cy', midy)\n                  .property('current_bin', findbin);\n      }\n\n      if (res.changed)\n         res.user_info = { obj: histo,  name: 'histo',\n                           bin: findbin, cont: histo.getBinContent(findbin+1),\n                           grx: midx, gry: midy };\n\n      return res;\n   }\n\n   /** @summary Fill histogram context menu */\n   fillHistContextMenu(menu) {\n\n      menu.add('Auto zoom-in', () => this.autoZoom());\n\n      let opts = this.getSupportedDrawOptions();\n\n      menu.addDrawMenu('Draw with', opts, arg => {\n         if (arg === 'inspect')\n            return this.showInspector();\n\n         this.decodeOptions(arg); // obsolete, should be implemented differently\n\n         if (this.options.need_fillcol && this.fillatt && this.fillatt.empty())\n            this.fillatt.change(5,1001);\n\n         // redraw all objects\n         this.interactiveRedraw('pad', 'drawopt');\n      });\n   }\n\n   /** @summary Perform automatic zoom inside non-zero region of histogram */\n   autoZoom() {\n      let left = this.getSelectIndex('x', 'left', -1),\n          right = this.getSelectIndex('x', 'right', 1),\n          dist = right - left, histo = this.getHisto(), xaxis = this.getAxis('x');\n\n      if (dist == 0) return;\n\n      // first find minimum\n      let min = histo.getBinContent(left + 1);\n      for (let indx = left; indx < right; ++indx)\n         min = Math.min(min, histo.getBinContent(indx+1));\n      if (min > 0) return; // if all points positive, no chance for autoscale\n\n      while ((left < right) && (histo.getBinContent(left+1) <= min)) ++left;\n      while ((left < right) && (histo.getBinContent(right) <= min)) --right;\n\n      // if singular bin\n      if ((left === right-1) && (left > 2) && (right < this.nbinsx-2)) {\n         --left; ++right;\n      }\n\n      if ((right - left < dist) && (left < right))\n         return this.getFramePainter().zoom(xaxis.GetBinCoord(left), xaxis.GetBinCoord(right));\n   }\n\n   /** @summary Checks if it makes sense to zoom inside specified axis range */\n   canZoomInside(axis,min,max) {\n      let xaxis = this.getAxis('x');\n\n      if ((axis == 'x') && (xaxis.FindBin(max,0.5) - xaxis.FindBin(min,0) > 1)) return true;\n\n      if ((axis == 'y') && (Math.abs(max-min) > Math.abs(this.ymax-this.ymin)*1e-6)) return true;\n\n      return false;\n   }\n\n   /** @summary Call appropriate draw function */\n   async callDrawFunc(reason) {\n      let main = this.getFramePainter();\n\n      if (main && (main.mode3d !== this.options.Mode3D) && !this.isMainPainter())\n         this.options.Mode3D = main.mode3d;\n\n      return this.options.Mode3D ? this.draw3D(reason) : this.draw2D(reason);\n   }\n\n   /** @summary Draw in 2d */\n   async draw2D(reason) {\n      this.clear3DScene();\n\n      return this.drawFrameAxes().then(res => {\n         return res ? this.drawingBins(reason) : false;\n      }).then(res => {\n         if (res)\n            return this.draw1DBins().then(() => this.addInteractivity());\n      }).then(() => this);\n   }\n\n   /** @summary Draw in 3d */\n   async draw3D(reason) {\n      console.log('3D drawing is disabled, load ./hist/RH1Painter.mjs');\n      return this.draw2D(reason);\n   }\n\n   /** @summary Readraw histogram */\n   async redraw(reason) {\n      return this.callDrawFunc(reason);\n   }\n\n   static async _draw(painter, opt) {\n      return ensureRCanvas(painter).then(() => {\n\n         painter.setAsMainPainter();\n\n         painter.options = { Hist: false, Bar: false, BarStyle: 0,\n                             Error: false, ErrorKind: -1, errorX: gStyle.fErrorX,\n                             Zero: false, Mark: false,\n                             Line: false, Fill: false, Lego: 0, Surf: 0,\n                             Text: false, TextAngle: 0, TextKind: '', AutoColor: 0,\n                             BarOffset: 0., BarWidth: 1., BaseLine: false, Mode3D: false };\n\n         let d = new DrawOptions(opt);\n         if (d.check('R3D_', true))\n            painter.options.Render3D = constants.Render3D.fromString(d.part.toLowerCase());\n\n         let kind = painter.v7EvalAttr('kind', 'hist'),\n             sub = painter.v7EvalAttr('sub', 0),\n             has_main = !!painter.getMainPainter(),\n             o = painter.options;\n\n         o.Text = painter.v7EvalAttr('drawtext', false);\n         o.BarOffset = painter.v7EvalAttr('baroffset', 0.);\n         o.BarWidth = painter.v7EvalAttr('barwidth', 1.);\n         o.second_x = has_main && painter.v7EvalAttr('secondx', false);\n         o.second_y = has_main && painter.v7EvalAttr('secondy', false);\n\n         switch(kind) {\n            case 'bar': o.Bar = true; o.BarStyle = sub; break;\n            case 'err': o.Error = true; o.ErrorKind = sub; break;\n            case 'p': o.Mark = true; break;\n            case 'l': o.Line = true; break;\n            case 'lego': o.Lego = sub > 0 ? 10+sub : 12; o.Mode3D = true; break;\n            default: o.Hist = true;\n         }\n\n         painter.scanContent();\n\n         return painter.callDrawFunc();\n      });\n   }\n\n   /** @summary draw RH1 object */\n   static async draw(dom, histo, opt) {\n      return RH1Painter._draw(new RH1Painter(dom, histo), opt);\n   }\n\n} // class RH1Painter\n\nexport { RH1Painter };\n","import { settings, gStyle } from '../core.mjs';\nimport { RH1Painter as RH1Painter2D } from '../hist2d/RH1Painter.mjs';\nimport { RAxisPainter } from '../gpad/RAxisPainter.mjs';\nimport { assignFrame3DMethods, drawBinsLego } from './hist3d.mjs';\n\n\nclass RH1Painter extends RH1Painter2D {\n\n   /** @summary Draw 1-D histogram in 3D mode */\n   draw3D(reason) {\n\n      this.mode3d = true;\n\n      let main = this.getFramePainter(), // who makes axis drawing\n          is_main = this.isMainPainter(), // is main histogram\n          zmult = 1 + 2*gStyle.fHistTopMargin,\n          pr = Promise.resolve(this);\n\n      if (reason == 'resize')  {\n         if (is_main && main.resize3D()) main.render3D();\n         return pr;\n      }\n\n      this.deleteAttr();\n\n      this.scanContent(true); // may be required for axis drawings\n\n      if (is_main) {\n         assignFrame3DMethods(main);\n         pr = main.create3DScene(this.options.Render3D).then(() => {\n            main.setAxesRanges(this.getAxis('x'), this.xmin, this.xmax, null, this.ymin, this.ymax, null, 0, 0);\n            main.set3DOptions(this.options);\n            main.drawXYZ(main.toplevel, RAxisPainter, { use_y_for_z: true, zmult, zoom: settings.Zooming, ndim: 1, draw: true, v7: true });\n         });\n      }\n\n      if (!main.mode3d)\n         return pr;\n\n      return pr.then(() => this.drawingBins(reason)).then(() => {\n\n         // called when bins received from server, must be reentrant\n         let main = this.getFramePainter();\n\n         drawBinsLego(this, true);\n         this.updatePaletteDraw();\n         main.render3D();\n         main.addKeysHandler();\n         return this;\n      });\n   }\n\n      /** @summary draw RH1 object */\n   static async draw(dom, histo, opt) {\n      return RH1Painter._draw(new RH1Painter(dom, histo), opt);\n   }\n\n} // class RH1Painter\n\nexport { RH1Painter };\n\n"],"x_google_ignoreList":[0,1]}