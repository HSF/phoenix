{"version":3,"file":"484.89644b81d83bc361.js","mappings":"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","names":["TSplinePainter","ObjectPainter","updateObject","obj","opt","spline","this","getObject","_typename","Object","assign","undefined","decodeOptions","eval","knot","x","dx","fX","fY","fB","fC","fD","fE","fF","findX","klow","khig","fNp","fXmin","fXmax","fKstep","Math","round","fDelta","fPoly","max","khalf","createDummyHisto","xmin","xmax","ymin","ymax","forEach","min","gStyle","fHistTopMargin","histo","createHistogram","clTH1I","fName","fTitle","fBits","kNoStats","fXaxis","fYaxis","processTooltipEvent","pnt","funcs","getFramePainter","getGrFuncs","options","second_x","second_y","xx","yy","cleanup","indx","revertAxis","fN","abs","grx","knot_size","gbin","draw_g","selectChild","radius","lineatt","width","remove","empty","append","attr","style","call","func","res","name","title","y","gry","color1","color","lines","exact","changed","property","menu","menu_dist","sqrt","getObjectHint","push","axisAsText","floatToString","fStatFormat","redraw","pmain","w","getFrameWidth","h","getFrameHeight","createG","createAttLine","Line","Curve","npx","fNpx","bins","scale_xmin","scale_xmax","logx","log","n","exp","buildSvgCurve","Mark","path","createAttMarker","markeratt","resetPos","getFullSize","length","create","canZoomInside","axis","d","DrawOptions","has_main","getMainPainter","Same","check","Hopt","storeDrawOpt","draw","dom","_asyncToGenerator","painter","no_main","promise","Promise","resolve","console","warn","TH1Painter","then","addToPadPrimitives"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/draw/TSplinePainter.mjs"],"sourcesContent":["import { gStyle, clTH1I, kNoStats, createHistogram } from '../core.mjs';\nimport { DrawOptions, floatToString, buildSvgCurve } from '../base/BasePainter.mjs';\nimport { ObjectPainter } from '../base/ObjectPainter.mjs';\nimport { TH1Painter } from '../hist/TH1Painter.mjs';\n\n\n/**\n * @summary Painter for TSpline objects.\n *\n * @private\n */\n\nclass TSplinePainter extends ObjectPainter {\n\n   /** @summary Update TSpline object\n     * @private */\n   updateObject(obj, opt) {\n      const spline = this.getObject();\n\n      if (spline._typename !== obj._typename) return false;\n\n      if (spline !== obj) Object.assign(spline, obj);\n\n      if (opt !== undefined) this.decodeOptions(opt);\n\n      return true;\n   }\n\n   /** @summary Evaluate spline at given position\n     * @private */\n   eval(knot, x) {\n      const dx = x - knot.fX;\n\n      if (knot._typename === 'TSplinePoly3')\n         return knot.fY + dx*(knot.fB + dx*(knot.fC + dx*knot.fD));\n\n      if (knot._typename === 'TSplinePoly5')\n         return knot.fY + dx*(knot.fB + dx*(knot.fC + dx*(knot.fD + dx*(knot.fE + dx*knot.fF))));\n\n      return knot.fY + dx;\n   }\n\n   /** @summary Find idex for x value\n     * @private */\n   findX(x) {\n      const spline = this.getObject();\n      let klow = 0, khig = spline.fNp - 1;\n\n      if (x <= spline.fXmin) return 0;\n      if (x >= spline.fXmax) return khig;\n\n      if (spline.fKstep) {\n         // Equidistant knots, use histogramming\n         klow = Math.round((x - spline.fXmin)/spline.fDelta);\n         // Correction for rounding errors\n         if (x < spline.fPoly[klow].fX)\n            klow = Math.max(klow-1, 0);\n          else if (klow < khig)\n            if (x > spline.fPoly[klow+1].fX) ++klow;\n      } else {\n         // Non equidistant knots, binary search\n         while (khig - klow > 1) {\n            const khalf = Math.round((klow + khig)/2);\n            if (x > spline.fPoly[khalf].fX) klow = khalf;\n                                      else khig = khalf;\n         }\n      }\n      return klow;\n   }\n\n   /** @summary Create histogram for axes drawing\n     * @private */\n   createDummyHisto() {\n      const spline = this.getObject();\n      let xmin = 0, xmax = 1, ymin = 0, ymax = 1;\n\n      if (spline.fPoly) {\n         xmin = xmax = spline.fPoly[0].fX;\n         ymin = ymax = spline.fPoly[0].fY;\n\n         spline.fPoly.forEach(knot => {\n            xmin = Math.min(knot.fX, xmin);\n            xmax = Math.max(knot.fX, xmax);\n            ymin = Math.min(knot.fY, ymin);\n            ymax = Math.max(knot.fY, ymax);\n         });\n\n         if (ymax > 0) ymax *= (1 + gStyle.fHistTopMargin);\n         if (ymin < 0) ymin *= (1 + gStyle.fHistTopMargin);\n      }\n\n      const histo = createHistogram(clTH1I, 10);\n\n      histo.fName = spline.fName + '_hist';\n      histo.fTitle = spline.fTitle;\n      histo.fBits |= kNoStats;\n\n      histo.fXaxis.fXmin = xmin;\n      histo.fXaxis.fXmax = xmax;\n      histo.fYaxis.fXmin = ymin;\n      histo.fYaxis.fXmax = ymax;\n\n      return histo;\n   }\n\n   /** @summary Process tooltip event\n     * @private */\n   processTooltipEvent(pnt) {\n      const spline = this.getObject(),\n            funcs = this.getFramePainter()?.getGrFuncs(this.options.second_x, this.options.second_y);\n      let cleanup = false, xx, yy, knot = null, indx = 0;\n\n      if ((pnt === null) || !spline || !funcs)\n         cleanup = true;\n       else {\n         xx = funcs.revertAxis('x', pnt.x);\n         indx = this.findX(xx);\n         knot = spline.fPoly[indx];\n         yy = this.eval(knot, xx);\n\n         if ((indx < spline.fN-1) && (Math.abs(spline.fPoly[indx+1].fX-xx) < Math.abs(xx-knot.fX))) knot = spline.fPoly[++indx];\n\n         if (Math.abs(funcs.grx(knot.fX) - pnt.x) < 0.5*this.knot_size) {\n            xx = knot.fX; yy = knot.fY;\n         } else {\n            knot = null;\n            if ((xx < spline.fXmin) || (xx > spline.fXmax)) cleanup = true;\n         }\n      }\n\n      let gbin = this.draw_g?.selectChild('.tooltip_bin');\n      const radius = this.lineatt.width + 3;\n\n      if (cleanup || !this.draw_g) {\n         gbin?.remove();\n         return null;\n      }\n\n      if (gbin.empty()) {\n         gbin = this.draw_g.append('svg:circle')\n                           .attr('class', 'tooltip_bin')\n                           .style('pointer-events', 'none')\n                           .attr('r', radius)\n                           .style('fill', 'none')\n                           .call(this.lineatt.func);\n      }\n\n      const res = { name: this.getObject().fName,\n                  title: this.getObject().fTitle,\n                  x: funcs.grx(xx),\n                  y: funcs.gry(yy),\n                  color1: this.lineatt.color,\n                  lines: [],\n                  exact: (knot !== null) || (Math.abs(funcs.gry(yy) - pnt.y) < radius) };\n\n      res.changed = gbin.property('current_xx') !== xx;\n      res.menu = res.exact;\n      res.menu_dist = Math.sqrt((res.x-pnt.x)**2 + (res.y-pnt.y)**2);\n\n      if (res.changed) {\n         gbin.attr('cx', Math.round(res.x))\n             .attr('cy', Math.round(res.y))\n             .property('current_xx', xx);\n      }\n\n      const name = this.getObjectHint();\n      if (name) res.lines.push(name);\n      res.lines.push(`x = ${funcs.axisAsText('x', xx)}`,\n                     `y = ${funcs.axisAsText('y', yy)}`);\n      if (knot !== null) {\n         res.lines.push(`knot = ${indx}`,\n                        `B = ${floatToString(knot.fB, gStyle.fStatFormat)}`,\n                        `C = ${floatToString(knot.fC, gStyle.fStatFormat)}`,\n                        `D = ${floatToString(knot.fD, gStyle.fStatFormat)}`);\n         if ((knot.fE !== undefined) && (knot.fF !== undefined)) {\n            res.lines.push(`E = ${floatToString(knot.fE, gStyle.fStatFormat)}`,\n                           `F = ${floatToString(knot.fF, gStyle.fStatFormat)}`);\n         }\n      }\n\n      return res;\n   }\n\n   /** @summary Redraw object\n     * @private */\n   redraw() {\n      const spline = this.getObject(),\n          pmain = this.getFramePainter(),\n          funcs = pmain.getGrFuncs(this.options.second_x, this.options.second_y),\n          w = pmain.getFrameWidth(),\n          h = pmain.getFrameHeight();\n\n      this.createG(true);\n\n      this.knot_size = 5; // used in tooltip handling\n\n      this.createAttLine({ attr: spline });\n\n      if (this.options.Line || this.options.Curve) {\n         const npx = Math.max(10, spline.fNpx), bins = []; // index of current knot\n         let xmin = Math.max(pmain.scale_xmin, spline.fXmin),\n             xmax = Math.min(pmain.scale_xmax, spline.fXmax),\n             indx = this.findX(xmin);\n\n         if (pmain.logx) {\n            xmin = Math.log(xmin);\n            xmax = Math.log(xmax);\n         }\n\n         for (let n = 0; n < npx; ++n) {\n            let x = xmin + (xmax-xmin)/npx*(n-1);\n            if (pmain.logx) x = Math.exp(x);\n\n            while ((indx < spline.fNp-1) && (x > spline.fPoly[indx+1].fX)) ++indx;\n\n            const y = this.eval(spline.fPoly[indx], x);\n\n            bins.push({ x, y, grx: funcs.grx(x), gry: funcs.gry(y) });\n         }\n\n         this.draw_g.append('svg:path')\n             .attr('class', 'line')\n             .attr('d', buildSvgCurve(bins))\n             .style('fill', 'none')\n             .call(this.lineatt.func);\n      }\n\n      if (this.options.Mark) {\n         // for tooltips use markers only if nodes where not created\n         let path = '';\n\n         this.createAttMarker({ attr: spline });\n\n         this.markeratt.resetPos();\n\n         this.knot_size = this.markeratt.getFullSize();\n\n         for (let n = 0; n < spline.fPoly.length; n++) {\n            const knot = spline.fPoly[n],\n                grx = funcs.grx(knot.fX);\n            if ((grx > -this.knot_size) && (grx < w + this.knot_size)) {\n               const gry = funcs.gry(knot.fY);\n               if ((gry > -this.knot_size) && (gry < h + this.knot_size))\n                  path += this.markeratt.create(grx, gry);\n            }\n         }\n\n         if (path) {\n            this.draw_g.append('svg:path')\n                       .attr('d', path)\n                       .call(this.markeratt.func);\n         }\n      }\n   }\n\n   /** @summary Checks if it makes sense to zoom inside specified axis range */\n   canZoomInside(axis /* , min, max */) {\n      if (axis !== 'x') return false;\n\n      // spline can always be calculated and therefore one can zoom inside\n      return !!this.getObject();\n   }\n\n   /** @summary Decode options for TSpline drawing */\n   decodeOptions(opt) {\n      const d = new DrawOptions(opt);\n\n      if (!this.options) this.options = {};\n\n      const has_main = !!this.getMainPainter();\n\n      Object.assign(this.options, {\n         Same: d.check('SAME'),\n         Line: d.check('L'),\n         Curve: d.check('C'),\n         Mark: d.check('P'),\n         Hopt: '',\n         second_x: false,\n         second_y: false\n      });\n\n      if (!this.options.Line && !this.options.Curve && !this.options.Mark)\n         this.options.Curve = true;\n\n      if (d.check('X+')) { this.options.Hopt += 'X+'; this.options.second_x = has_main; }\n      if (d.check('Y+')) { this.options.Hopt += 'Y+'; this.options.second_y = has_main; }\n\n      this.storeDrawOpt(opt);\n   }\n\n   /** @summary Draw TSpline */\n   static async draw(dom, spline, opt) {\n      const painter = new TSplinePainter(dom, spline);\n      painter.decodeOptions(opt);\n\n      const no_main = !painter.getMainPainter();\n      let promise = Promise.resolve();\n      if (no_main || painter.options.second_x || painter.options.second_y) {\n         if (painter.options.Same && no_main) {\n            console.warn('TSpline painter requires histogram to be drawn');\n            return null;\n         }\n         const histo = painter.createDummyHisto();\n         promise = TH1Painter.draw(dom, histo, painter.options.Hopt);\n      }\n\n      return promise.then(() => {\n         painter.addToPadPrimitives();\n         painter.redraw();\n         return painter;\n      });\n   }\n\n} // class TSplinePainter\n\nexport { TSplinePainter };\n"],"x_google_ignoreList":[0]}