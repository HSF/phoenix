{"version":3,"file":"666.1bff488e4190532e.js","mappings":"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","names":["TASImagePainter","ObjectPainter","decodeOptions","opt","d","DrawOptions","this","options","Zscale","obj","getObject","check","constRatio","fConstRatio","console","log","createRGBA","nlevels","pal","fPalette","rgba","Array","fill","lvl","indx","l","fPoints","length","r1","r2","Math","min","round","fColorRed","fColorGreen","fColorBlue","fColorAlpha","makeUrlFromImageBuf","fp","_this","_asyncToGenerator","fImgBuf","max","k","v","fContour","arr","getLevels","getPaletteColor","zval","toHex","z","getImageZoomRange","fWidth","fHeight","isNodeJs","__webpack_require__","e","then","t","bind","h","default","createCanvas","xmax","xmin","ymax","ymin","Promise","resolveFunc","c","document","createElement","width","height","canvas","context","getContext","imageData","getImageData","data","i","dst","row","j","iii","putImageData","url","toDataURL","can_zoom","res","offx","offy","sizex","sizey","image_ratio","frame_ratio","getFrameHeight","getFrameWidth","w2","h2","zoom_xmin","zoom_xmax","zoom_ymin","zoom_ymax","makeUrlFromPngBuf","_this2","buf","fPngBuf","pngbuf","isStr","String","fromCharCode","btoa_func","doc","getDocument","image","onload","drawImage","canvas2","context2","imageData2","arr2","src","onerror","_this3","getFramePainter","rect","getFrameRect","getPadPainter","getPadRect","promise","wheel_zoomy","_blob","error","fImageQuality","fImageCompression","_typename","clTImagePalette","fUniqueID","fBits","fNumPoints","resolve","img","createG","append","attr","isBatchMode","settings","MoveResize","ContextMenu","style","assignContextMenu","drawColorPalette","setAxesRanges","create","clTAxis","createXY","ndim","check_pad_range","addInteractivity","fillContextMenuItems","menu","addchk","flag","interactiveRedraw","canZoomInside","axis","enabled","can_move","_this4","isMainPainter","draw_palette","clTPaletteAxis","Object","assign","fX1NDC","fX2NDC","fY1NDC","fY2NDC","fInit","fAxis","fChopt","_color_palette","pal_painter","findPainterFor","Enabled","removeG","drawPave","prev_name","selectCurrentPad","getPadName","TPavePainter","draw","getDom","p","setSecondary","redraw","toggleColz","clickButton","funcname","fillToolbar","pp","addPadButton","showPadButtons","dom","painter","setAsMainPainter","ensureTCanvas"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/draw/TASImagePainter.mjs"],"sourcesContent":["import { create, settings, isNodeJs, isStr, btoa_func, clTAxis, clTPaletteAxis, clTImagePalette, getDocument } from '../core.mjs';\nimport { toHex } from '../base/colors.mjs';\nimport { assignContextMenu } from '../gui/menu.mjs';\nimport { DrawOptions } from '../base/BasePainter.mjs';\nimport { ObjectPainter } from '../base/ObjectPainter.mjs';\nimport { TPavePainter } from '../hist/TPavePainter.mjs';\nimport { ensureTCanvas } from '../gpad/TCanvasPainter.mjs';\n\n/**\n * @summary Painter for TASImage object.\n *\n * @private\n */\n\nclass TASImagePainter extends ObjectPainter {\n\n   /** @summary Decode options string  */\n   decodeOptions(opt) {\n      const d = new DrawOptions(opt);\n\n      this.options = { Zscale: false };\n\n      const obj = this.getObject();\n\n      if (d.check('CONST')) {\n         this.options.constRatio = true;\n         if (obj) obj.fConstRatio = true;\n         console.log('use const');\n      }\n      if (d.check('Z')) this.options.Zscale = true;\n   }\n\n   /** @summary Create RGBA buffers */\n   createRGBA(nlevels) {\n      const obj = this.getObject(),\n            pal = obj?.fPalette;\n      if (!pal) return null;\n\n      const rgba = new Array((nlevels+1) * 4).fill(0); // precaclucated colors\n\n      for (let lvl = 0, indx = 1; lvl <= nlevels; ++lvl) {\n         const l = lvl/nlevels;\n         while ((pal.fPoints[indx] < l) && (indx < pal.fPoints.length-1)) indx++;\n\n         const r1 = (pal.fPoints[indx] - l) / (pal.fPoints[indx] - pal.fPoints[indx-1]),\n               r2 = (l - pal.fPoints[indx-1]) / (pal.fPoints[indx] - pal.fPoints[indx-1]);\n\n         rgba[lvl*4] = Math.min(255, Math.round((pal.fColorRed[indx-1] * r1 + pal.fColorRed[indx] * r2) / 256));\n         rgba[lvl*4+1] = Math.min(255, Math.round((pal.fColorGreen[indx-1] * r1 + pal.fColorGreen[indx] * r2) / 256));\n         rgba[lvl*4+2] = Math.min(255, Math.round((pal.fColorBlue[indx-1] * r1 + pal.fColorBlue[indx] * r2) / 256));\n         rgba[lvl*4+3] = Math.min(255, Math.round((pal.fColorAlpha[indx-1] * r1 + pal.fColorAlpha[indx] * r2) / 256));\n      }\n\n      return rgba;\n   }\n\n   /** @summary Create url using image buffer\n     * @private */\n   async makeUrlFromImageBuf(obj, fp) {\n      const nlevels = 1000;\n      this.rgba = this.createRGBA(nlevels); // precaclucated colors\n\n      let min = obj.fImgBuf[0], max = obj.fImgBuf[0];\n      for (let k = 1; k < obj.fImgBuf.length; ++k) {\n         const v = obj.fImgBuf[k];\n         min = Math.min(v, min);\n         max = Math.max(v, max);\n      }\n\n      // does not work properly in Node.js, causes 'Maximum call stack size exceeded' error\n      // min = Math.min.apply(null, obj.fImgBuf),\n      // max = Math.max.apply(null, obj.fImgBuf);\n\n      // create countor like in hist painter to allow palette drawing\n      this.fContour = {\n         arr: new Array(200),\n         rgba: this.rgba,\n         getLevels() { return this.arr; },\n         getPaletteColor(pal, zval) {\n            if (!this.arr || !this.rgba) return 'white';\n            const indx = Math.round((zval - this.arr[0]) / (this.arr[this.arr.length-1] - this.arr[0]) * (this.rgba.length-4)/4) * 4;\n            return '#' + toHex(this.rgba[indx], 1) + toHex(this.rgba[indx+1], 1) + toHex(this.rgba[indx+2], 1) + toHex(this.rgba[indx+3], 1);\n         }\n      };\n      for (let k = 0; k < 200; k++)\n         this.fContour.arr[k] = min + (max-min)/(200-1)*k;\n\n      if (min >= max) max = min + 1;\n\n      const z = this.getImageZoomRange(fp, obj.fConstRatio, obj.fWidth, obj.fHeight),\n            pr = isNodeJs()\n                 ? import('canvas').then(h => h.default.createCanvas(z.xmax - z.xmin, z.ymax - z.ymin))\n                 : new Promise(resolveFunc => {\n                    const c = document.createElement('canvas');\n                    c.width = z.xmax - z.xmin;\n                    c.height = z.ymax - z.ymin;\n                    resolveFunc(c);\n                 });\n\n      return pr.then(canvas => {\n         const context = canvas.getContext('2d'),\n               imageData = context.getImageData(0, 0, canvas.width, canvas.height),\n               arr = imageData.data;\n\n         for (let i = z.ymin; i < z.ymax; ++i) {\n            let dst = (z.ymax - i - 1) * (z.xmax - z.xmin) * 4;\n            const row = i * obj.fWidth;\n            for (let j = z.xmin; j < z.xmax; ++j) {\n               let iii = Math.round((obj.fImgBuf[row + j] - min) / (max - min) * nlevels) * 4;\n               // copy rgba value for specified point\n               arr[dst++] = this.rgba[iii++];\n               arr[dst++] = this.rgba[iii++];\n               arr[dst++] = this.rgba[iii++];\n               arr[dst++] = this.rgba[iii++];\n            }\n         }\n\n         context.putImageData(imageData, 0, 0);\n\n         return { url: canvas.toDataURL(), constRatio: obj.fConstRatio, can_zoom: true };\n      });\n   }\n\n   getImageZoomRange(fp, constRatio, width, height) {\n      const res = { xmin: 0, xmax: width, ymin: 0, ymax: height };\n      if (!fp) return res;\n\n      let offx = 0, offy = 0, sizex = width, sizey = height;\n\n      if (constRatio) {\n         const image_ratio = height/width,\n               frame_ratio = fp.getFrameHeight() / fp.getFrameWidth();\n\n         if (image_ratio > frame_ratio) {\n            const w2 = height / frame_ratio;\n            offx = Math.round((w2 - width)/2);\n            sizex = Math.round(w2);\n         } else {\n            const h2 = frame_ratio * width;\n            offy = Math.round((h2 - height)/2);\n            sizey = Math.round(h2);\n         }\n      }\n\n      if (fp.zoom_xmin !== fp.zoom_xmax) {\n         res.xmin = Math.min(width, Math.max(0, Math.round(fp.zoom_xmin * sizex) - offx));\n         res.xmax = Math.min(width, Math.max(0, Math.round(fp.zoom_xmax * sizex) - offx));\n      }\n      if (fp.zoom_ymin !== fp.zoom_ymax) {\n         res.ymin = Math.min(height, Math.max(0, Math.round(fp.zoom_ymin * sizey) - offy));\n         res.ymax = Math.min(height, Math.max(0, Math.round(fp.zoom_ymax * sizey) - offy));\n      }\n      return res;\n   }\n\n   /** @summary Produce data url from png buffer */\n   async makeUrlFromPngBuf(obj, fp) {\n      const buf = obj.fPngBuf;\n      let pngbuf = '';\n\n      if (isStr(buf))\n         pngbuf = buf;\n      else {\n         for (let k = 0; k < buf.length; ++k)\n            pngbuf += String.fromCharCode(buf[k] < 0 ? 256 + buf[k] : buf[k]);\n      }\n\n      const res = { url: 'data:image/png;base64,' + btoa_func(pngbuf), constRatio: obj.fConstRatio, can_zoom: fp && !isNodeJs() },\n            doc = getDocument();\n\n      if (!res.can_zoom || ((fp?.zoom_xmin === fp?.zoom_xmax) && (fp?.zoom_ymin === fp?.zoom_ymax)))\n         return res;\n\n      return new Promise(resolveFunc => {\n         const image = doc.createElement('img');\n\n         image.onload = () => {\n            const canvas = doc.createElement('canvas');\n            canvas.width = image.width;\n            canvas.height = image.height;\n\n            const context = canvas.getContext('2d');\n            context.drawImage(image, 0, 0);\n\n            const arr = context.getImageData(0, 0, image.width, image.height).data,\n                  z = this.getImageZoomRange(fp, res.constRatio, image.width, image.height),\n                  canvas2 = doc.createElement('canvas');\n            canvas2.width = z.xmax - z.xmin;\n            canvas2.height = z.ymax - z.ymin;\n\n            const context2 = canvas2.getContext('2d'),\n                  imageData2 = context2.getImageData(0, 0, canvas2.width, canvas2.height),\n                  arr2 = imageData2.data;\n\n            for (let i = z.ymin; i < z.ymax; ++i) {\n                let dst = (z.ymax - i - 1) * (z.xmax - z.xmin) * 4,\n                    src = ((image.height - i - 1) * image.width + z.xmin) * 4;\n                for (let j = z.xmin; j < z.xmax; ++j) {\n                   // copy rgba value for specified point\n                   arr2[dst++] = arr[src++];\n                   arr2[dst++] = arr[src++];\n                   arr2[dst++] = arr[src++];\n                   arr2[dst++] = arr[src++];\n                }\n            }\n\n            context2.putImageData(imageData2, 0, 0);\n\n            res.url = canvas2.toDataURL();\n\n            resolveFunc(res);\n         };\n\n         image.onerror = () => resolveFunc(res);\n\n         image.src = res.url;\n      });\n   }\n\n   /** @summary Draw image */\n   async drawImage() {\n      const obj = this.getObject(),\n            fp = this.getFramePainter(),\n            rect = fp?.getFrameRect() ?? this.getPadPainter().getPadRect();\n\n      this.wheel_zoomy = true;\n\n      if (obj._blob) {\n         // try to process blob data due to custom streamer\n         if ((obj._blob.length === 15) && !obj._blob[0]) {\n            obj.fImageQuality = obj._blob[1];\n            obj.fImageCompression = obj._blob[2];\n            obj.fConstRatio = obj._blob[3];\n            obj.fPalette = {\n                _typename: clTImagePalette,\n                fUniqueID: obj._blob[4],\n                fBits: obj._blob[5],\n                fNumPoints: obj._blob[6],\n                fPoints: obj._blob[7],\n                fColorRed: obj._blob[8],\n                fColorGreen: obj._blob[9],\n                fColorBlue: obj._blob[10],\n                fColorAlpha: obj._blob[11]\n            };\n\n            obj.fWidth = obj._blob[12];\n            obj.fHeight = obj._blob[13];\n            obj.fImgBuf = obj._blob[14];\n\n            if ((obj.fWidth * obj.fHeight !== obj.fImgBuf.length) ||\n                  (obj.fPalette.fNumPoints !== obj.fPalette.fPoints.length)) {\n               console.error(`TASImage _blob decoding error ${obj.fWidth * obj.fHeight} != ${obj.fImgBuf.length} ${obj.fPalette.fNumPoints} != ${obj.fPalette.fPoints.length}`);\n               delete obj.fImgBuf;\n               delete obj.fPalette;\n            }\n         } else if ((obj._blob.length === 3) && obj._blob[0]) {\n            obj.fPngBuf = obj._blob[2];\n            if (obj.fPngBuf?.length !== obj._blob[1]) {\n               console.error(`TASImage with png buffer _blob error ${obj._blob[1]} != ${obj.fPngBuf?.length}`);\n               delete obj.fPngBuf;\n            }\n         } else\n            console.error(`TASImage _blob len ${obj._blob.length} not recognized`);\n\n         delete obj._blob;\n      }\n\n      let promise;\n\n      if (obj.fImgBuf && obj.fPalette)\n         promise = this.makeUrlFromImageBuf(obj, fp);\n      else if (obj.fPngBuf)\n         promise = this.makeUrlFromPngBuf(obj, fp);\n      else\n         promise = Promise.resolve(null);\n\n      return promise.then(res => {\n         if (!res?.url)\n            return this;\n\n         const img = this.createG(!!fp)\n             .append('image')\n             .attr('href', res.url)\n             .attr('width', rect.width)\n             .attr('height', rect.height)\n             .attr('preserveAspectRatio', res.constRatio ? null : 'none');\n\n         if (!this.isBatchMode()) {\n            if (settings.MoveResize || settings.ContextMenu)\n               img.style('pointer-events', 'visibleFill');\n\n            if (res.can_zoom)\n               img.style('cursor', 'pointer');\n         }\n\n         assignContextMenu(this);\n\n         if (!fp || !res.can_zoom)\n            return this;\n\n         return this.drawColorPalette(this.options.Zscale, true).then(() => {\n            fp.setAxesRanges(create(clTAxis), 0, 1, create(clTAxis), 0, 1, null, 0, 0);\n            fp.createXY({ ndim: 2, check_pad_range: false });\n            return fp.addInteractivity();\n         });\n      });\n   }\n\n   /** @summary Fill TASImage context */\n   fillContextMenuItems(menu) {\n      const obj = this.getObject();\n      if (obj) {\n         menu.addchk(obj.fConstRatio, 'Const ratio', flag => {\n            obj.fConstRatio = flag;\n            this.interactiveRedraw('pad', `exec:SetConstRatio(${flag})`);\n         }, 'Change const ratio flag of image');\n      }\n      if (obj?.fPalette) {\n         menu.addchk(this.options.Zscale, 'Color palette', flag => {\n            this.options.Zscale = flag;\n            this.drawColorPalette(flag, true);\n         }, 'Toggle color palette');\n      }\n   }\n\n   /** @summary Checks if it makes sense to zoom inside specified axis range */\n   canZoomInside(axis, min, max) {\n      const obj = this.getObject();\n\n      if (!obj)\n         return false;\n\n      if (((axis === 'x') || (axis === 'y')) && (max - min > 0.01)) return true;\n\n      return false;\n   }\n\n   /** @summary Draw color palette\n     * @private */\n   async drawColorPalette(enabled, can_move) {\n      if (!this.isMainPainter())\n         return null;\n\n      if (!this.draw_palette) {\n         const pal = create(clTPaletteAxis);\n         Object.assign(pal, { fX1NDC: 0.91, fX2NDC: 0.95, fY1NDC: 0.1, fY2NDC: 0.9, fInit: 1 });\n         pal.fAxis.fChopt = '+';\n         this.draw_palette = pal;\n         this._color_palette = true; // to emulate behaviour of hist painter\n      }\n\n      let pal_painter = this.getPadPainter().findPainterFor(this.draw_palette);\n\n      if (!enabled) {\n         if (pal_painter) {\n            pal_painter.Enabled = false;\n            pal_painter.removeG(); // completely remove drawing without need to redraw complete pad\n         }\n         return null;\n      }\n\n      const fp = this.getFramePainter();\n\n      // keep palette width\n      if (can_move && fp) {\n         const pal = this.draw_palette;\n         pal.fX2NDC = fp.fX2NDC + 0.01 + (pal.fX2NDC - pal.fX1NDC);\n         pal.fX1NDC = fp.fX2NDC + 0.01;\n         pal.fY1NDC = fp.fY1NDC;\n         pal.fY2NDC = fp.fY2NDC;\n      }\n\n      if (pal_painter) {\n         pal_painter.Enabled = true;\n         return pal_painter.drawPave('');\n      }\n\n      const prev_name = this.selectCurrentPad(this.getPadName());\n\n      return TPavePainter.draw(this.getDom(), this.draw_palette).then(p => {\n         pal_painter = p;\n\n         this.selectCurrentPad(prev_name);\n         // mark painter as secondary - not in list of TCanvas primitives\n         pal_painter.setSecondary(this);\n\n         // make dummy redraw, palette will be updated only from histogram painter\n         pal_painter.redraw = function() {};\n      });\n   }\n\n   /** @summary Toggle colz draw option\n     * @private */\n   toggleColz() {\n      if (this.getObject()?.fPalette) {\n         this.options.Zscale = !this.options.Zscale;\n         return this.drawColorPalette(this.options.Zscale, true);\n      }\n   }\n\n   /** @summary Redraw image */\n   redraw() {\n      return this.drawImage();\n   }\n\n   /** @summary Process click on TASImage-defined buttons\n     * @desc may return promise or simply false */\n   clickButton(funcname) {\n      if (this.isMainPainter() && funcname === 'ToggleColorZ')\n         return this.toggleColz();\n\n      return false;\n   }\n\n   /** @summary Fill pad toolbar for TASImage */\n   fillToolbar() {\n      const pp = this.getPadPainter();\n      if (pp && this.getObject()?.fPalette) {\n         pp.addPadButton('th2colorz', 'Toggle color palette', 'ToggleColorZ');\n         pp.showPadButtons();\n      }\n   }\n\n   /** @summary Draw TASImage object */\n   static async draw(dom, obj, opt) {\n      const painter = new TASImagePainter(dom, obj, opt);\n      painter.setAsMainPainter();\n      painter.decodeOptions(opt);\n      return ensureTCanvas(painter, false)\n                 .then(() => painter.drawImage())\n                 .then(() => {\n                     painter.fillToolbar();\n                     return painter;\n                 });\n   }\n\n} // class TASImagePainter\n\nexport { TASImagePainter };\n"],"x_google_ignoreList":[0]}