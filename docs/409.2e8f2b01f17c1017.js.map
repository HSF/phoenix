{"version":3,"file":"409.2e8f2b01f17c1017.js","mappings":"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","names":["RPavePainter","RObjectPainter","drawContent","_this","this","_asyncToGenerator","drawPave","_this2","rect","getPadPainter","getPadRect","fp","getFramePainter","onFrame","v7EvalAttr","corner","visible","offsetx","v7EvalLength","width","offsety","height","pave_width","pave_height","createG","draw_g","classed","createv7AttLine","createv7AttFill","fr","getFrameRect","pave_x","pave_y","x","y","makeTranslate","append","attr","call","lineatt","func","fillatt","then","isBatchMode","settings","ContextMenu","paveContextMenu","on","evnt","addDragHandler","minwidth","minheight","redraw","d","sizeChanged","drag","changes","v7AttrChange","v7SendAttrChanges","selectChild","_this3","draw","dom","pave","opt","painter","ensureRCanvas","RLegendPainter","_this4","legend","getObject","textFont","v7EvalFont","size","color","align","pp","nlines","fEntries","length","fTitle","stepy","margin_x","setSize","startTextDrawingAsync","posy","drawText","latex","text","i","entry","w4","Math","round","objp","fLabel","fDrawableId","findSnap","fDrawable","fIO","fLine","fFill","fMarker","createv7AttMarker","fError","markeratt","create","finishTextDrawing","RPaveTextPainter","_this5","pavetext","fText","undefined","RHistStatsPainter","clearStat","stats_lines","addText","line","push","updateStatistic","reply","lines","drawStatistic","fillStatistic","_fast_drawing","obj","fLines","v7OfflineMode","main","getMainPainter","isFunc","gStyle","fOptStat","fOptFit","format","value","fmt","fStatFormat","fFitFormat","abs","toFixed","lastformat","res","floatToString","_this6","changeMask","nbit","mask","fShowMask","statsContextMenu","preventDefault","stopPropagation","createMenu","menu","action","bind","header","n","addchk","fillObjectExecMenu","show","_this7","first_stat","num_cols","maxlen","j","max","indexOf","parts","split","has_head","text_g","empty","selectAll","remove","max_hlen","slice","args","_expected_width","_args","post_process","ready","scaleTextDrawing","result_width","__expected_width","lpath","nrow","ncol","reason","_this8","isStr","v7NormalMode","req","_typename","nsREX","v7SubmitRequest","stats"],"ignoreList":[],"sourceRoot":"webpack:///","sources":["../node_modules/jsroot/modules/hist/RPavePainter.mjs"],"sourcesContent":["import { settings, isFunc, isStr, gStyle, nsREX } from '../core.mjs';\nimport { floatToString, makeTranslate } from '../base/BasePainter.mjs';\nimport { RObjectPainter } from '../base/RObjectPainter.mjs';\nimport { ensureRCanvas } from '../gpad/RCanvasPainter.mjs';\nimport { addDragHandler } from '../gpad/TFramePainter.mjs';\nimport { createMenu } from '../gui/menu.mjs';\n\n\nconst ECorner = { kTopLeft: 1, kTopRight: 2, kBottomLeft: 3, kBottomRight: 4 };\n\n/**\n * @summary Painter for RPave class\n *\n * @private\n */\n\nclass RPavePainter extends RObjectPainter {\n\n   /** @summary Draw pave content\n     * @desc assigned depending on pave class */\n   async drawContent() { return this; }\n\n   /** @summary Draw pave */\n   async drawPave() {\n      const rect = this.getPadPainter().getPadRect(),\n            fp = this.getFramePainter();\n\n      this.onFrame = fp && this.v7EvalAttr('onFrame', true);\n      this.corner = this.v7EvalAttr('corner', ECorner.kTopRight);\n\n      const visible = this.v7EvalAttr('visible', true),\n            offsetx = this.v7EvalLength('offsetX', rect.width, 0.02),\n            offsety = this.v7EvalLength('offsetY', rect.height, 0.02),\n            pave_width = this.v7EvalLength('width', rect.width, 0.3),\n            pave_height = this.v7EvalLength('height', rect.height, 0.3);\n\n      this.createG();\n\n      this.draw_g.classed('most_upper_primitives', true); // this primitive will remain on top of list\n\n      if (!visible)\n         return this;\n\n      this.createv7AttLine('border_');\n\n      this.createv7AttFill();\n\n      const fr = this.onFrame ? fp.getFrameRect() : rect;\n      let pave_x = 0, pave_y = 0;\n      switch (this.corner) {\n         case ECorner.kTopLeft:\n            pave_x = fr.x + offsetx;\n            pave_y = fr.y + offsety;\n            break;\n         case ECorner.kBottomLeft:\n            pave_x = fr.x + offsetx;\n            pave_y = fr.y + fr.height - offsety - pave_height;\n            break;\n         case ECorner.kBottomRight:\n            pave_x = fr.x + fr.width - offsetx - pave_width;\n            pave_y = fr.y + fr.height - offsety - pave_height;\n            break;\n         case ECorner.kTopRight:\n         default:\n            pave_x = fr.x + fr.width - offsetx - pave_width;\n            pave_y = fr.y + offsety;\n      }\n\n      makeTranslate(this.draw_g, pave_x, pave_y);\n\n      this.draw_g.append('svg:rect')\n                 .attr('x', 0)\n                 .attr('width', pave_width)\n                 .attr('y', 0)\n                 .attr('height', pave_height)\n                 .call(this.lineatt.func)\n                 .call(this.fillatt.func);\n\n      this.pave_width = pave_width;\n      this.pave_height = pave_height;\n\n      // here should be fill and draw of text\n\n      return this.drawContent().then(() => {\n         if (!this.isBatchMode()) {\n            // TODO: provide pave context menu as in v6\n            if (settings.ContextMenu && this.paveContextMenu)\n               this.draw_g.on('contextmenu', evnt => this.paveContextMenu(evnt));\n\n            addDragHandler(this, { x: pave_x, y: pave_y, width: pave_width, height: pave_height,\n                                   minwidth: 20, minheight: 20, redraw: d => this.sizeChanged(d) });\n         }\n\n         return this;\n      });\n   }\n\n   /** @summary Process interactive moving of the stats box */\n   sizeChanged(drag) {\n      this.pave_width = drag.width;\n      this.pave_height = drag.height;\n\n      const pave_x = drag.x,\n            pave_y = drag.y,\n            rect = this.getPadPainter().getPadRect(),\n            fr = this.onFrame ? this.getFramePainter().getFrameRect() : rect,\n            changes = {};\n      let offsetx = 0, offsety = 0;\n\n      switch (this.corner) {\n         case ECorner.kTopLeft:\n            offsetx = pave_x - fr.x;\n            offsety = pave_y - fr.y;\n            break;\n         case ECorner.kBottomLeft:\n            offsetx = pave_x - fr.x;\n            offsety = fr.y + fr.height - pave_y - this.pave_height;\n            break;\n         case ECorner.kBottomRight:\n            offsetx = fr.x + fr.width - pave_x - this.pave_width;\n            offsety = fr.y + fr.height - pave_y - this.pave_height;\n            break;\n         case ECorner.kTopRight:\n         default:\n            offsetx = fr.x + fr.width - pave_x - this.pave_width;\n            offsety = pave_y - fr.y;\n      }\n\n      this.v7AttrChange(changes, 'offsetX', offsetx / rect.width);\n      this.v7AttrChange(changes, 'offsetY', offsety / rect.height);\n      this.v7AttrChange(changes, 'width', this.pave_width / rect.width);\n      this.v7AttrChange(changes, 'height', this.pave_height / rect.height);\n      this.v7SendAttrChanges(changes, false); // do not invoke canvas update on the server\n\n      this.draw_g.selectChild('rect')\n                 .attr('width', this.pave_width)\n                 .attr('height', this.pave_height);\n\n      this.drawContent();\n   }\n\n   /** @summary Redraw RPave object */\n   async redraw(/* reason */) {\n      return this.drawPave();\n   }\n\n   /** @summary draw RPave object */\n   static async draw(dom, pave, opt) {\n      const painter = new RPavePainter(dom, pave, opt, 'pave');\n      return ensureRCanvas(painter, false).then(() => painter.drawPave());\n   }\n\n}\n\n\n/**\n * @summary Painter for RLegend class\n *\n * @private\n */\n\nclass RLegendPainter extends RPavePainter {\n\n   /** @summary draw RLegend content */\n   async drawContent() {\n      const legend = this.getObject(),\n            textFont = this.v7EvalFont('text', { size: 12, color: 'black', align: 22 }),\n            width = this.pave_width,\n            height = this.pave_height,\n            pp = this.getPadPainter();\n\n      let nlines = legend.fEntries.length;\n      if (legend.fTitle) nlines++;\n\n      if (!nlines || !pp) return this;\n\n      const stepy = height / nlines, margin_x = 0.02 * width;\n\n      textFont.setSize(height/(nlines * 1.2));\n      return this.startTextDrawingAsync(textFont, 'font').then(() => {\n         let posy = 0;\n\n         if (legend.fTitle) {\n            this.drawText({ latex: 1, width: width - 2*margin_x, height: stepy, x: margin_x, y: posy, text: legend.fTitle });\n            posy += stepy;\n         }\n\n         for (let i = 0; i < legend.fEntries.length; ++i) {\n            const entry = legend.fEntries[i], w4 = Math.round(width/4);\n            let objp = null;\n\n            this.drawText({ latex: 1, width: 0.75*width - 3*margin_x, height: stepy, x: 2*margin_x + w4, y: posy, text: entry.fLabel });\n\n            if (entry.fDrawableId !== 'custom')\n               objp = pp.findSnap(entry.fDrawableId, true);\n            else if (entry.fDrawable.fIO) {\n               objp = new RObjectPainter(this.getPadPainter(), entry.fDrawable.fIO);\n               if (entry.fLine) objp.createv7AttLine();\n               if (entry.fFill) objp.createv7AttFill();\n               if (entry.fMarker) objp.createv7AttMarker();\n            }\n\n            if (entry.fFill && objp?.fillatt) {\n               this.draw_g\n                  .append('svg:path')\n                  .attr('d', `M${Math.round(margin_x)},${Math.round(posy + stepy*0.1)}h${w4}v${Math.round(stepy*0.8)}h${-w4}z`)\n                  .call(objp.fillatt.func);\n            }\n\n            if (entry.fLine && objp?.lineatt) {\n               this.draw_g\n                  .append('svg:path')\n                  .attr('d', `M${Math.round(margin_x)},${Math.round(posy + stepy/2)}h${w4}`)\n                  .call(objp.lineatt.func);\n            }\n\n            if (entry.fError && objp?.lineatt) {\n               this.draw_g\n                  .append('svg:path')\n                  .attr('d', `M${Math.round(margin_x + width/8)},${Math.round(posy + stepy*0.2)}v${Math.round(stepy*0.6)}`)\n                  .call(objp.lineatt.func);\n            }\n\n            if (entry.fMarker && objp?.markeratt) {\n               this.draw_g.append('svg:path')\n                  .attr('d', objp.markeratt.create(margin_x + width/8, posy + stepy/2))\n                  .call(objp.markeratt.func);\n            }\n\n            posy += stepy;\n         }\n\n         return this.finishTextDrawing();\n      });\n   }\n\n   /** @summary draw RLegend object */\n   static async draw(dom, legend, opt) {\n      const painter = new RLegendPainter(dom, legend, opt, 'legend');\n      return ensureRCanvas(painter, false).then(() => painter.drawPave());\n   }\n\n} // class RLegendPainter\n\n\n/**\n * @summary Painter for RPaveText class\n *\n * @private\n */\n\nclass RPaveTextPainter extends RPavePainter {\n\n   /** @summary draw RPaveText content */\n   async drawContent() {\n      const pavetext = this.getObject(),\n            textFont = this.v7EvalFont('text', { size: 12, color: 'black', align: 22 }),\n            width = this.pave_width,\n            height = this.pave_height,\n            nlines = pavetext.fText.length;\n\n      if (!nlines) return;\n\n      const stepy = height / nlines, margin_x = 0.02 * width;\n\n      textFont.setSize(height/(nlines * 1.2));\n\n      return this.startTextDrawingAsync(textFont, 'font').then(() => {\n         for (let i = 0, posy = 0; i < pavetext.fText.length; ++i, posy += stepy)\n            this.drawText({ latex: 1, width: width - 2*margin_x, height: stepy, x: margin_x, y: posy, text: pavetext.fText[i] });\n\n         return this.finishTextDrawing(undefined, true);\n      });\n   }\n\n   /** @summary draw RPaveText object */\n   static async draw(dom, pave, opt) {\n      const painter = new RPaveTextPainter(dom, pave, opt, 'pavetext');\n      return ensureRCanvas(painter, false).then(() => painter.drawPave());\n   }\n\n} // class RPaveTextPainter\n\n/**\n * @summary Painter for RHistStats class\n *\n * @private\n */\n\nclass RHistStatsPainter extends RPavePainter {\n\n   /** @summary clear entries from stat box */\n   clearStat() {\n      this.stats_lines = [];\n   }\n\n   /** @summary add text entry to stat box */\n   addText(line) {\n      this.stats_lines.push(line);\n   }\n\n   /** @summary update statistic from the server */\n   updateStatistic(reply) {\n      this.stats_lines = reply.lines;\n      this.drawStatistic(this.stats_lines);\n   }\n\n   /** @summary fill statistic */\n   fillStatistic() {\n      const pp = this.getPadPainter();\n      if (pp?._fast_drawing) return false;\n\n      const obj = this.getObject();\n      if (obj.fLines !== undefined) {\n         this.stats_lines = obj.fLines;\n         delete obj.fLines;\n         return true;\n      }\n\n      if (this.v7OfflineMode()) {\n         const main = this.getMainPainter();\n         if (!isFunc(main?.fillStatistic)) return false;\n         // we take statistic from main painter\n         return main.fillStatistic(this, gStyle.fOptStat, gStyle.fOptFit);\n      }\n\n      // show lines which are exists, maybe server request will be received later\n      return (this.stats_lines !== undefined);\n   }\n\n   /** @summary format float value as string\n     * @private */\n   format(value, fmt) {\n      if (!fmt) fmt = 'stat';\n\n      switch (fmt) {\n         case 'stat' : fmt = gStyle.fStatFormat; break;\n         case 'fit': fmt = gStyle.fFitFormat; break;\n         case 'entries': if ((Math.abs(value) < 1e9) && (Math.round(value) === value)) return value.toFixed(0); fmt = '14.7g'; break;\n         case 'last': fmt = this.lastformat; break;\n      }\n\n      const res = floatToString(value, fmt || '6.4g', true);\n\n      this.lastformat = res[1];\n\n      return res[0];\n   }\n\n   /** @summary Draw content */\n   async drawContent() {\n      if (this.fillStatistic())\n         return this.drawStatistic(this.stats_lines);\n\n      return this;\n   }\n\n   /** @summary Change mask */\n   changeMask(nbit) {\n      const obj = this.getObject(), mask = (1<<nbit);\n      if (obj.fShowMask & mask)\n         obj.fShowMask = obj.fShowMask & ~mask;\n      else\n         obj.fShowMask = obj.fShowMask | mask;\n\n      if (this.fillStatistic())\n         this.drawStatistic(this.stats_lines);\n   }\n\n   /** @summary Context menu */\n   statsContextMenu(evnt) {\n      evnt.preventDefault();\n      evnt.stopPropagation(); // disable main context menu\n\n      createMenu(evnt, this).then(menu => {\n         const obj = this.getObject(),\n             action = this.changeMask.bind(this);\n\n         menu.header('Stat Box');\n\n         for (let n = 0; n < obj.fEntries.length; ++n)\n            menu.addchk((obj.fShowMask & (1<<n)), obj.fEntries[n], n, action);\n\n         return this.fillObjectExecMenu(menu);\n      }).then(menu => menu.show());\n   }\n\n   /** @summary Draw statistic */\n   async drawStatistic(lines) {\n      if (!lines) return this;\n      const textFont = this.v7EvalFont('stats_text', { size: 12, color: 'black', align: 22 }),\n            width = this.pave_width,\n            height = this.pave_height,\n            nlines = lines.length;\n      let first_stat = 0, num_cols = 0, maxlen = 0;\n\n      // adjust font size\n      for (let j = 0; j < nlines; ++j) {\n         const line = lines[j];\n         if (j > 0) maxlen = Math.max(maxlen, line.length);\n         if ((j === 0) || (line.indexOf('|') < 0)) continue;\n         if (first_stat === 0) first_stat = j;\n         const parts = line.split('|');\n         if (parts.length > num_cols)\n            num_cols = parts.length;\n      }\n\n      // for characters like 'p' or 'y' several more pixels required to stay in the box when drawn in last line\n      const stepy = height / nlines, margin_x = 0.02 * width;\n      let has_head = false,\n          text_g = this.draw_g.selectChild('.statlines');\n      if (text_g.empty())\n         text_g = this.draw_g.append('svg:g').attr('class', 'statlines');\n      else\n         text_g.selectAll('*').remove();\n\n      textFont.setSize(height/(nlines * 1.2));\n      return this.startTextDrawingAsync(textFont, 'font', text_g).then(() => {\n         if (nlines === 1)\n            this.drawText({ width, height, text: lines[0], latex: 1, draw_g: text_g });\n         else {\n            for (let j = 0; j < nlines; ++j) {\n               const posy = j*stepy;\n\n               if (first_stat && (j >= first_stat)) {\n                  const parts = lines[j].split('|');\n                  for (let n = 0; n < parts.length; ++n) {\n                     this.drawText({ align: 'middle', x: width * n / num_cols, y: posy, latex: 0,\n                                    width: width/num_cols, height: stepy, text: parts[n], draw_g: text_g });\n                  }\n               } else if (lines[j].indexOf('=') < 0) {\n                  if (j === 0) {\n                     has_head = true;\n                     const max_hlen = Math.max(maxlen, Math.round((width-2*margin_x)/stepy/0.65));\n                     if (lines[j].length > max_hlen + 5)\n                        lines[j] = lines[j].slice(0, max_hlen+2) + '...';\n                  }\n                  this.drawText({ align: (j === 0) ? 'middle' : 'start', x: margin_x, y: posy,\n                                 width: width - 2*margin_x, height: stepy, text: lines[j], draw_g: text_g });\n               } else {\n                  const parts = lines[j].split('='), args = [];\n\n                  for (let n = 0; n < 2; ++n) {\n                     const arg = {\n                        align: (n === 0) ? 'start' : 'end', x: margin_x, y: posy,\n                        width: width-2*margin_x, height: stepy, text: parts[n], draw_g: text_g,\n                        _expected_width: width-2*margin_x, _args: args,\n                        post_process(painter) {\n                        if (this._args[0].ready && this._args[1].ready)\n                           painter.scaleTextDrawing(1.05*(this._args[0].result_width && this._args[1].result_width)/this.__expected_width, this.draw_g);\n                        }\n                     };\n                     args.push(arg);\n                  }\n\n                  for (let n = 0; n < 2; ++n)\n                     this.drawText(args[n]);\n               }\n            }\n         }\n\n         let lpath = '';\n\n         if (has_head)\n            lpath += 'M0,' + Math.round(stepy) + 'h' + width;\n\n         if ((first_stat > 0) && (num_cols > 1)) {\n            for (let nrow = first_stat; nrow < nlines; ++nrow)\n               lpath += 'M0,' + Math.round(nrow * stepy) + 'h' + width;\n            for (let ncol = 0; ncol < num_cols - 1; ++ncol)\n               lpath += 'M' + Math.round(width / num_cols * (ncol + 1)) + ',' + Math.round(first_stat * stepy) + 'V' + height;\n         }\n\n         if (lpath) this.draw_g.append('svg:path').attr('d', lpath);\n\n         return this.finishTextDrawing(text_g);\n      });\n   }\n\n   /** @summary Redraw stats box */\n   async redraw(reason) {\n      if (reason && isStr(reason) && (reason.indexOf('zoom') === 0) && this.v7NormalMode()) {\n         const req = {\n            _typename: `${nsREX}RHistStatBoxBase::RRequest`,\n            mask: this.getObject().fShowMask // lines to show in stat box\n         };\n\n         this.v7SubmitRequest('stat', req, reply => this.updateStatistic(reply));\n      }\n\n      return this.drawPave();\n   }\n\n   /** @summary draw RHistStats object */\n   static async draw(dom, stats, opt) {\n      const painter = new RHistStatsPainter(dom, stats, opt, stats);\n      return ensureRCanvas(painter, false).then(() => painter.drawPave());\n   }\n\n} // class RHistStatsPainter\n\nexport { RPavePainter, RLegendPainter, RPaveTextPainter, RHistStatsPainter };\n"],"x_google_ignoreList":[0]}